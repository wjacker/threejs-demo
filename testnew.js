module.exports = !function(t) {
    function e(i) {
        if (n[i]) return n[i].exports;
        var r = n[i] = {
            i: i,
            l: false,
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, e),
        r.l = true,
        r.exports
    }
    var n = {};
    e.m = t,
    e.c = n,
    e.d = function(t, n, i) {
        e.o(t, n) || Object.defineProperty(t, n, {
            configurable: false,
            enumerable: true,
            get: i
        })
    },
    e.n = function(t) {
        var n = t && t.__esModule ?
        function() {
            return t.
        default
        }:
        function() {
            return t
        };
        return e.d(n, "a", n),
        n
    },
    e.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    },
    e.p = (self.__g_cdnHostL + "/h5tool/diy/"),
    e(e.s = "4OoW")
} ({
    "+5Cw": function(t, e, n) {
        "use strict";
        e.a = "varying vec2 vUv;\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\\n"
    },
    "+8dW": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i = function() {
            function t(t) {
                this.value = [],
                this.netValue = [],
                this.updateTimestamp = [],
                this.object = t
            }
            return Object.defineProperty(t.prototype, "parent", {
                get: function() {
                    return this.object.parent ? this.object.parent.attribute: undefined
                },
                enumerable: true,
                configurable: true
            }),
            t.prototype.setValue = function(e, n) {
                var i = t.valueMap[e];
                undefined === i && (t.valueMap[e] = t.valueCount, i = t.valueCount, t.valueCount++),
                this.value[i] = n,
                this.updateTimestamp[i] = -1
            },
            t.prototype.getValue = function(e) {
                var n = t.valueMap[e];
                return this.value[n]
            },
            t.prototype.getNetValue = function(e, n) {
                undefined === n && (n = false);
                var i = t.valueMap[e];
                if (undefined !== i) {
                    var r = this.object.sceneNode;
                    if (undefined === r) {
                        if (!n) return;
                        var a;
                        return function t(e) {
                            undefined !== e.value[i] && (a = e.value[i]),
                            undefined !== e.parent && t(e.parent)
                        } (this),
                        a
                    }
                    return n ? (r.sceneDoc.updateScene(), this.netValue[i]) : this.netValue[i]
                }
            },
            t.prototype.markAllDirty = function() {
                for (var e = 0; e < t.valueCount; e++) this.updateTimestamp[e] = -1
            },
            t.valueMap = {},
            t.valueCount = 0,
            t
        } ()
    },
    "+Czl": function(t, e, n) {
        "use strict";
        e.a = "float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\troughnessFactor *= texelRoughness.g;\\n#endif\\n"
    },
    "+Ro2": function(t, e, n) {
        "use strict";

        function i(t, e) {
            r.a.call(this),
            this.v1 = t,
            this.v2 = e
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Lk8y");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isLineCurve = true,
        i.prototype.getPoint = function(t) {
            if (1 === t) return this.v2.clone();
            var e = this.v2.clone().sub(this.v1);
            return e.multiplyScalar(t).add(this.v1),
            e
        },
        i.prototype.getPointAt = function(t) {
            return this.getPoint(t)
        },
        i.prototype.getTangent = function(t) {
            return this.v2.clone().sub(this.v1).normalize()
        }
    },
    "Box3": function(t, e, n) {
        "use strict";

        function i(t, e) {
            this.min = undefined !== t ? t: new r.a(1 / 0, 1 / 0, 1 / 0),
            this.max = undefined !== e ? e: new r.a( - 1 / 0, -Infinity, -Infinity)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Vector3"),
        a = n("Sphere");
        Object.assign(i.prototype, {
            isBox3: true,
            set: function(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            },
            setFromArray: function(t) {
                for (var e = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -Infinity,
                a = -Infinity,
                o = -Infinity,
                s = 0,
                u = t.length; s < u; s += 3) {
                    var c = t[s],
                    h = t[s + 1],
                    l = t[s + 2];
                    c < e && (e = c),
                    h < n && (n = h),
                    l < i && (i = l),
                    c > r && (r = c),
                    h > a && (a = h),
                    l > o && (o = l)
                }
                return this.min.set(e, n, i),
                this.max.set(r, a, o),
                this
            },
            setFromBufferAttribute: function(t) {
                for (var e = 1 / 0,
                n = 1 / 0,
                i = 1 / 0,
                r = -Infinity,
                a = -Infinity,
                o = -Infinity,
                s = 0,
                u = t.count; s < u; s++) {
                    var c = t.getX(s),
                    h = t.getY(s),
                    l = t.getZ(s);
                    c < e && (e = c),
                    h < n && (n = h),
                    l < i && (i = l),
                    c > r && (r = c),
                    h > a && (a = h),
                    l > o && (o = l)
                }
                return this.min.set(e, n, i),
                this.max.set(r, a, o),
                this
            },
            setFromBufferAttributeRange: function(t, e, n) {
                for (var i = 1 / 0,
                r = 1 / 0,
                a = 1 / 0,
                o = -Infinity,
                s = -Infinity,
                u = -Infinity,
                c = e,
                h = e + n; c < h; c++) {
                    var l = t.getX(c),
                    f = t.getY(c),
                    p = t.getZ(c);
                    l < i && (i = l),
                    f < r && (r = f),
                    p < a && (a = p),
                    l > o && (o = l),
                    f > s && (s = f),
                    p > u && (u = p)
                }
                return this.min.set(i, r, a),
                this.max.set(o, s, u),
                this
            },
            setFromIndexBufferAttributeRange: function(t, e, n, i) {
                for (var r = 1 / 0,
                a = 1 / 0,
                o = 1 / 0,
                s = -Infinity,
                u = -Infinity,
                c = -Infinity,
                h = n,
                l = n + i; h < l; h++) {
                    var f = e.array[h],
                    p = t.getX(f),
                    d = t.getY(f),
                    m = t.getZ(f);
                    p < r && (r = p),
                    d < a && (a = d),
                    m < o && (o = m),
                    p > s && (s = p),
                    d > u && (u = d),
                    m > c && (c = m)
                }
                return this.min.set(r, a, o),
                this.max.set(s, u, c),
                this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0,
                n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new r.a;
                return function(e, n) {
                    var i = t.copy(n).multiplyScalar(.5);
                    return this.min.copy(e).sub(i),
                    this.max.copy(e).add(i),
                    this
                }
            } (),
            setFromObject: function(t) {
                return this.makeEmpty(),
                this.expandByObject(t)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0,
                this.max.x = this.max.y = this.max.z = -Infinity,
                this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function(t) {
                var e = t || new r.a;
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                var e = t || new r.a;
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            },
            expandByVector: function(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            },
            expandByScalar: function(t) {
                return this.min.addScalar( - t),
                this.max.addScalar(t),
                this
            },
            expandByObject: function() {
                var t = new r.a;
                return function(e) {
                    var n = this;
                    return e.updateMatrixWorld(true),
                    e.traverse(function(e) {
                        var i, r, a = e.geometry;
                        if (undefined !== a) if (a.isGeometry) {
                            var o = a.vertices;
                            for (i = 0, r = o.length; i < r; i++) t.copy(o[i]),
                            t.applyMatrix4(e.matrixWorld),
                            n.expandByPoint(t)
                        } else if (a.isBufferGeometry) {
                            var s = a.attributes.position;
                            if (undefined !== s) for (i = 0, r = s.count; i < r; i++) t.fromBufferAttribute(s, i).applyMatrix4(e.matrixWorld),
                            n.expandByPoint(t)
                        }
                    }),
                    this
                }
            } (),
            containsPoint: function(t) {
                return ! (t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
            },
            getParameter: function(t, e) {
                return (e || new r.a).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(t) {
                return ! (t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
            },
            intersectsSphere: function() {
                var t = new r.a;
                return function(e) {
                    return this.clampPoint(e.center, t),
                    t.distanceToSquared(e.center) <= e.radius * e.radius
                }
            } (),
            intersectsPlane: function(t) {
                var e, n;
                return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x),
                t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y),
                t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z),
                e <= t.constant && n >= t.constant
            },
            clampPoint: function(t, e) {
                return (e || new r.a).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new r.a;
                return function(e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            } (),
            getBoundingSphere: function() {
                var t = new r.a;
                return function(e) {
                    var n = e || new a.a;
                    return this.getCenter(n.center),
                    n.radius = .5 * this.getSize(t).length(),
                    n
                }
            } (),
            intersect: function(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this.isEmpty() && this.makeEmpty(),
                this
            },
            union: function(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            },
            applyMatrix4: function() {
                var t = [new r.a, new r.a, new r.a, new r.a, new r.a, new r.a, new r.a, new r.a];
                return function(e) {
                    return this.isEmpty() ? this: (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                }
            } (),
            translate: function(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        })
    },
    "+mP+": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_SKINNING\\n\\tmat4 skinMatrix = mat4( 0.0 );\\n\\tskinMatrix += skinWeight.x * boneMatX;\\n\\tskinMatrix += skinWeight.y * boneMatY;\\n\\tskinMatrix += skinWeight.z * boneMatZ;\\n\\tskinMatrix += skinWeight.w * boneMatW;\\n\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n"
    },
    "+oY6": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return o
        });
        var i = n("ytBM"),
        r = n("coYL"),
        a = new r.a,
        o = function() {
            function t(t, e) {
                this.listener = [],
                this.configuration = e,
                this.bus = i.a.getInstance(),
                this.target = t
            }
            return Object.defineProperty(t.prototype, "values", {
                get: function() {
                    return this.configuration
                },
                enumerable: true,
                configurable: true
            }),
            t.prototype.addValueListener = function(t, e) {
                var n = this;
                if (!e) throw "callback is not set";
                var i = function(i) {
                    n.matchPath(t, i.configName) && e(i.value)
                };
                this.bus.on(a, i),
                this.listener.push({
                    originCallBack: e,
                    callBack: i,
                    path: t
                })
            },
            t.prototype.removeValueListener = function(t, e) {
                var n = this;
                this.listener = this.listener.filter(function(i, r) {
                    var o = i.originCallBack === e && i.path === t;
                    return o && n.bus.off(a, i.callBack),
                    !o
                })
            },
            t.prototype.matchPath = function(t, e) {
                if (t === e) return ! 0;
                for (var n = e.split("/"), i = t.split("/"), r = 0; r < i.length; r++) {
                    if (i[r] !== n[r]) return ! 1
                }
                return ! 0
            },
            t.prototype.setValue = function(t, e) {
                this.getConfigurationOption(this.configuration, t, false)[this.getOptionName(t)] = e,
                this.bus.emit(a, {
                    target: this.target,
                    configName: t,
                    value: e
                })
            },
            t.prototype.setAllValues = function(t) {
                this.configuration = t,
                this.bus.emit(a, {
                    target: this.target,
                    configName: "",
                    value: t
                })
            },
            t.prototype.getValue = function(t, e) {
                var n = this.getConfigurationOption(this.configuration, t, true);
                if (undefined === n) return e;
                var i = this.getOptionName(t),
                r = n[i];
                return undefined === r ? e: r
            },
            t.prototype.getConfigurationOption = function(t, e, n) {
                var i, r = t;
                if ( - 1 !== e.indexOf("/")) for (var a = e.split("/"), o = 0; o < a.length; o++) {
                    var s = a[o];
                    if (o === a.length - 1) {
                        i = r;
                        break
                    }
                    if (!r[s]) {
                        if (n) return;
                        r[s] = {}
                    }
                    r = r[s]
                } else i = r;
                return i
            },
            t.prototype.getOptionName = function(t) {
                return - 1 !== t.indexOf("/") ? t.split("/").pop() : t
            },
            t
        } ()
    },
    "/E3y": function(t, e, n) {
        "use strict";
        n.d(e, "t",
        function() {
            return p
        });
        var i = n("auUc"),
        r = (n.n(i), n("ytBM"));
        n.d(e, "f",
        function() {
            return r.a
        });
        var a = n("+oY6");
        n.d(e, "e",
        function() {
            return a.a
        });
        var o = n("ChZQ");
        n.d(e, "o",
        function() {
            return o.a
        });
        var s = n("4wub");
        n.d(e, "p",
        function() {
            return s.a
        });
        var u = n("DtoS");
        n.d(e, "b",
        function() {
            return u.a
        }),
        n.d(e, "q",
        function() {
            return u.b
        });
        var c = n("PopGeometry");
        n.d(e, "l",
        function() {
            //PopModel;
            return c.c
        }),
        n.d(e, "m",
        function() {
            //PopModelBlock
            return c.d
        }),
        n.d(e, "k",
        function() {
            //PopMesh
            return c.b
        }),
        n.d(e, "j",
        function() {
            //PopGeometry
            return c.a
        }),
        n.d(e, "n",
        function() {
            //PopPhongMaterial
            return c.e
        });
        var h = n("3JDn");
        n.d(e, "h",
        function() {
            return h.a
        }),
        n.d(e, "i",
        function() {
            return h.b
        });
        var l = n("UI9A");
        n.d(e, "c",
        function() {
            return l.a
        }),
        n.d(e, "d",
        function() {
            return l.b
        }),
        n.d(e, "g",
        function() {
            return l.c
        }),
        n.d(e, "r",
        function() {
            return l.d
        }),
        n.d(e, "s",
        function() {
            return l.e
        });
        var f = n("Mnzq");
        n.d(e, "a",
        function() {
            return f.a
        });
        var p = "ExaGraphics Graphics System"
    },
    "/Ev4": function(t, e, n) {
        "use strict";
        e.a = "varying vec2 vUv;\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n"
    },
    "/Ni5": function(t, e, n) {
        "use strict";

        function i(t, e) {
            return e / (2 * Math.tan(t.fov * r / 2))
        }
        e.a = i;
        var r = Math.PI / 180
    },
    "/bYS": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i = {
            enabled: false,
            files: {},
            add: function(t, e) { ! 1 !== this.enabled && (this.files[t] = e)
            },
            get: function(t) {
                if (false !== this.enabled) return this.files[t]
            },
            remove: function(t) {
                delete this.files[t]
            },
            clear: function() {
                this.files = {}
            }
        }
    },
    "LineBasicMaterial": function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.type = "LineBasicMaterial",
            this.color = new a.a(16777215),
            this.linewidth = 1,
            this.linecap = "round",
            this.linejoin = "round",
            this.lights = false,
            this.setValues(t)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Material"),
        a = n("Color");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isLineBasicMaterial = true,
        i.prototype.copy = function(t) {
            return r.a.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.linewidth = t.linewidth,
            this.linecap = t.linecap,
            this.linejoin = t.linejoin,
            this
        }
    },
    "/wr7": function(t, e, n) {
        "use strict";

        function i(t) {
            o.a.call(this),
            this.currentPoint = new Vector2(),
            t && this.fromPoints(t)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("HDm3"),
        o = n("XAHe");
        i.prototype = r.a,
        r.a.constructor = i
    },
    "PolyhedronGeometry||PolyhedronBufferGeometry": function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            a.a.call(this),
            this.type = "PolyhedronGeometry",
            this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: i
            },
            this.fromBufferGeometry(new r(t, e, n, i)),
            this.mergeVertices()
        }

        function r(t, e, n, i) {
            function r(t, e, n, i) {
                var r, a, o = Math.pow(2, i),
                s = [];
                for (r = 0; r <= o; r++) {
                    s[r] = [];
                    var u = t.clone().lerp(n, r / o),
                    c = e.clone().lerp(n, r / o),
                    l = o - r;
                    for (a = 0; a <= l; a++) s[r][a] = 0 === a && r === o ? u: u.clone().lerp(c, a / l)
                }
                for (r = 0; r < o; r++) for (a = 0; a < 2 * (o - r) - 1; a++) {
                    var f = Math.floor(a / 2);
                    a % 2 == 0 ? (h(s[r][f + 1]), h(s[r + 1][f]), h(s[r][f])) : (h(s[r][f + 1]), h(s[r + 1][f + 1]), h(s[r + 1][f]))
                }
            }

            function a() {
                for (var t = 0; t < g.length; t += 6) {
                    var e = g[t + 0],
                    n = g[t + 2],
                    i = g[t + 4],
                    r = Math.max(e, n, i),
                    a = Math.min(e, n, i);
                    r > .9 && a < .1 && (e < .2 && (g[t + 0] += 1), n < .2 && (g[t + 2] += 1), i < .2 && (g[t + 4] += 1))
                }
            }

            function h(t) {
                v.push(t.x, t.y, t.z)
            }

            function l(e, n) {
                var i = 3 * e;
                n.x = t[i + 0],
                n.y = t[i + 1],
                n.z = t[i + 2]
            }

            function f() {
                for (var t = new u.a,
                e = new u.a,
                n = new u.a,
                i = new u.a,
                r = new Vector2(),
                a = new Vector2(),
                o = new Vector2(),
                s = 0,
                h = 0; s < v.length; s += 9, h += 6) {
                    t.set(v[s + 0], v[s + 1], v[s + 2]),
                    e.set(v[s + 3], v[s + 4], v[s + 5]),
                    n.set(v[s + 6], v[s + 7], v[s + 8]),
                    r.set(g[h + 0], g[h + 1]),
                    a.set(g[h + 2], g[h + 3]),
                    o.set(g[h + 4], g[h + 5]),
                    i.copy(t).add(e).add(n).divideScalar(3);
                    var l = d(i);
                    p(r, h + 0, t, l),
                    p(a, h + 2, e, l),
                    p(o, h + 4, n, l)
                }
            }

            function p(t, e, n, i) {
                i < 0 && 1 === t.x && (g[e] = t.x - 1),
                0 === n.x && 0 === n.z && (g[e] = i / 2 / Math.PI + .5)
            }

            function d(t) {
                return Math.atan2(t.z, -t.x)
            }

            function m(t) {
                return Math.atan2( - t.y, Math.sqrt(t.x * t.x + t.z * t.z))
            }
            o.a.call(this),
            this.type = "PolyhedronBufferGeometry",
            this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: i
            },
            n = n || 1,
            i = i || 0;
            var v = [],
            g = []; !
            function(t) {
                for (var n = new u.a,
                i = new u.a,
                a = new u.a,
                o = 0; o < e.length; o += 3) l(e[o + 0], n),
                l(e[o + 1], i),
                l(e[o + 2], a),
                r(n, i, a, t)
            } (i),
            function(t) {
                for (var e = new u.a,
                n = 0; n < v.length; n += 3) e.x = v[n + 0],
                e.y = v[n + 1],
                e.z = v[n + 2],
                e.normalize().multiplyScalar(t),
                v[n + 0] = e.x,
                v[n + 1] = e.y,
                v[n + 2] = e.z
            } (n),
            function() {
                for (var t = new u.a,
                e = 0; e < v.length; e += 3) {
                    t.x = v[e + 0],
                    t.y = v[e + 1],
                    t.z = v[e + 2];
                    var n = d(t) / 2 / Math.PI + .5,
                    i = m(t) / Math.PI + .5;
                    g.push(n, 1 - i)
                }
                f(),
                a()
            } (),
            this.addAttribute("position", new s.b(v, 3)),
            this.addAttribute("normal", new s.b(v.slice(), 3)),
            this.addAttribute("uv", new s.b(g, 2)),
            0 === i ? this.computeVertexNormals() : this.normalizeNormals()
        }
        n.d(e, "a",
        function() {
            return r
        });
        var a = n("Geometry"),
        o = n("BufferGeometry"),
        s = n("BufferAttribute"),
        u = n("Vector3"),
        i.prototype = Object.create(a.a.prototype),
        i.prototype.constructor = i,
        r.prototype = Object.create(o.a.prototype),
        r.prototype.constructor = r
    },
    "07ZH": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return u
        });
        var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        r = n("TQJV"),
        a = new i.I,
        o = new i.I,
        s = new i.I,
        u = function() {
            function t() {
                var t = this;
                this.onMouseMove = function(e) {
                    o.set(e.clientX, e.clientY),
                    s.copy(o).sub(a),
                    0 === t.mouseButton && t.leftMouseMove(s),
                    2 === t.mouseButton && t.RightMouseMove(s),
                    a.copy(o)
                },
                this.onMouseDown = function(e) {
                    a.set(e.clientX, e.clientY),
                    t.mouseButton = e.button
                },
                this.onMouseUp = function(e) {
                    t.mouseUp(),
                    t.mouseButton = -1
                },
                this.onMouseWheel = function(e) {
                    var n = 0;
                    undefined !== e.wheelDelta ? n = e.wheelDelta: undefined !== e.deltaY && (n = -e.deltaY),
                    n = n > 0 ? 1.1 : .9,
                    t.mouseWheel(n)
                },
                this.onKeyDown = function(e) {
                    t.keyDown(e.keyCode)
                },
                this.onKeyUp = function(t) {},
                this.loopFlagMap = new Map,
                this.eventLoop = function(e) {
                    var n = t.loopFlagMap.get(e.keyCode);
                    if (undefined === n || -1 === n) {
                        var i = function n() {
                            t.onKeyDown(e),
                            t.loopFlagMap.set(e.keyCode, requestAnimationFrame(n))
                        };
                        t.loopFlagMap.set(e.keyCode, requestAnimationFrame(i))
                    }
                },
                this.cancelLoop = function(e) {
                    var n = t.loopFlagMap.get(e.keyCode);
                    undefined !== n && -1 !== n && (cancelAnimationFrame(n), t.loopFlagMap.delete(e.keyCode)),
                    t.onKeyUp(e),
                    t.loopFlagMap.size
                },
                this.handler = null,
                this.mouseButton = -1,
                this.controller = null
            }
            return t.prototype.setCameraController = function(t) {
                this.controller = t,
                this.handler = this.controller.viewer.getCanvasElement()
            },
            t.prototype.activate = function(t) {
                undefined === t && (t = true),
                this.bind()
            },
            t.prototype.deactivate = function() {
                this.unbind()
            },
            t.prototype.mouseWheel = function(t) {},
            t.prototype.mouseDown = function() {},
            t.prototype.mouseUp = function() {},
            t.prototype.leftMouseMove = function(t) {},
            t.prototype.RightMouseMove = function(t) {},
            t.prototype.keyDown = function(t) {
                t !== r.a.W && t !== r.a.ARROW_UP || this.controller.move(s.set(0, -4)),
                t !== r.a.S && t !== r.a.ARROW_DOWN || this.controller.move(s.set(0, 4)),
                t !== r.a.A && t !== r.a.ARROW_LEFT || this.controller.move(s.set( - 4, 0)),
                t !== r.a.D && t !== r.a.ARROW_RIGHT || this.controller.move(s.set(4, 0)),
                t !== r.a.Q && t !== r.a.E || this.keyQEDown(t === r.a.Q)
            },
            t.prototype.keyQEDown = function(t) {},
            t.prototype.bind = function() {
                var t = this.handler;
                this.mouseButton = -1,
                t.addEventListener("mousemove", this.onMouseMove, false),
                t.addEventListener("mousedown", this.onMouseDown, false),
                t.addEventListener("mouseup", this.onMouseUp, false),
                t.addEventListener("mousewheel", this.onMouseWheel, false),
                t.addEventListener("keydown", this.eventLoop, false),
                t.addEventListener("keyup", this.cancelLoop, false)
            },
            t.prototype.unbind = function() {
                this.mouseButton = -1,
                this.handler.removeEventListener("mousemove", this.onMouseMove),
                this.handler.removeEventListener("mousedown", this.onMouseDown),
                this.handler.removeEventListener("mouseup", this.onMouseUp),
                this.handler.removeEventListener("mousewheel", this.onMouseWheel),
                this.handler.removeEventListener("keydown", this.eventLoop),
                this.handler.removeEventListener("keyup", this.cancelLoop)
            },
            t
        } ()
    },
    "0CTy": function(t, e, n) {
        "use strict";
        e.a = "#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n"
    },
    "0P0p": function(t, e, n) {
        "use strict";
        e.a = "varying vec2 vUv;\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n"
    },
    "0atI": function(t, e, n) {
        "use strict";

        function i(t, e) {
            o.a.call(this),
            this.light = t,
            this.light.updateMatrixWorld(),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = false;
            var n = new h.a(e);
            n.rotateY(.5 * Math.PI);
            var i = new c.a({
                vertexColors: u._60,
                wireframe: true
            }),
            r = n.getAttribute("position"),
            a = new Float32Array(3 * r.count);
            n.addAttribute("color", new l.a(a, 3)),
            this.add(new s.a(n, i)),
            this.update()
        }
        var r = n("Vector3"),
        a = n("Color"),
        o = n("Object3D"),
        s = n("Mesh"),
        u = n("RBSo"),
        c = n("MeshBasicMaterial"),
        h = n("OctahedronGeometry||OctahedronBufferGeometry"),
        l = n("BufferAttribute");
        i.prototype = Object.create(o.a.prototype),
        i.prototype.constructor = i,
        i.prototype.dispose = function() {
            this.children[0].geometry.dispose(),
            this.children[0].material.dispose()
        },
        i.prototype.update = function() {
            var t = new r.a,
            e = new a.a,
            n = new a.a;
            return function() {
                var i = this.children[0],
                r = i.geometry.getAttribute("color");
                e.copy(this.light.color),
                n.copy(this.light.groundColor);
                for (var a = 0,
                o = r.count; a < o; a++) {
                    var s = a < o / 2 ? e: n;
                    r.setXYZ(a, s.r, s.g, s.b)
                }
                i.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()),
                r.needsUpdate = true
            }
        } ()
    },
    "0bni": function(t, e, n) {
        "use strict";

        function i(t) {
            a.a.call(this),
            this.light = t,
            this.light.updateMatrixWorld(),
            this.matrix = t.matrixWorld,
            this.matrixAutoUpdate = false;
            for (var e = new c.a,
            n = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, r = 1; i < 32; i++, r++) {
                var h = i / 32 * Math.PI * 2,
                l = r / 32 * Math.PI * 2;
                n.push(Math.cos(h), Math.sin(h), 1, Math.cos(l), Math.sin(l), 1)
            }
            e.addAttribute("position", new u.b(n, 3));
            var f = new s.a({
                fog: false
            });
            this.cone = new o.a(e, f),
            this.add(this.cone),
            this.update()
        }
        var r = n("Vector3"),
        a = n("Object3D"),
        o = n("LineSegments"),
        s = n("LineBasicMaterial"),
        u = n("BufferAttribute"),
        c = n("BufferGeometry");
        i.prototype = Object.create(a.a.prototype),
        i.prototype.constructor = i,
        i.prototype.dispose = function() {
            this.cone.geometry.dispose(),
            this.cone.material.dispose()
        },
        i.prototype.update = function() {
            var t = new r.a,
            e = new r.a;
            return function() {
                this.light.updateMatrixWorld();
                var n = this.light.distance ? this.light.distance: 1e3,
                i = n * Math.tan(this.light.angle);
                this.cone.scale.set(i, i, n),
                t.setFromMatrixPosition(this.light.matrixWorld),
                e.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(e.sub(t)),
                this.cone.material.color.copy(this.light.color)
            }
        } ()
    },
    "0dFb": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return a
        });
        var i = n("sz/p"),
        r = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        a = function(t) {
            function e(e) {
                undefined === e && (e = {});
                var n = t.call(this) || this;
                n.name = "RenderPass",
                n.needsSwap = true;
                var i = e.overrideMaterial,
                r = e.clear,
                a = undefined === r || r,
                o = e.clearDepth,
                s = undefined !== o && o,
                u = e.clearColor;
                return n.overrideMaterial = i,
                n.clear = a,
                n.clearDepth = s,
                n.clearColor = u,
                n.clearDepth = s,
                n
            }
            return r(e, t),
            e.prototype.render = function(t, e) {
                var n = this.scene,
                i = this.camera,
                r = this.renderToScreen ? null: e,
                a = n.overrideMaterial;
                if (this.clear) {
                    var o = undefined,
                    s = undefined;
                    undefined !== this.clearColor && (o = t.getClearColor().getHex(), s = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)),
                    t.setRenderTarget(r),
                    t.clear(),
                    undefined !== this.clearColor && t.setClearColor(o, s)
                } else this.clearDepth && (t.setRenderTarget(r), t.clearDepth());
                n.overrideMaterial = this.overrideMaterial,
                t.render(n, i, r, false),
                n.overrideMaterial = a
            },
            e
        } (i.a)
    },
    "0opt": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_SKINNING\\n\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif"
    },
    "2Jtw": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return v
        });
        var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        r = n("v504"),
        a = n("sz/p"),
        o = n("LL6t"),
        s = n("SvK/"),
        u = n("b+DU"),
        c = n("aPws"),
        h = n("/Ni5"),
        l = n("0dFb"),
        f = n("2rQf"),
        p = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        d = 8,
        m = function(t) {
            function e() {
                var e = t.call(this, o.a) || this;
                return e.clear = false,
                e.material.transparent = true,
                e.material.depthTest = false,
                e.material.depthWrite = false,
                e.material.blending = i.g,
                e.material.blendSrc = i.k,
                e.material.blendDst = i.L,
                e.material.blendEquation = i.a,
                e.material.blendSrcAlpha = i.j,
                e.material.blendDstAlpha = i.L,
                e.material.blendEquationAlpha = i.a,
                e
            }
            return p(e, t),
            e
        } (f.a),
        v = function(t) {
            function e(e) {
                undefined === e && (e = {});
                var n = t.call(this) || this;
                return n.computePass = new f.a(u.a),
                n.vBlurPass = new f.a(s.a),
                n.hBlurPass = new f.a(s.a),
                n.options = {},
                n.renderToScreen = false,
                n.depthPass = new l.a({
                    overrideMaterial: new i.s({
                        depthPacking: i.y,
                        blending: i.v
                    }),
                    clearColor: 16777215,
                    clearAlpha: 1
                }),
                n.depthTarget = new r.a(1, 1, {
                    minFilter: i.o,
                    magFilter: i.o
                }),
                n.computePass.material.extensions.derivatives = true,
                n.computePass.uniforms.depthMap.value = n.depthTarget.texture,
                n.computePass.uniforms.noiseMap.value = Object(c.a)(d),
                n.computeTarget = new r.a(1, 1, {
                    minFilter: i.o,
                    magFilter: i.o
                }),
                n.hBlurPass.uniforms.axis.value.set(1, 0),
                n.hBlurPass.uniforms.map.value = n.computeTarget.texture,
                n.hBlurPass.uniforms.depthMap.value = n.depthTarget.texture,
                n.hBlurTarget = new r.a(1, 1, {
                    minFilter: i.o,
                    magFilter: i.o
                }),
                n.vBlurPass.uniforms.axis.value.set(0, 1),
                n.vBlurPass.uniforms.map.value = n.hBlurTarget.texture,
                n.vBlurPass.uniforms.depthMap.value = n.depthTarget.texture,
                n.vBlurTarget = new r.a(1, 1, {
                    minFilter: i.o,
                    magFilter: i.o
                }),
                n.blendPass = new m,
                n.setOptions({
                    aoBias: .01,
                    aoRadius: .5,
                    aoIntensity: .4,
                    blurKernalRadius: 4,
                    blurEdgeSharpness: .25
                }),
                n
            }
            return p(e, t),
            Object.defineProperty(e.prototype, "aoBias", {
                get: function() {
                    return this.options.aoBias
                },
                set: function(t) {
                    this.options.aoBias = t,
                    this.computePass.uniforms.bias.value = t
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(e.prototype, "aoRadius", {
                get: function() {
                    return this.options.aoRadius
                },
                set: function(t) {
                    this.options.aoRadius = t,
                    this.computePass.uniforms.radius.value = t,
                    this.computePass.uniforms.intensityDivR6.value = this.options.aoIntensity / Math.pow(t, 6)
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(e.prototype, "aoIntensity", {
                get: function() {
                    return this.options.aoIntensity
                },
                set: function(t) {
                    this.options.aoIntensity = t,
                    this.computePass.uniforms.intensityDivR6.value = t / Math.pow(this.options.aoRadius, 6)
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(e.prototype, "blurEdgeSharpness", {
                get: function() {
                    return this.options.blurEdgeSharpness
                },
                set: function(t) {
                    this.options.blurEdgeSharpness = t,
                    this.hBlurPass.uniforms.edgeSharpness.value = t,
                    this.vBlurPass.uniforms.edgeSharpness.value = t
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(e.prototype, "blurKernalRadius", {
                get: function() {
                    return this.options.blurKernalRadius
                },
                set: function(t) {
                    this.options.blurKernalRadius = t,
                    this.hBlurPass.defines.KERNEL_RADIUS = t,
                    this.vBlurPass.defines.KERNEL_RADIUS = t;
                    var e = Object(s.b)(t);
                    this.hBlurPass.uniforms.weights.value = e,
                    this.vBlurPass.uniforms.weights.value = e,
                    this.hBlurPass.material.needsUpdate = true,
                    this.vBlurPass.material.needsUpdate = true
                },
                enumerable: true,
                configurable: true
            }),
            e.prototype.setOptions = function(t) {
                for (var e = 0,
                n = Object.keys(t); e < n.length; e++) {
                    var i = n[e];
                    undefined !== t[i] && (this[i] = t[i])
                }
            },
            e.prototype.render = function(t, e) {
                this.refreshUniforms(),
                this.depthPass.render(t, this.depthTarget),
                this.computePass.render(t, this.computeTarget),
                this.hBlurPass.render(t, this.hBlurTarget),
                this.vBlurPass.render(t, this.vBlurTarget),
                this.blendPass.render(t, e, this.vBlurTarget)
            },
            e.prototype.setSize = function(t, e) {
                var n = 1 / t,
                i = 1 / e;
                this.height = e,
                this.depthTarget.setSize(t, e),
                this.computePass.uniforms.noiseScale.value.set(t, e).divideScalar(d),
                this.computePass.uniforms.texelSize.value.set(n, i),
                this.computeTarget.setSize(t, e),
                this.vBlurPass.uniforms.texelSize.value.set(n, i),
                this.vBlurTarget.setSize(t, e),
                this.hBlurPass.uniforms.texelSize.value.set(n, i),
                this.hBlurTarget.setSize(t, e)
            },
            e.prototype.setup = function(e, n) {
                t.prototype.setup.call(this, e, n),
                this.depthPass.setup(e, n)
            },
            e.prototype.refreshUniforms = function() {
                var t = this.camera;
                this.computePass.uniforms.cameraNear.value = t.near,
                this.computePass.uniforms.cameraFar.value = t.far,
                this.computePass.uniforms.cameraInverseProjectionMatrix.value.getInverse(t.projectionMatrix),
                this.computePass.uniforms.cameraProjectionMatrix.value = t.projectionMatrix,
                this.computePass.uniforms.projectionScale.value = Object(h.a)(t, this.height),
                this.vBlurPass.uniforms.cameraNear.value = t.near,
                this.vBlurPass.uniforms.cameraFar.value = t.far,
                this.hBlurPass.uniforms.cameraNear.value = t.near,
                this.hBlurPass.uniforms.cameraFar.value = t.far
            },
            e
        } (a.a)
    },
    "2QWY": function(t, e, n) {
        "use strict";
        e.a = "#ifdef TOON\\n\\tuniform sampler2D gradientMap;\\n\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\\t\\tfloat dotNL = dot( normal, lightDirection );\\n\\t\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\\t\\t#ifdef USE_GRADIENTMAP\\n\\t\\t\\treturn texture2D( gradientMap, coord ).rgb;\\n\\t\\t#else\\n\\t\\t\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\\t\\t#endif\\n\\t}\\n#endif\\n"
    },
    "2Tlm": function(t, e, n) {
        "use strict";

        function i(t) {
            this.uuid = a.a.generateUUID(),
            this._objects = Array.prototype.slice.call(arguments),
            this.nCachedObjects_ = 0;
            var e = {};
            this._indicesByUUID = e;
            for (var n = 0,
            i = arguments.length; n !== i; ++n) e[arguments[n].uuid] = n;
            this._paths = [],
            this._parsedPaths = [],
            this._bindings = [],
            this._bindingsIndicesByPath = {};
            var r = this;
            this.stats = {
                objects: {
                    get total() {
                        return r._objects.length
                    },
                    get inUse() {
                        return this.total - r.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return r._bindings.length
                }
            }
        }
        var r = n("2seR"),
        a = n("_Math");
        Object.assign(i.prototype, {
            isAnimationObjectGroup: true,
            add: function(t) {
                for (var e = this._objects,
                n = e.length,
                i = this.nCachedObjects_,
                a = this._indicesByUUID,
                o = this._paths,
                s = this._parsedPaths,
                u = this._bindings,
                c = u.length,
                h = 0,
                l = arguments.length; h !== l; ++h) {
                    var f = arguments[h],
                    p = f.uuid,
                    d = a[p],
                    m = undefined;
                    if (undefined === d) {
                        d = n++,
                        a[p] = d,
                        e.push(f);
                        for (var v = 0,
                        g = c; v !== g; ++v) u[v].push(new r.a(f, o[v], s[v]))
                    } else if (d < i) {
                        m = e[d];
                        var y = --i,
                        _ = e[y];
                        a[_.uuid] = d,
                        e[d] = _,
                        a[p] = y,
                        e[y] = f;
                        for (var v = 0,
                        g = c; v !== g; ++v) {
                            var x = u[v],
                            b = x[y],
                            w = x[d];
                            x[d] = b,
                            undefined === w && (w = new r.a(f, o[v], s[v])),
                            x[y] = w
                        }
                    } else e[d] !== m && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                }
                this.nCachedObjects_ = i
            },
            remove: function(t) {
                for (var e = this._objects,
                n = this.nCachedObjects_,
                i = this._indicesByUUID,
                r = this._bindings,
                a = r.length,
                o = 0,
                s = arguments.length; o !== s; ++o) {
                    var u = arguments[o],
                    c = u.uuid,
                    h = i[c];
                    if (undefined !== h && h >= n) {
                        var l = n++,
                        f = e[l];
                        i[f.uuid] = h,
                        e[h] = f,
                        i[c] = l,
                        e[l] = u;
                        for (var p = 0,
                        d = a; p !== d; ++p) {
                            var m = r[p],
                            v = m[l],
                            g = m[h];
                            m[h] = v,
                            m[l] = g
                        }
                    }
                }
                this.nCachedObjects_ = n
            },
            uncache: function(t) {
                for (var e = this._objects,
                n = e.length,
                i = this.nCachedObjects_,
                r = this._indicesByUUID,
                a = this._bindings,
                o = a.length,
                s = 0,
                u = arguments.length; s !== u; ++s) {
                    var c = arguments[s],
                    h = c.uuid,
                    l = r[h];
                    if (undefined !== l) if (delete r[h], l < i) {
                        var f = --i,
                        p = e[f],
                        d = --n,
                        m = e[d];
                        r[p.uuid] = l,
                        e[l] = p,
                        r[m.uuid] = f,
                        e[f] = m,
                        e.pop();
                        for (var v = 0,
                        g = o; v !== g; ++v) {
                            var y = a[v],
                            _ = y[f],
                            x = y[d];
                            y[l] = _,
                            y[f] = x,
                            y.pop()
                        }
                    } else {
                        var d = --n,
                        m = e[d];
                        r[m.uuid] = l,
                        e[l] = m,
                        e.pop();
                        for (var v = 0,
                        g = o; v !== g; ++v) {
                            var y = a[v];
                            y[l] = y[d],
                            y.pop()
                        }
                    }
                }
                this.nCachedObjects_ = i
            },
            subscribe_: function(t, e) {
                var n = this._bindingsIndicesByPath,
                i = n[t],
                a = this._bindings;
                if (undefined !== i) return a[i];
                var o = this._paths,
                s = this._parsedPaths,
                u = this._objects,
                c = u.length,
                h = this.nCachedObjects_,
                l = new Array(c);
                i = a.length,
                n[t] = i,
                o.push(t),
                s.push(e),
                a.push(l);
                for (var f = h,
                p = u.length; f !== p; ++f) {
                    var d = u[f];
                    l[f] = new r.a(d, t, e)
                }
                return l
            },
            unsubscribe_: function(t) {
                var e = this._bindingsIndicesByPath,
                n = e[t];
                if (undefined !== n) {
                    var i = this._paths,
                    r = this._parsedPaths,
                    a = this._bindings,
                    o = a.length - 1,
                    s = a[o];
                    e[t[o]] = n,
                    a[n] = s,
                    a.pop(),
                    r[n] = r[o],
                    r.pop(),
                    i[n] = i[o],
                    i.pop()
                }
            }
        })
    },
    "EventDispatcher": function(t, e, n) {
        "use strict";

        function EventDispatcher() {}
        n.d(e, "a",
        function() {
            return EventDispatcher
        }),
        Object.assign(i.prototype, {
            addEventListener: function(t, e) {
                undefined === this._listeners && (this._listeners = {});
                var n = this._listeners;
                undefined === n[t] && (n[t] = []),
                -1 === n[t].indexOf(e) && n[t].push(e)
            },
            hasEventListener: function(t, e) {
                if (undefined === this._listeners) return ! 1;
                var n = this._listeners;
                return undefined !== n[t] && -1 !== n[t].indexOf(e)
            },
            removeEventListener: function(t, e) {
                if (undefined !== this._listeners) {
                    var n = this._listeners,
                    i = n[t];
                    if (undefined !== i) {
                        var r = i.indexOf(e); - 1 !== r && i.splice(r, 1)
                    }
                }
            },
            dispatchEvent: function(t) {
                if (undefined !== this._listeners) {
                    var e = this._listeners,
                    n = e[t.type];
                    if (undefined !== n) {
                        t.target = this;
                        for (var i = n.slice(0), r = 0, a = i.length; r < a; r++) i[r].call(this, t)
                    }
                }
            }
        })
    },
    "2ki8": function(t, e, n) {
        "use strict";

        function i(t, e) {
            this.analyser = t.context.createAnalyser(),
            this.analyser.fftSize = undefined !== e ? e: 2048,
            this.data = new Uint8Array(this.analyser.frequencyBinCount),
            t.getOutput().connect(this.analyser)
        }
        Object.assign(i.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data),
                this.data
            },
            getAverageFrequency: function() {
                for (var t = 0,
                e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
                return t / e.length
            }
        })
    },
    "2rQf": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return s
        });
        var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        r = n("sz/p"),
        a = n("85Qu"),
        o = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        s = function(t) {
            function e(e, n) {
                var r = t.call(this) || this;
                return r.name = "ShaderPass",
                r.clear = true,
                r.textureID = undefined !== n ? n: "tDiffuse",
                e instanceof i.E ? (r.uniforms = e.uniforms, r.material = e) : e && (r.material = Object(a.a)(e), r.uniforms = r.material.uniforms, r.defines = r.material.defines),
                r.quadScene = new i.C,
                r.quadCamera = new i.w( - 1, 1, 1, -1, 0, 1),
                r.quad = new i.q(new i.x(2, 2)),
                r.quad.frustumCulled = false,
                r.quadScene.add(r.quad),
                r
            }
            return o(e, t),
            e.prototype.render = function(t, e, n, i, r) {
                n && this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture);
                var a = this.renderToScreen ? null: e;
                this.clear && (t.setRenderTarget(a), t.clear()),
                this.quad.material = this.material,
                t.render(this.quadScene, this.quadCamera, a)
            },
            e
        } (r.a)
    },
    "2seR": function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            var i = n || r.parseTrackName(e);
            this._targetGroup = t,
            this._bindings = t.subscribe_(e, i)
        }

        function r(t, e, n) {
            this.path = e,
            this.parsedPath = n || r.parseTrackName(e),
            this.node = r.findNode(t, this.parsedPath.nodeName) || t,
            this.rootNode = t
        }
        n.d(e, "a",
        function() {
            return r
        }),
        Object.assign(i.prototype, {
            getValue: function(t, e) {
                this.bind();
                var n = this._targetGroup.nCachedObjects_,
                i = this._bindings[n];
                undefined !== i && i.getValue(t, e)
            },
            setValue: function(t, e) {
                for (var n = this._bindings,
                i = this._targetGroup.nCachedObjects_,
                r = n.length; i !== r; ++i) n[i].setValue(t, e)
            },
            bind: function() {
                for (var t = this._bindings,
                e = this._targetGroup.nCachedObjects_,
                n = t.length; e !== n; ++e) t[e].bind()
            },
            unbind: function() {
                for (var t = this._bindings,
                e = this._targetGroup.nCachedObjects_,
                n = t.length; e !== n; ++e) t[e].unbind()
            }
        }),
        Object.assign(r, {
            Composite: i,
            create: function(t, e, n) {
                return t && t.isAnimationObjectGroup ? new r.Composite(t, e, n) : new r(t, e, n)
            },
            sanitizeNodeName: function(t) {
                return t.replace(/\\s/g, "_").replace(/[^\\w-]/g, "")
            },
            parseTrackName: function() {
                var t = /((?:[\\w-]+[\\/: ]) * ) / ,
                e = /([\\w-\\.]+)?/,
                n = /(?:\\.([\\w-]+)(?:\\[(.+)\\])?)?/,
                i = /\\.([\\w-]+)(?:\\[(.+)\\])?/,
                r = new RegExp("^" + t.source + e.source + n.source + i.source + "$"),
                a = ["material", "materials", "bones"];
                return function(t) {
                    var e = r.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    var n = {
                        nodeName: e[2],
                        objectName: e[3],
                        objectIndex: e[4],
                        propertyName: e[5],
                        propertyIndex: e[6]
                    },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (undefined !== i && -1 !== i) {
                        var o = n.nodeName.substring(i + 1); - 1 !== a.indexOf(o) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = o)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                }
            } (),
            findNode: function(t, e) {
                if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                if (t.skeleton) {
                    var n = function(t) {
                        for (var n = 0; n < t.bones.length; n++) {
                            var i = t.bones[n];
                            if (i.name === e) return i
                        }
                        return null
                    } (t.skeleton);
                    if (n) return n
                }
                if (t.children) {
                    var i = function t(n) {
                        for (var i = 0; i < n.length; i++) {
                            var r = n[i];
                            if (r.name === e || r.uuid === e) return r;
                            var a = t(r.children);
                            if (a) return a
                        }
                        return null
                    } (t.children);
                    if (i) return i
                }
                return null
            }
        }),
        Object.assign(r.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(t, e) {
                t[e] = this.node[this.propertyName]
            },
            function(t, e) {
                for (var n = this.resolvedProperty,
                i = 0,
                r = n.length; i !== r; ++i) t[e++] = n[i]
            },
            function(t, e) {
                t[e] = this.resolvedProperty[this.propertyIndex]
            },
            function(t, e) {
                this.resolvedProperty.toArray(t, e)
            }],
            SetterByBindingTypeAndVersioning: [[function(t, e) {
                this.node[this.propertyName] = t[e]
            },
            function(t, e) {
                this.node[this.propertyName] = t[e],
                this.targetObject.needsUpdate = true
            },
            function(t, e) {
                this.node[this.propertyName] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = true
            }], [function(t, e) {
                for (var n = this.resolvedProperty,
                i = 0,
                r = n.length; i !== r; ++i) n[i] = t[e++]
            },
            function(t, e) {
                for (var n = this.resolvedProperty,
                i = 0,
                r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.needsUpdate = true
            },
            function(t, e) {
                for (var n = this.resolvedProperty,
                i = 0,
                r = n.length; i !== r; ++i) n[i] = t[e++];
                this.targetObject.matrixWorldNeedsUpdate = true
            }], [function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e]
            },
            function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.needsUpdate = true
            },
            function(t, e) {
                this.resolvedProperty[this.propertyIndex] = t[e],
                this.targetObject.matrixWorldNeedsUpdate = true
            }], [function(t, e) {
                this.resolvedProperty.fromArray(t, e)
            },
            function(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.needsUpdate = true
            },
            function(t, e) {
                this.resolvedProperty.fromArray(t, e),
                this.targetObject.matrixWorldNeedsUpdate = true
            }]],
            getValue: function(t, e) {
                this.bind(),
                this.getValue(t, e)
            },
            setValue: function(t, e) {
                this.bind(),
                this.setValue(t, e)
            },
            bind: function() {
                var t = this.node,
                e = this.parsedPath,
                n = e.objectName,
                i = e.propertyName,
                a = e.propertyIndex;
                if (t || (t = r.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                if (n) {
                    var o = e.objectIndex;
                    switch (n) {
                    case "materials":
                        if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        t = t.material.materials;
                        break;
                    case "bones":
                        if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        t = t.skeleton.bones;
                        for (var s = 0; s < t.length; s++) if (t[s].name === o) {
                            o = s;
                            break
                        }
                        break;
                    default:
                        if (undefined === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        t = t[n]
                    }
                    if (undefined !== o) {
                        if (undefined === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[o]
                    }
                }
                var u = t[i];
                if (undefined === u) {
                    var c = e.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", t)
                }
                var h = this.Versioning.None;
                undefined !== t.needsUpdate ? (h = this.Versioning.NeedsUpdate, this.targetObject = t) : undefined !== t.matrixWorldNeedsUpdate && (h = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = t);
                var l = this.BindingType.Direct;
                if (undefined !== a) {
                    if ("morphTargetInfluences" === i) {
                        if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (t.geometry.isBufferGeometry) {
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            for (var s = 0; s < this.node.geometry.morphAttributes.position.length; s++) if (t.geometry.morphAttributes.position[s].name === a) {
                                a = s;
                                break
                            }
                        } else {
                            if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                            for (var s = 0; s < this.node.geometry.morphTargets.length; s++) if (t.geometry.morphTargets[s].name === a) {
                                a = s;
                                break
                            }
                        }
                    }
                    l = this.BindingType.ArrayElement,
                    this.resolvedProperty = u,
                    this.propertyIndex = a
                } else undefined !== u.fromArray && undefined !== u.toArray ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = u) : Array.isArray(u) ? (l = this.BindingType.EntireArray, this.resolvedProperty = u) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[l],
                this.setValue = this.SetterByBindingTypeAndVersioning[l][h]
            },
            unbind: function() {
                this.node = null,
                this.getValue = this._getValue_unbound,
                this.setValue = this._setValue_unbound
            }
        }),
        Object.assign(r.prototype, {
            _getValue_unbound: r.prototype.getValue,
            _setValue_unbound: r.prototype.setValue
        })
    },
    "2ss1": function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            return this.radius = undefined !== t ? t: 1,
            this.theta = undefined !== e ? e: 0,
            this.y = undefined !== n ? n: 0,
            this
        }
        Object.assign(i.prototype, {
            set: function(t, e, n) {
                return this.radius = t,
                this.theta = e,
                this.y = n,
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.radius = t.radius,
                this.theta = t.theta,
                this.y = t.y,
                this
            },
            setFromVector3: function(t) {
                return this.radius = Math.sqrt(t.x * t.x + t.z * t.z),
                this.theta = Math.atan2(t.x, t.z),
                this.y = t.y,
                this
            }
        })
    },
    "2xD/": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_ALPHAMAP\\n\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n"
    },
    "3IRH": function(t, e) {
        t.exports = function(t) {
            return t.webpackPolyfill || (t.deprecate = function() {},
            t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
                enumerable: true,
                get: function() {
                    return t.l
                }
            }), Object.defineProperty(t, "id", {
                enumerable: true,
                get: function() {
                    return t.i
                }
            }), t.webpackPolyfill = 1),
            t
        }
    },
    "3JDn": function(t, e, n) {
        "use strict";
        n.d(e, "b",
        function() {
            return i
        }),
        n.d(e, "a",
        function() {
            return r
        });
        var i; !
        function(t) {
            t.Stacking = "Stacking",
            t.Camera = "Camera"
        } (i || (i = {}));
        var r = function() {
            function t() {
                this.plugins = new Map
            }
            return t.getInstance = function() {
                return t.instance || (t.instance = new t)
            },
            t.prototype.registerPlugin = function(t) {
                this.plugins.set(t.name, t)
            },
            t.prototype.getPlugin = function(t) {
                return this.plugins.get(t)
            },
            t
        } ()
    },
    "3O7r": function(t, e, n) {
        "use strict";
        e.a = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tattribute vec2 uv2;\\n\\tvarying vec2 vUv2;\\n#endif"
    },
    ShaderLib : function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return u
        });
        var i = n("WqzK"),
        r = n("UniformsUtils"),
        a = n("Vector3"),
        o = n("yQK5"),
        s = n("Color"),
        u = {
            basic: {
                uniforms: r.a.merge([o.a.common, o.a.aomap, o.a.lightmap, o.a.fog]),
                vertexShader: i.a.meshbasic_vert,
                fragmentShader: i.a.meshbasic_frag
            },
            lambert: {
                uniforms: r.a.merge([o.a.common, o.a.aomap, o.a.lightmap, o.a.emissivemap, o.a.fog, o.a.lights, {
                    emissive: {
                        value: new s.a(0)
                    }
                }]),
                vertexShader: i.a.meshlambert_vert,
                fragmentShader: i.a.meshlambert_frag
            },
            phong: {
                uniforms: r.a.merge([o.a.common, o.a.aomap, o.a.lightmap, o.a.emissivemap, o.a.bumpmap, o.a.normalmap, o.a.displacementmap, o.a.gradientmap, o.a.fog, o.a.lights, {
                    emissive: {
                        value: new s.a(0)
                    },
                    specular: {
                        value: new s.a(1118481)
                    },
                    shininess: {
                        value: 30
                    }
                }]),
                vertexShader: i.a.meshphong_vert,
                fragmentShader: i.a.meshphong_frag
            },
            standard: {
                uniforms: r.a.merge([o.a.common, o.a.aomap, o.a.lightmap, o.a.emissivemap, o.a.bumpmap, o.a.normalmap, o.a.displacementmap, o.a.roughnessmap, o.a.metalnessmap, o.a.fog, o.a.lights, {
                    emissive: {
                        value: new s.a(0)
                    },
                    roughness: {
                        value: .5
                    },
                    metalness: {
                        value: .5
                    },
                    envMapIntensity: {
                        value: 1
                    }
                }]),
                vertexShader: i.a.meshphysical_vert,
                fragmentShader: i.a.meshphysical_frag
            },
            points: {
                uniforms: r.a.merge([o.a.points, o.a.fog]),
                vertexShader: i.a.points_vert,
                fragmentShader: i.a.points_frag
            },
            dashed: {
                uniforms: r.a.merge([o.a.common, o.a.fog, {
                    scale: {
                        value: 1
                    },
                    dashSize: {
                        value: 1
                    },
                    totalSize: {
                        value: 2
                    }
                }]),
                vertexShader: i.a.linedashed_vert,
                fragmentShader: i.a.linedashed_frag
            },
            depth: {
                uniforms: r.a.merge([o.a.common, o.a.displacementmap]),
                vertexShader: i.a.depth_vert,
                fragmentShader: i.a.depth_frag
            },
            normal: {
                uniforms: r.a.merge([o.a.common, o.a.bumpmap, o.a.normalmap, o.a.displacementmap, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: i.a.normal_vert,
                fragmentShader: i.a.normal_frag
            },
            cube: {
                uniforms: {
                    tCube: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    },
                    opacity: {
                        value: 1
                    }
                },
                vertexShader: i.a.cube_vert,
                fragmentShader: i.a.cube_frag
            },
            equirect: {
                uniforms: {
                    tEquirect: {
                        value: null
                    },
                    tFlip: {
                        value: -1
                    }
                },
                vertexShader: i.a.equirect_vert,
                fragmentShader: i.a.equirect_frag
            },
            distanceRGBA: {
                uniforms: {
                    lightPos: {
                        value: new a.a
                    }
                },
                vertexShader: i.a.distanceRGBA_vert,
                fragmentShader: i.a.distanceRGBA_frag
            }
        };
        u.physical = {
            uniforms: r.a.merge([u.standard.uniforms, {
                clearCoat: {
                    value: 0
                },
                clearCoatRoughness: {
                    value: 0
                }
            }]),
            vertexShader: i.a.meshphysical_vert,
            fragmentShader: i.a.meshphysical_frag
        }
    },
    "4J9B": function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.material = t,
            this.render = function(t) {}
        }
        var r = n("Object3D");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isImmediateRenderObject = true
    },
    "4OoW": function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            a.postMessage({
                type: t,
                data: e
            },
            n)
        }
        var r = n("g1lb"),
        a = self;
        a.onmessage = function(t) {
            var e = t.data;
            try {
                i("start", undefined);
                var n = r.PopModel.decode(e);
                i("success", n, [n.indices.buffer, n.normals.buffer, n.textures.buffer, n.vertices.buffer])
            } catch(t) {
                i("error", JSON.stringify(t))
            }
        }
    },
    "4W4M": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i = {
            arraySlice: function(t, e, n) {
                return i.isTypedArray(t) ? new t.constructor(t.subarray(e, undefined !== n ? n: t.length)) : t.slice(e, n)
            },
            convertArray: function(t, e, n) {
                return ! t || !n && t.constructor === e ? t: "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
            },
            isTypedArray: function(t) {
                return ArrayBuffer.isView(t) && !(t instanceof DataView)
            },
            getKeyframeOrder: function(t) {
                function e(e, n) {
                    return t[e] - t[n]
                }
                for (var n = t.length,
                i = new Array(n), r = 0; r !== n; ++r) i[r] = r;
                return i.sort(e),
                i
            },
            sortedArray: function(t, e, n) {
                for (var i = t.length,
                r = new t.constructor(i), a = 0, o = 0; o !== i; ++a) for (var s = n[a] * e, u = 0; u !== e; ++u) r[o++] = t[s + u];
                return r
            },
            flattenJSON: function(t, e, n, i) {
                for (var r = 1,
                a = t[0]; undefined !== a && undefined === a[i];) a = t[r++];
                if (undefined !== a) {
                    var o = a[i];
                    if (undefined !== o) if (Array.isArray(o)) do {
                        o = a[i], undefined !== o && (e.push(a.time), n.push.apply(n, o)), a = t[r++]
                    } while ( undefined !== a );
                    else if (undefined !== o.toArray) do {
                        o = a[i], undefined !== o && (e.push(a.time), o.toArray(n, n.length)), a = t[r++]
                    } while ( undefined !== a );
                    else do {
                        o = a[i], undefined !== o && (e.push(a.time), n.push(o)), a = t[r++]
                    } while ( undefined !== a )
                }
            }
        }
    },
    "4Ww7": function(t, e, n) {
        "use strict";
        var i; !
        function(t) {
            t[t.TOP = 0] = "TOP",
            t[t.BOTTOM = 1] = "BOTTOM",
            t[t.FRONT = 2] = "FRONT",
            t[t.BACK = 3] = "BACK"
        } (i || (i = {})),
        e.a = i
    },
    "4X5t": function(t, e, n) {
        "use strict";
        e.a = "\\nvec4 LinearToLinear( in vec4 value ) {\\n\\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\\tM            = ceil( M * 255.0 ) / 255.0;\\n\\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\n\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\n\\tD            = min( floor( D ) / 255.0, 1.0 );\\n\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n\\tvec4 vResult;\\n\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\\tvResult.w = fract(Le);\\n\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n\\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\\tfloat Le = value.z * 255.0 + value.w;\\n\\tvec3 Xp_Y_XYZp;\\n\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n\\treturn vec4( max(vRGB, 0.0), 1.0 );\\n}\\n"
    },
    "4eq2": function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            var a = new r.a(t, e, n);
            Object.defineProperties(this, {
                v: {
                    get: function() {
                        return a
                    }
                },
                x: {
                    get: function() {
                        return a.x
                    },
                    set: function(t) {
                        this.emitChange(),
                        a.setX(t)
                    }
                },
                y: {
                    get: function() {
                        return a.y
                    },
                    set: function(t) {
                        this.emitChange(),
                        a.setY(t)
                    }
                },
                z: {
                    get: function() {
                        return a.z
                    },
                    set: function(t) {
                        this.emitChange(),
                        a.setZ(t)
                    }
                }
            }),
            this.obj = i
        }
        e.a = i;
        var r = n("Vector3");
        Object.assign(i.prototype, {
            isVector3: true,
            emitChange: function() {
                this.obj.setMatrixDirty()
            },
            set: function(t, e, n) {
                return this.v.set(t, e, n),
                this.emitChange(),
                this
            },
            setScalar: function(t) {
                return this.v.setScalar(t),
                this.emitChange(),
                this
            },
            setX: function(t) {
                return this.v.setX(t),
                this.emitChange(),
                this
            },
            setY: function(t) {
                return this.v.setY(t),
                this.emitChange(),
                this
            },
            setZ: function(t) {
                return this.v.setZ(t),
                this.emitChange(),
                this
            },
            setComponent: function(t, e) {
                return this.v.setComponent(t, e),
                this.emitChange(),
                this
            },
            getComponent: function(t) {
                return this.v.getComponent(t)
            },
            clone: function() {
                return this.v.clone()
            },
            copy: function(t) {
                return this.v.copy(t),
                this.emitChange(),
                this
            },
            add: function(t, e) {
                return this.v.add(t, e),
                this.emitChange(),
                this
            },
            addScalar: function(t) {
                return this.v.addScalar(t),
                this.emitChange(),
                this
            },
            addVectors: function(t, e) {
                return this.v.addVectors(t, e),
                this.emitChange(),
                this
            },
            addScaledVector: function(t, e) {
                return this.v.addScaledVector(t, e),
                this.emitChange(),
                this
            },
            sub: function(t, e) {
                return this.v.sub(t, e),
                this.emitChange(),
                this
            },
            subScalar: function(t) {
                return this.v.subScalar(t),
                this.emitChange(),
                this
            },
            subVectors: function(t, e) {
                return this.v.subVectors(t, e),
                this.emitChange(),
                this
            },
            multiply: function(t, e) {
                return this.v.multiply(t, e),
                this.emitChange(),
                this
            },
            multiplyScalar: function(t) {
                return this.v.multiplyScalar(t),
                this.emitChange(),
                this
            },
            multiplyVectors: function(t, e) {
                return this.v.multiplyVectors(t, e),
                this.emitChange(),
                this
            },
            applyEuler: function(t) {
                return this.v.applyEuler(t),
                this.emitChange(),
                this
            },
            applyAxisAngle: function(t, e) {
                return this.v.applyAxisAngle(t, e),
                this.emitChange(),
                this
            },
            applyMatrix3: function(t) {
                return this.v.applyMatrix3(t),
                this.emitChange(),
                this
            },
            applyMatrix4: function(t) {
                return this.v.applyMatrix4(t),
                this.emitChange(),
                this
            },
            applyQuaternion: function(t) {
                return this.v.applyQuaternion(t),
                this.emitChange(),
                this
            },
            project: function(t) {
                return this.v.project(t),
                this.emitChange(),
                this
            },
            unproject: function(t) {
                return this.v.unproject(t),
                this.emitChange(),
                this
            },
            transformDirection: function(t) {
                return this.v.transformDirection(t),
                this.emitChange(),
                this
            },
            divide: function(t) {
                return this.v.divide(t),
                this.emitChange(),
                this
            },
            divideScalar: function(t) {
                return this.v.divideScalar(t),
                this.emitChange(),
                this
            },
            min: function(t) {
                return this.v.min(t),
                this.emitChange(),
                this
            },
            max: function(t) {
                return this.v.max(t),
                this.emitChange(),
                this
            },
            clamp: function(t, e) {
                return this.v.clamp(t, e),
                this.emitChange(),
                this
            },
            clampScalar: function(t, e) {
                return this.v.clampScalar(t, e),
                this.emitChange(),
                this
            },
            clampLength: function(t, e) {
                return this.v.clampLength(t, e),
                this.emitChange(),
                this
            },
            floor: function() {
                return this.v.floor(),
                this.emitChange(),
                this
            },
            ceil: function() {
                return this.v.ceil(),
                this.emitChange(),
                this
            },
            round: function() {
                return this.v.round(),
                this.emitChange(),
                this
            },
            roundToZero: function() {
                return this.v.roundToZero(),
                this.emitChange(),
                this
            },
            negate: function() {
                return this.v.negate()
            },
            dot: function(t) {
                return this.v.dot(t),
                this.emitChange(),
                this
            },
            lengthSq: function() {
                return this.v.lengthSq()
            },
            length: function() {
                return this.v.length()
            },
            lengthManhattan: function() {
                return this.v.lengthManhattan()
            },
            normalize: function() {
                return this.v.normalize(),
                this.emitChange(),
                this
            },
            setLength: function(t) {
                return this.v.setLength(t),
                this.emitChange(),
                this
            },
            lerp: function(t, e) {
                return this.v.lerp(t, e),
                this.emitChange(),
                this
            },
            lerpVectors: function(t, e, n) {
                return this.v.lerpVectors(t, e, n),
                this.emitChange(),
                this
            },
            cross: function(t, e) {
                return this.v.cross(t, e),
                this.emitChange(),
                this
            },
            crossVectors: function(t, e) {
                return this.v.crossVectors(t, e),
                this.emitChange(),
                this
            },
            projectOnVector: function(t) {
                return this.v.projectOnVector(t),
                this.emitChange(),
                this
            },
            projectOnPlane: function(t) {
                return this.v.projectOnVector(t),
                this.emitChange(),
                this
            },
            reflect: function(t) {
                return this.v.reflect(t)
            },
            angleTo: function(t) {
                return this.innerVector3.angleTo(t),
                this.emitChange(),
                this
            },
            distanceTo: function(t) {
                return this.v.distanceTo(t),
                this.emitChange(),
                this
            },
            distanceToSquared: function(t) {
                return this.v.distanceToSquared(t),
                this.emitChange(),
                this
            },
            distanceToManhattan: function(t) {
                return this.v.distanceToManhattan(t)
            },
            setFromSpherical: function(t) {
                return this.v.setFromSpherical(t),
                this.emitChange(),
                this
            },
            setFromCylindrical: function(t) {
                return this.v.setFromCylindrical(t),
                this.emitChange(),
                this
            },
            setFromMatrixPosition: function(t) {
                return this.v.setFromMatrixPosition(t),
                this.emitChange(),
                this
            },
            setFromMatrixScale: function(t) {
                return this.innerVector3.setFromMatrixScale(t),
                this.emitChange(),
                this
            },
            setFromMatrixColumn: function(t, e) {
                return this.v.setFromMatrixColumn(t, e),
                this.emitChange(),
                this
            },
            equals: function(t) {
                return this.v.equals(t)
            },
            fromArray: function(t, e) {
                return this.v.fromArray(t, e),
                this.emitChange(),
                this
            },
            toArray: function(t, e) {
                return this.v.toArray(t, e)
            },
            fromBufferAttribute: function(t, e, n) {
                return this.v.fromArray(t, e, n),
                this.emitChange(),
                this
            }
        })
    },
    "4fHl": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_DISPLACEMENTMAP\\n\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n"
    },
    "4ic7": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i = function() {
            function t(t) {
                this.buff = 0,
                this.bits = 0,
                this.stream = t
            }
            return t.prototype.read = function(t) {
                if (t > this.bits) {
                    this.bits = t - this.bits;
                    var e = this.buff << this.bits;
                    return this.bits = 32 - this.bits,
                    this.buff = this.stream.readSwappedInt(),
                    e |= this.buff >>> this.bits,
                    this.buff = this.buff & (1 << this.bits) - 1,
                    e
                }
                this.bits -= t;
                var e = this.buff >>> this.bits;
                return this.buff = this.buff & (1 << this.bits) - 1,
                e
            },
            t
        } ()
    },
    "4idU": function(t, e, n) {
        "use strict";
        e.a = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform vec4 offsetRepeat;\\n#endif\\n"
    },
    "4k0s": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i = n("CustomerDefine4"),
        r = function() {
            function t(t) {
                var e = this;
                this.onMaterialDisposed = function(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", e.onMaterialDisposed),
                    e.removeMaterial(n)
                },
                this.materials = new i.a(t)
            }
            return t.prototype.dispose = function() {
                var t = this;
                this.materials.forEach(function(e) {
                    e._egsMatId = undefined,
                    e.removeEventListener("dispose", t.onMaterialDisposed)
                })
            },
            t.prototype.reset = function() {
                this.materials.reset()
            },
            t.prototype.addMaterial = function(t) {
                var e = t._egsMatId;
                return undefined !== e ? e: (t.addEventListener("dispose", this.onMaterialDisposed), this.doAddMaterial(t))
            },
            t.prototype.getMatId = function(t) {
                return t._egsMatId
            },
            t.prototype.doAddMaterial = function(t) {
                var e = this.materials.addItemNoduplicate(t);
                if ( - 1 === e) throw "rendermodel material list error";
                return t._egsMatId = e,
                t._egsMatId
            },
            t.prototype.removeMaterial = function(t) {
                undefined !== t._egsMatId && (this.materials.removeItem(t, t._egsMatId), t._egsMatId = undefined)
            },
            t
        } ()
    },
    "TetrahedronGeometry||TetrahedronBufferGeometry": function(t, e, n) {
        "use strict";

        function i(t, e) {
            a.a.call(this),
            this.type = "TetrahedronGeometry",
            this.parameters = {
                radius: t,
                detail: e
            },
            this.fromBufferGeometry(new r(t, e)),
            this.mergeVertices()
        }

        function r(t, e) {
            var n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
            o.a.call(this, n, i, t, e),
            this.type = "TetrahedronBufferGeometry",
            this.parameters = {
                radius: t,
                detail: e
            }
        }
        var a = n("Geometry"),
        o = n("PolyhedronGeometry||PolyhedronBufferGeometry");
        i.prototype = Object.create(a.a.prototype),
        i.prototype.constructor = i,
        r.prototype = Object.create(o.a.prototype),
        r.prototype.constructor = r
    },
    "4wub": function(t, e, n) {
        "use strict";

        function i(t, e) {
            t.render.calls = e.render.calls,
            t.render.vertices = e.render.vertices,
            t.render.faces = e.render.faces,
            t.render.points = e.render.points,
            t.render.frames = e.render.frame,
            t.memory.geometries = e.memory.geometries,
            t.memory.textures = e.memory.textures,
            t.programs = e.programs.length,
            t.renderModelUpdate = e.egsinfo.renderModelUpdate,
            t.threeWebGLPrepare = e.egsinfo.threeWebGLPrepare
        }
        n.d(e, "a",
        function() {
            return r
        }),
        e.b = i;
        var r = function() {
            function t() {
                this.memory = {
                    geometries: 0,
                    textures: 0
                },
                this.render = {
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0,
                    frames: 0,
                    batchUpdateTime: 0,
                    modelUpdateTime: 0
                },
                this.programs = 0,
                this.renderModelUpdate = 0,
                this.threeWebGLPrepare = 0
            }
            return t
        } ()
    },
    "4ywI": function(t, e, n) {
        "use strict";
        e.a = "#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n"
    },
    "PopGroups": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i = n("PopChunks"),
        r = function() {
            function t() {}
            return t.prototype.readFromStream = function(t) {
                this.chunks = [],
                this.minLevel = t.readSwappedInt(),
                this.maxLevel = t.readSwappedInt();
                for (var e = t.readSwappedInt(), n = 0; n < e; n++) {
                    var r = new PopChunks();
                    r.readFromStream(t),
                    this.chunks.push(r)
                }
            },
            t
        } ()
    },
    "CustomerDefine5": function(t, e, n) {
        "use strict";

        function i(t) {
            if (t.isBufferGeometry) for (var e = 0; e < t.groups.length; e++) {
                var n = t.groups[e],
                i = new r.c;
                undefined !== t.attributes.position ? t.isPopGeometry ? (i.setFromIndexBufferAttributeRange(t.attributes.position, t.index, n.start, t.model.blocks[e].count), n.debugBoxStart = n.start, n.debugBoxCount = t.model.blocks[e].count) : i.setFromBufferAttributeRange(t.attributes.position, n.start, n.count) : i.makeEmpty(),
                t.groups[e].box = i
            } else;
        }
        n.d(e, "a",
        function() {
            return s
        });
        var r = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        a = n("CustomerDefine3"),
        o = n("CustomerDefine4"),
        s = function() {
            function t(t) {
                var e = this;
                this.capacity = 0,
                this.onGeometryDisposed = function(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", e.onGeometryDisposed),
                    e.removeGeometry(n)
                },
                this.reallocate(t),
                this.geometries = new o.a(t)
            }
            return t.prototype.dispose = function() {
                var t = this;
                this.geometries.forEach(function(e) {
                    e._egsGeoId = undefined,
                    e.removeEventListener("dispose", t.onGeometryDisposed)
                })
            },
            t.prototype.reallocate = function(t) {
                var e = new Float32Array(t * a.a);
                this.capacity > 0 && this.geometries.length > 0 && e.set(this.boxes),
                this.boxes = e,
                this.capacity = t
            },
            t.prototype.reset = function() {
                this.geometries.reset()
            },
            t.prototype.getGeoId = function(t) {
                return t._egsGeoId
            },
            t.prototype.addGeometry = function(t) {
                var e = t._egsGeoId;
                return undefined !== e ? e: (t.addEventListener("dispose", this.onGeometryDisposed), this.doAddGeometry(t))
            },
            t.prototype.doAddGeometry = function(t) {
                var e = this.geometries.addItemNoduplicate(t);
                if (this.capacity <= e && this.reallocate(Math.ceil(1.8 * this.capacity)), -1 === e) throw "rendermodel geometry list error";
                t._egsGeoId = e;
                var n = t.boundingBox;
                return n || (t.computeBoundingBox(), n = t.boundingBox),
                a.b.setFromThree(this.boxes, t._egsGeoId, n),
                i(t),
                t._egsGeoId
            },
            t.prototype.removeGeometry = function(t) {
                t && undefined !== t._egsGeoId && (this.geometries.removeItem(t, t._egsGeoId), t._egsGeoId = undefined)
            },
            t
        } ()
    },
    "52ZB": function(t, e, n) {
        "use strict";

        function i(t) {
            t.transparent = true,
            t.depthTest = false,
            t.depthWrite = false,
            t.blending = a.g,
            t.blendSrc = a.k,
            t.blendDst = a.L,
            t.blendEquation = a.a,
            t.blendSrcAlpha = a.j,
            t.blendDstAlpha = a.L,
            t.blendEquationAlpha = a.a
        }
        n.d(e, "a",
        function() {
            return p
        });
        var r = n("v504"),
        a = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        o = n("sz/p"),
        s = n("LL6t"),
        u = n("5EHP"),
        c = n("N+Ao"),
        h = n("r7QY"),
        l = n("2rQf"),
        f = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        p = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.options = {
                    highQuality: true
                },
                e.renderToScreen = false,
                e.encodePass = new h.a,
                e.encodeTarget = new r.a(1, 1, {
                    minFilter: a.u,
                    magFilter: a.u
                }),
                e.outlineLowQuality = new l.a(c.a, "diffuseMap"),
                e.outlineLowQuality.material.extensions.derivatives = true,
                e.outlineLowQuality.defines.HIGH_QUALITY = 0,
                e.outlineLowQuality.uniforms.indexNormalMap.value = e.encodeTarget.texture,
                e.outlineHighQuality = new l.a(c.a, "diffuseMap"),
                e.outlineHighQuality.material.extensions.derivatives = true,
                e.outlineHighQuality.defines.HIGH_QUALITY = 1,
                e.outlineHighQuality.uniforms.indexNormalMap.value = e.encodeTarget.texture,
                e.computeTarget = new r.a(1, 1, {
                    depthBuffer: false,
                    stencilBuffer: false,
                    minFilter: a.u,
                    magFilter: a.u
                }),
                e.blendLowQuality = new l.a(s.a),
                e.blendLowQuality.clear = false,
                i(e.blendLowQuality.material),
                e.blendHighQuality = new l.a(u.a, "sourceMap"),
                e.blendHighQuality.clear = false,
                i(e.blendHighQuality.material),
                e.highQuality = true,
                e
            }
            return f(e, t),
            Object.defineProperty(e.prototype, "highQuality", {
                get: function() {
                    return this.options.highQuality
                },
                set: function(t) {
                    this.options.highQuality = t,
                    this.computePass = t ? this.outlineHighQuality: this.outlineLowQuality,
                    this.blendPass = t ? this.blendHighQuality: this.blendLowQuality,
                    this.resize()
                },
                enumerable: true,
                configurable: true
            }),
            e.prototype.render = function(t, e) {
                this.blendPass.renderToScreen = this.renderToScreen,
                this.encodePass.render(t, this.encodeTarget),
                this.computePass.render(t, this.computeTarget),
                this.blendPass.render(t, e, this.computeTarget)
            },
            e.prototype.setSize = function(t, e) {
                this.drawingBufferWidth = t,
                this.drawingBufferHeight = e,
                this.resize()
            },
            e.prototype.resize = function() {
                if (this.drawingBufferWidth) {
                    var t = this.highQuality ? 2 : 1,
                    e = Math.min(this.drawingBufferWidth * t, 4096),
                    n = Math.min(this.drawingBufferHeight * t, 4096),
                    i = 1 / e,
                    r = 1 / n;
                    this.encodeTarget.setSize(e, n),
                    this.computePass.uniforms.texelSize.value.set(i, r),
                    this.computeTarget.setSize(e, n),
                    this.blendHighQuality.uniforms.texelSize.value.set(i, r)
                }
            },
            e.prototype.setup = function(e, n) {
                t.prototype.setup.call(this, e, n),
                this.encodePass.setup(e, n),
                this.computePass.setup(e, n),
                this.blendPass.setup(e, n)
            },
            e
        } (o.a)
    },
    "53qq": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return a
        });
        var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        r = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        
    },
    "MeshDepthMaterial": function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.type = "MeshDepthMaterial",
            this.depthPacking = a.g,
            this.skinning = false,
            this.morphTargets = false,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.wireframe = false,
            this.wireframeLinewidth = 1,
            this.fog = false,
            this.lights = false,
            this.setValues(t)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Material"),
        a = n("RBSo");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isMeshDepthMaterial = true,
        i.prototype.copy = function(t) {
            return r.a.prototype.copy.call(this, t),
            this.depthPacking = t.depthPacking,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.map = t.map,
            this.alphaMap = t.alphaMap,
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this
        }
    },
    "5AlW": function(t, e, n) {
        "use strict";

        function i(t) {
            a.a.call(this, t),
            this.panner = this.context.createPanner(),
            this.panner.connect(this.gain)
        }
        var r = n("Vector3"),
        a = n("Audio"),
        o = n("Object3D");
        i.prototype = Object.assign(Object.create(a.a.prototype), {
            constructor: i,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(t) {
                this.panner.refDistance = t
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(t) {
                this.panner.rolloffFactor = t
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(t) {
                this.panner.distanceModel = t
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(t) {
                this.panner.maxDistance = t
            },
            updateMatrixWorld: function() {
                var t = new r.a;
                return function(e) {
                    o.a.prototype.updateMatrixWorld.call(this, e),
                    t.setFromMatrixPosition(this.matrixWorld),
                    this.panner.setPosition(t.x, t.y, t.z)
                }
            } ()
        })
    },
    "5EHP": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return o
        });
        var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        r = n("D+VX"),
        a = n("0P0p"),
        o = {
            uniforms: {
                sourceMap: {
                    value: null
                },
                texelSize: {
                    value: new i.I(1, 1)
                }
            },
            vertexShader: a.a,
            fragmentShader: r.a
        }
    },
    "MeshPhongMaterial": function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.type = "MeshPhongMaterial",
            this.color = new s.a(16777215),
            this.specular = new s.a(1118481),
            this.shininess = 30,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new s.a(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalScale = new Vector2()(1, 1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = a._4,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = false,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = false,
            this.morphTargets = false,
            this.morphNormals = false,
            this.setValues(t)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Material"),
        a = n("RBSo"),
        // o = n("Vector2"),
        s = n("Color");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isMeshPhongMaterial = true,
        i.prototype.copy = function(t) {
            return r.a.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.specular.copy(t.specular),
            this.shininess = t.shininess,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.specularMap = t.specularMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.combine = t.combine,
            this.reflectivity = t.reflectivity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this
        }
    },
    "5f+G": function(t, e, n) {
        "use strict";
        e.a = "#if defined( DITHERING )\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\\n"
    },
    "PopModelData": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return a
        });
        // var i = n("lUBy")
        function inlineFunction1(t) {
            for (var e = "",
            n = 0; n < t.length; n++) {
                var i = t[n];
                if (i < 128) e += String.fromCharCode(i);
                else if (i > 191 && i < 224) e += String.fromCharCode((31 & i) << 6 | 63 & t[n + 1]),
                n += 1;
                else if (i > 223 && i < 240) e += String.fromCharCode((15 & i) << 12 | (63 & t[n + 1]) << 6 | 63 & t[n + 2]),
                n += 2;
                else {
                    var r = ((7 & i) << 18 | (63 & t[n + 1]) << 12 | (63 & t[n + 2]) << 6 | 63 & t[n + 3]) - 65536;
                    e += String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320),
                    n += 3
                }
            }
            return e
        }
        // r = n("Q2ls"),
        function inlineFunction1(t) {
            var r = new Int8Array(4);
            a = new Int32Array(r.buffer, 0, 1);
            o = new Float32Array(r.buffer, 0, 1);
            return a[0] = t, o[0]
        }

        a = function() {
            function t(t) {
                this.data = t,
                this.position = 0
            }
            return t.prototype.flip = function() {
                this.data = this.data.reverse(),
                this.position = 0
            },
            t.prototype.readByte = function() {
                return this.data[this.position++]
            },
            t.prototype.readBytes = function(t) {
                return this.position += t,
                this.data.slice(this.position - t, this.position)
            },
            t.prototype.readSwappedShort = function() {
                return this.readByte() | this.readByte() << 8
            },
            t.prototype.readSwappedInt = function() {
                return this.readByte() | this.readByte() << 8 | this.readByte() << 16 | this.readByte() << 24
            },
            t.prototype.readSwappedFloat = function() {
                return inlineFunction1(this.readSwappedInt())
            },
            t.prototype.readUTFBytes = function(t) {
                return inlineFunction1(this.readBytes(t))
            },
            t.prototype.readZigzag = function() {
                var t = this.readVarint();
                return t % 2 == 0 ? .5 * t: -.5 * (t + 1)
            },
            t.prototype.readVarint = function() {
                for (var t = 0,
                e = 0; e < 32; e += 7) {
                    var n = this.readByte();
                    if (t |= (127 & n) << e, 0 == (128 & n)) break
                }
                return t
            },
            t.prototype.readByte3 = function() {
                return {
                    x: this.readByte(),
                    y: this.readByte(),
                    z: this.readByte()
                }
            },
            t.prototype.readFloat3 = function() {
                return {
                    x: this.readSwappedFloat(),
                    y: this.readSwappedFloat(),
                    z: this.readSwappedFloat()
                }
            },
            t
        } ()
    },
    "5qJX": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return u
        });
        var i = n("+8dW"),
        r = n("Object3D"),
        a = n("Jjpd"),
        o = n("CustomerDefine3"),
        s = n("9qOK"),
        u = function() {
            function t(t) {
                var e = this;
                this.model = null,
                this.updateModelNodeVisitor = null,
                this.nodeTraversalFilter = null,
                this.updateId = 1,
                this.doc = null,
                this.doc = t,
                this.updateModelNodeVisitor = function(t) {
                    return e.updateNode(t)
                },
                this.nodeTraversalFilter = function(t) {
                    var n = t.sceneNode;
                    if (n && !n.needsUpdate) {
                        var i = t.parent ? t.parent.sceneNode: null;
                        return ! i || i.netVisiblityUpdateTimestamp !== e.updateId && i.worldMatrixUpdateTimestamp !== e.updateId && i.attributeUpdateTimeStamp !== e.updateId
                    }
                    return ! 1
                }
            }
            return t.prototype.build = function() {
                this.updateId++,
                Object(s.a)(this.model.scene, this.updateModelNodeVisitor, this.nodeTraversalFilter)
            },
            t.prototype.updateAttributes = function(t, e) {
                for (var n = t.attribute,
                r = t.sceneNode,
                a = 0; a < i.a.valueCount; a++) { ( - 1 === n.updateTimestamp[a] || undefined !== n.parent && n.parent.updateTimestamp[a] === e) && (undefined !== n.parent && undefined !== n.parent.netValue[a] ? (n.netValue[a] = n.parent.netValue[a], n.updateTimestamp[a] = e, r.attributeUpdateTimeStamp = e) : (n.netValue[a] = n.value[a], n.updateTimestamp[a] = e, r.attributeUpdateTimeStamp = e))
                }
            },
            t.prototype.updateObject = function(t) {
                this.model.fragments.removeFragments(t);
                var e = t.geometry,
                n = t.material;
                t._egsFragIds = [];
                var i = this.model.geometries.addGeometry(e),
                r = this.model.objects.addObject(t);
                if (Array.isArray(n)) for (var a = 0; a < e.groups.length; a++) {
                    var o = this.model.fragments.addFragment(t);
                    this.model.fragments.setFragGeometry(o, i),
                    this.model.fragments.setFragObject(o, r);
                    var s = this.model.materials.addMaterial(n[a]);
                    this.model.fragments.setFragMaterialIndex(o, a),
                    this.model.fragments.setFragMaterial(o, s),
                    t._egsFragIds.push(o)
                } else {
                    var o = this.model.fragments.addFragment(t),
                    s = this.model.materials.addMaterial(n);
                    this.model.fragments.setFragMaterial(o, s),
                    this.model.fragments.setFragMaterialIndex(o, 0),
                    this.model.fragments.setFragGeometry(o, i),
                    this.model.fragments.setFragObject(o, r),
                    t._egsFragIds.push(o)
                }
                return t._egsFragIds
            },
            t.prototype.updateNode = function(t) {
                var e, n = t,
                i = n.sceneNode,
                o = false,
                s = false,
                u = false,
                c = false,
                h = false,
                l = false,
                f = n.isMesh || n.isPopMesh || n.isLine || n.isPoints;
                f || (n.isLight ? this.model.lights.addLight(n) : n.isSprite && this.model.sprites.addSprite(n)),
                undefined === i && (i = new a.a(this.doc, n), n.sceneNode = i, h = true),
                l = h,
                f && (e = this.model.fragments.getObjectFragmentIds(n), h && (e = this.updateObject(n)));
                var p = t.parent ? t.parent.sceneNode: null;
                if (i.changes & r.b.GEOMETRY_CHANGED && f && (this.updateObject(n), l = true, c = true), i.changes & r.b.MATERIAL_CHANGED && f && (this.updateObject(n), l = true), u = u || h, u = u || p && p.attributeUpdateTimeStamp === this.updateId, u = u || (i.changes & r.b.ATTRIBUTE_CHANGED) > 0, u && this.updateAttributes(t, this.updateId), s = s || l, s = s || p && p.netVisiblityUpdateTimestamp === this.updateId, s = s || (i.changes & r.b.VISIBILITY_CHANGED) > 0) {
                    var d = t.visible;
                    d = !(p && !p.netVisiblity) && d,
                    (h || d !== i.netVisiblity) && (i.netVisiblity = d, i.netVisiblityUpdateTimestamp = this.updateId, f && this.model.fragments.setFragsVisible(e, i.netVisiblity))
                }
                o = o || l,
                o = o || p && p.worldMatrixUpdateTimestamp === this.updateId,
                o = o || !!(i.changes & r.b.MATRIX_CHANGED),
                o && (t.matrixWorldNeedsUpdate && t.updateMatrixWorld(false), i.worldMatrixUpdateTimestamp = this.updateId),
                c = c || o,
                c && f && this.applyTransformations(n, this.model.fragments.boxes, e, n.matrixWorld),
                i.setNodeUpdated()
            },
            t.prototype.applyTransformations = function(t, e, n, i) {
                if (Array.isArray(t.material)) for (var r = t.geometry.groups,
                a = 0; a < r.length; a++) {
                    var s = r[a].box;
                    o.b.applyTransformationFromBox(s, e, n[a], i)
                } else {
                    var s = t.geometry.boundingBox;
                    o.b.applyTransformationFromBox(s, e, n[0], i)
                }
            },
            t.prototype.onSceneObjectRemoved = function(t) {
                function e(t) {
                    n.fragments.removeFragments(t),
                    n.lights.removeLight(t),
                    n.sprites.removeSprite(t),
                    n.objects.removeObject(t),
                    t.sceneNode = undefined;
                    for (var i = 0,
                    r = t.children; i < r.length; i++) {
                        e(r[i])
                    }
                }
                var n = this.model;
                e(t)
            },
            t
        } ()
    },
    "Matrix4": function(t, e, n) {
        "use strict";

        function Matrix4() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        n.d(e, "a",
        function() {
            return Matrix4
        });
        var r = n("Vector3");
        Object.assign(i.prototype, {
            isMatrix4: true,
            set: function(t, e, n, i, r, a, o, s, u, c, h, l, f, p, d, m) {
                var v = this.elements;
                return v[0] = t,
                v[4] = e,
                v[8] = n,
                v[12] = i,
                v[1] = r,
                v[5] = a,
                v[9] = o,
                v[13] = s,
                v[2] = u,
                v[6] = c,
                v[10] = h,
                v[14] = l,
                v[3] = f,
                v[7] = p,
                v[11] = d,
                v[15] = m,
                this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            },
            clone: function() {
                return (new i).fromArray(this.elements)
            },
            copy: function(t) {
                var e = this.elements,
                n = t.elements;
                return e[0] = n[0],
                e[1] = n[1],
                e[2] = n[2],
                e[3] = n[3],
                e[4] = n[4],
                e[5] = n[5],
                e[6] = n[6],
                e[7] = n[7],
                e[8] = n[8],
                e[9] = n[9],
                e[10] = n[10],
                e[11] = n[11],
                e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                e[15] = n[15],
                this
            },
            copyPosition: function(t) {
                var e = this.elements,
                n = t.elements;
                return e[12] = n[12],
                e[13] = n[13],
                e[14] = n[14],
                this
            },
            extractBasis: function(t, e, n) {
                return t.setFromMatrixColumn(this, 0),
                e.setFromMatrixColumn(this, 1),
                n.setFromMatrixColumn(this, 2),
                this
            },
            makeBasis: function(t, e, n) {
                return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1),
                this
            },
            extractRotation: function() {
                var t;
                return function(e) {
                    undefined === t && (t = new r.a);
                    var n = this.elements,
                    i = e.elements,
                    a = 1 / t.setFromMatrixColumn(e, 0).length(),
                    o = 1 / t.setFromMatrixColumn(e, 1).length(),
                    s = 1 / t.setFromMatrixColumn(e, 2).length();
                    return n[0] = i[0] * a,
                    n[1] = i[1] * a,
                    n[2] = i[2] * a,
                    n[4] = i[4] * o,
                    n[5] = i[5] * o,
                    n[6] = i[6] * o,
                    n[8] = i[8] * s,
                    n[9] = i[9] * s,
                    n[10] = i[10] * s,
                    this
                }
            } (),
            makeRotationFromEuler: function(t) {
                t && t.isEuler || console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z,
                a = Math.cos(n),
                o = Math.sin(n),
                s = Math.cos(i),
                u = Math.sin(i),
                c = Math.cos(r),
                h = Math.sin(r);
                if ("XYZ" === t.order) {
                    var l = a * c,
                    f = a * h,
                    p = o * c,
                    d = o * h;
                    e[0] = s * c,
                    e[4] = -s * h,
                    e[8] = u,
                    e[1] = f + p * u,
                    e[5] = l - d * u,
                    e[9] = -o * s,
                    e[2] = d - l * u,
                    e[6] = p + f * u,
                    e[10] = a * s
                } else if ("YXZ" === t.order) {
                    var m = s * c,
                    v = s * h,
                    g = u * c,
                    y = u * h;
                    e[0] = m + y * o,
                    e[4] = g * o - v,
                    e[8] = a * u,
                    e[1] = a * h,
                    e[5] = a * c,
                    e[9] = -o,
                    e[2] = v * o - g,
                    e[6] = y + m * o,
                    e[10] = a * s
                } else if ("ZXY" === t.order) {
                    var m = s * c,
                    v = s * h,
                    g = u * c,
                    y = u * h;
                    e[0] = m - y * o,
                    e[4] = -a * h,
                    e[8] = g + v * o,
                    e[1] = v + g * o,
                    e[5] = a * c,
                    e[9] = y - m * o,
                    e[2] = -a * u,
                    e[6] = o,
                    e[10] = a * s
                } else if ("ZYX" === t.order) {
                    var l = a * c,
                    f = a * h,
                    p = o * c,
                    d = o * h;
                    e[0] = s * c,
                    e[4] = p * u - f,
                    e[8] = l * u + d,
                    e[1] = s * h,
                    e[5] = d * u + l,
                    e[9] = f * u - p,
                    e[2] = -u,
                    e[6] = o * s,
                    e[10] = a * s
                } else if ("YZX" === t.order) {
                    var _ = a * s,
                    x = a * u,
                    b = o * s,
                    w = o * u;
                    e[0] = s * c,
                    e[4] = w - _ * h,
                    e[8] = b * h + x,
                    e[1] = h,
                    e[5] = a * c,
                    e[9] = -o * c,
                    e[2] = -u * c,
                    e[6] = x * h + b,
                    e[10] = _ - w * h
                } else if ("XZY" === t.order) {
                    var _ = a * s,
                    x = a * u,
                    b = o * s,
                    w = o * u;
                    e[0] = s * c,
                    e[4] = -h,
                    e[8] = u * c,
                    e[1] = _ * h + w,
                    e[5] = a * c,
                    e[9] = x * h - b,
                    e[2] = b * h - x,
                    e[6] = o * c,
                    e[10] = w * h + _
                }
                return e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            },
            makeRotationFromQuaternion: function(t) {
                var e = this.elements,
                n = t._x,
                i = t._y,
                r = t._z,
                a = t._w,
                o = n + n,
                s = i + i,
                u = r + r,
                c = n * o,
                h = n * s,
                l = n * u,
                f = i * s,
                p = i * u,
                d = r * u,
                m = a * o,
                v = a * s,
                g = a * u;
                return e[0] = 1 - (f + d),
                e[4] = h - g,
                e[8] = l + v,
                e[1] = h + g,
                e[5] = 1 - (c + d),
                e[9] = p - m,
                e[2] = l - v,
                e[6] = p + m,
                e[10] = 1 - (c + f),
                e[3] = 0,
                e[7] = 0,
                e[11] = 0,
                e[12] = 0,
                e[13] = 0,
                e[14] = 0,
                e[15] = 1,
                this
            },
            lookAt: function() {
                var t, e, n;
                return function(i, a, o) {
                    undefined === t && (t = new r.a),
                    undefined === e && (e = new r.a),
                    undefined === n && (n = new r.a);
                    var s = this.elements;
                    return n.subVectors(i, a),
                    0 === n.lengthSq() && (n.z = 1),
                    n.normalize(),
                    t.crossVectors(o, n),
                    0 === t.lengthSq() && (1 === Math.abs(o.z) ? n.x += 1e-4: n.z += 1e-4, n.normalize(), t.crossVectors(o, n)),
                    t.normalize(),
                    e.crossVectors(n, t),
                    s[0] = t.x,
                    s[4] = e.x,
                    s[8] = n.x,
                    s[1] = t.y,
                    s[5] = e.y,
                    s[9] = n.y,
                    s[2] = t.z,
                    s[6] = e.z,
                    s[10] = n.z,
                    this
                }
            } (),
            multiply: function(t, e) {
                return undefined !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
            },
            premultiply: function(t) {
                return this.multiplyMatrices(t, this)
            },
            multiplyMatrices: function(t, e) {
                var n = t.elements,
                i = e.elements,
                r = this.elements,
                a = n[0],
                o = n[4],
                s = n[8],
                u = n[12],
                c = n[1],
                h = n[5],
                l = n[9],
                f = n[13],
                p = n[2],
                d = n[6],
                m = n[10],
                v = n[14],
                g = n[3],
                y = n[7],
                _ = n[11],
                x = n[15],
                b = i[0],
                w = i[4],
                M = i[8],
                S = i[12],
                E = i[1],
                T = i[5],
                A = i[9],
                C = i[13],
                P = i[2],
                L = i[6],
                R = i[10],
                I = i[14],
                O = i[3],
                N = i[7],
                D = i[11],
                U = i[15];
                return r[0] = a * b + o * E + s * P + u * O,
                r[4] = a * w + o * T + s * L + u * N,
                r[8] = a * M + o * A + s * R + u * D,
                r[12] = a * S + o * C + s * I + u * U,
                r[1] = c * b + h * E + l * P + f * O,
                r[5] = c * w + h * T + l * L + f * N,
                r[9] = c * M + h * A + l * R + f * D,
                r[13] = c * S + h * C + l * I + f * U,
                r[2] = p * b + d * E + m * P + v * O,
                r[6] = p * w + d * T + m * L + v * N,
                r[10] = p * M + d * A + m * R + v * D,
                r[14] = p * S + d * C + m * I + v * U,
                r[3] = g * b + y * E + _ * P + x * O,
                r[7] = g * w + y * T + _ * L + x * N,
                r[11] = g * M + y * A + _ * R + x * D,
                r[15] = g * S + y * C + _ * I + x * U,
                this
            },
            multiplyScalar: function(t) {
                var e = this.elements;
                return e[0] *= t,
                e[4] *= t,
                e[8] *= t,
                e[12] *= t,
                e[1] *= t,
                e[5] *= t,
                e[9] *= t,
                e[13] *= t,
                e[2] *= t,
                e[6] *= t,
                e[10] *= t,
                e[14] *= t,
                e[3] *= t,
                e[7] *= t,
                e[11] *= t,
                e[15] *= t,
                this
            },
            applyToBufferAttribute: function() {
                var t;
                return function(e) {
                    undefined === t && (t = new r.a);
                    for (var n = 0,
                    i = e.count; n < i; n++) t.x = e.getX(n),
                    t.y = e.getY(n),
                    t.z = e.getZ(n),
                    t.applyMatrix4(this),
                    e.setXYZ(n, t.x, t.y, t.z);
                    return e
                }
            } (),
            determinant: function() {
                var t = this.elements,
                e = t[0],
                n = t[4],
                i = t[8],
                r = t[12],
                a = t[1],
                o = t[5],
                s = t[9],
                u = t[13],
                c = t[2],
                h = t[6],
                l = t[10],
                f = t[14];
                return t[3] * ( + r * s * h - i * u * h - r * o * l + n * u * l + i * o * f - n * s * f) + t[7] * ( + e * s * f - e * u * l + r * a * l - i * a * f + i * u * c - r * s * c) + t[11] * ( + e * u * h - e * o * f - r * a * h + n * a * f + r * o * c - n * u * c) + t[15] * ( - i * o * c - e * s * h + e * o * l + i * a * h - n * a * l + n * s * c)
            },
            transpose: function() {
                var t, e = this.elements;
                return t = e[1],
                e[1] = e[4],
                e[4] = t,
                t = e[2],
                e[2] = e[8],
                e[8] = t,
                t = e[6],
                e[6] = e[9],
                e[9] = t,
                t = e[3],
                e[3] = e[12],
                e[12] = t,
                t = e[7],
                e[7] = e[13],
                e[13] = t,
                t = e[11],
                e[11] = e[14],
                e[14] = t,
                this
            },
            setPosition: function(t) {
                var e = this.elements;
                return e[12] = t.x,
                e[13] = t.y,
                e[14] = t.z,
                this
            },
            getInverse: function(t, e) {
                var n = this.elements,
                i = t.elements,
                r = i[0],
                a = i[1],
                o = i[2],
                s = i[3],
                u = i[4],
                c = i[5],
                h = i[6],
                l = i[7],
                f = i[8],
                p = i[9],
                d = i[10],
                m = i[11],
                v = i[12],
                g = i[13],
                y = i[14],
                _ = i[15],
                x = p * y * l - g * d * l + g * h * m - c * y * m - p * h * _ + c * d * _,
                b = v * d * l - f * y * l - v * h * m + u * y * m + f * h * _ - u * d * _,
                w = f * g * l - v * p * l + v * c * m - u * g * m - f * c * _ + u * p * _,
                M = v * p * h - f * g * h - v * c * d + u * g * d + f * c * y - u * p * y,
                S = r * x + a * b + o * w + s * M;
                if (0 === S) {
                    var E = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                    if (true === e) throw new Error(E);
                    return console.warn(E),
                    this.identity()
                }
                var T = 1 / S;
                return n[0] = x * T,
                n[1] = (g * d * s - p * y * s - g * o * m + a * y * m + p * o * _ - a * d * _) * T,
                n[2] = (c * y * s - g * h * s + g * o * l - a * y * l - c * o * _ + a * h * _) * T,
                n[3] = (p * h * s - c * d * s - p * o * l + a * d * l + c * o * m - a * h * m) * T,
                n[4] = b * T,
                n[5] = (f * y * s - v * d * s + v * o * m - r * y * m - f * o * _ + r * d * _) * T,
                n[6] = (v * h * s - u * y * s - v * o * l + r * y * l + u * o * _ - r * h * _) * T,
                n[7] = (u * d * s - f * h * s + f * o * l - r * d * l - u * o * m + r * h * m) * T,
                n[8] = w * T,
                n[9] = (v * p * s - f * g * s - v * a * m + r * g * m + f * a * _ - r * p * _) * T,
                n[10] = (u * g * s - v * c * s + v * a * l - r * g * l - u * a * _ + r * c * _) * T,
                n[11] = (f * c * s - u * p * s - f * a * l + r * p * l + u * a * m - r * c * m) * T,
                n[12] = M * T,
                n[13] = (f * g * o - v * p * o + v * a * d - r * g * d - f * a * y + r * p * y) * T,
                n[14] = (v * c * o - u * g * o - v * a * h + r * g * h + u * a * y - r * c * y) * T,
                n[15] = (u * p * o - f * c * o + f * a * h - r * p * h - u * a * d + r * c * d) * T,
                this
            },
            scale: function(t) {
                var e = this.elements,
                n = t.x,
                i = t.y,
                r = t.z;
                return e[0] *= n,
                e[4] *= i,
                e[8] *= r,
                e[1] *= n,
                e[5] *= i,
                e[9] *= r,
                e[2] *= n,
                e[6] *= i,
                e[10] *= r,
                e[3] *= n,
                e[7] *= i,
                e[11] *= r,
                this
            },
            getMaxScaleOnAxis: function() {
                var t = this.elements,
                e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                return Math.sqrt(Math.max(e, n, i))
            },
            makeTranslation: function(t, e, n) {
                return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
                this
            },
            makeRotationX: function(t) {
                var e = Math.cos(t),
                n = Math.sin(t);
                return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1),
                this
            },
            makeRotationY: function(t) {
                var e = Math.cos(t),
                n = Math.sin(t);
                return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1),
                this
            },
            makeRotationZ: function(t) {
                var e = Math.cos(t),
                n = Math.sin(t);
                return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                this
            },
            makeRotationAxis: function(t, e) {
                var n = Math.cos(e),
                i = Math.sin(e),
                r = 1 - n,
                a = t.x,
                o = t.y,
                s = t.z,
                u = r * a,
                c = r * o;
                return this.set(u * a + n, u * o - i * s, u * s + i * o, 0, u * o + i * s, c * o + n, c * s - i * a, 0, u * s - i * o, c * s + i * a, r * s * s + n, 0, 0, 0, 0, 1),
                this
            },
            makeScale: function(t, e, n) {
                return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
                this
            },
            makeShear: function(t, e, n) {
                return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1),
                this
            },
            compose: function(t, e, n) {
                return this.makeRotationFromQuaternion(e),
                this.scale(n),
                this.setPosition(t),
                this
            },
            decompose: function() {
                var t, e = new i;
                return function(n, i, a) {
                    undefined === t && (t = new r.a);
                    var o = this.elements,
                    s = t.set(o[0], o[1], o[2]).length(),
                    u = t.set(o[4], o[5], o[6]).length(),
                    c = t.set(o[8], o[9], o[10]).length();
                    this.determinant() < 0 && (s = -s),
                    n.x = o[12],
                    n.y = o[13],
                    n.z = o[14],
                    e.copy(this);
                    var h = 1 / s,
                    l = 1 / u,
                    f = 1 / c;
                    return e.elements[0] *= h,
                    e.elements[1] *= h,
                    e.elements[2] *= h,
                    e.elements[4] *= l,
                    e.elements[5] *= l,
                    e.elements[6] *= l,
                    e.elements[8] *= f,
                    e.elements[9] *= f,
                    e.elements[10] *= f,
                    i.setFromRotationMatrix(e),
                    a.x = s,
                    a.y = u,
                    a.z = c,
                    this
                }
            } (),
            makePerspective: function(t, e, n, i, r, a) {
                undefined === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                var o = this.elements,
                s = 2 * r / (e - t),
                u = 2 * r / (n - i),
                c = (e + t) / (e - t),
                h = (n + i) / (n - i),
                l = -(a + r) / (a - r),
                f = -2 * a * r / (a - r);
                return o[0] = s,
                o[4] = 0,
                o[8] = c,
                o[12] = 0,
                o[1] = 0,
                o[5] = u,
                o[9] = h,
                o[13] = 0,
                o[2] = 0,
                o[6] = 0,
                o[10] = l,
                o[14] = f,
                o[3] = 0,
                o[7] = 0,
                o[11] = -1,
                o[15] = 0,
                this
            },
            makeOrthographic: function(t, e, n, i, r, a) {
                var o = this.elements,
                s = 1 / (e - t),
                u = 1 / (n - i),
                c = 1 / (a - r),
                h = (e + t) * s,
                l = (n + i) * u,
                f = (a + r) * c;
                return o[0] = 2 * s,
                o[4] = 0,
                o[8] = 0,
                o[12] = -h,
                o[1] = 0,
                o[5] = 2 * u,
                o[9] = 0,
                o[13] = -l,
                o[2] = 0,
                o[6] = 0,
                o[10] = -2 * c,
                o[14] = -f,
                o[3] = 0,
                o[7] = 0,
                o[11] = 0,
                o[15] = 1,
                this
            },
            equals: function(t) {
                for (var e = this.elements,
                n = t.elements,
                i = 0; i < 16; i++) if (e[i] !== n[i]) return ! 1;
                return ! 0
            },
            fromArray: function(t, e) {
                undefined === e && (e = 0);
                for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                return this
            },
            toArray: function(t, e) {
                undefined === t && (t = []),
                undefined === e && (e = 0);
                var n = this.elements;
                return t[e] = n[0],
                t[e + 1] = n[1],
                t[e + 2] = n[2],
                t[e + 3] = n[3],
                t[e + 4] = n[4],
                t[e + 5] = n[5],
                t[e + 6] = n[6],
                t[e + 7] = n[7],
                t[e + 8] = n[8],
                t[e + 9] = n[9],
                t[e + 10] = n[10],
                t[e + 11] = n[11],
                t[e + 12] = n[12],
                t[e + 13] = n[13],
                t[e + 14] = n[14],
                t[e + 15] = n[15],
                t
            }
        })
    },
    "6Q3k": function(t, e, n) {
        "use strict";

        function i(t) {
            this.manager = undefined !== t ? t: o.a,
            this.textures = {}
        }
        n.d(e, "a",
        function() {
            return i
        });
        a = n("w2Sq"),
        o = n("OJZr"),
        s = n("eekH");
        Object.assign(i.prototype, {
            load: function(t, e, n, i) {
                var r = this;
                new a.a(r.manager).load(t,
                function(t) {
                    e(r.parse(JSON.parse(t)))
                },
                n, i)
            },
            setTextures: function(t) {
                this.textures = t
            },
            parse: function(t) {
                function e(t) {
                    return undefined === n[t] && console.warn("THREE.MaterialLoader: Undefined texture", t),
                    n[t]
                }
                var n = this.textures,
                i = new s[t.type];
                if (undefined !== t.uuid && (i.uuid = t.uuid), 
                    undefined !== t.name && (i.name = t.name), 
                    undefined !== t.color && i.color.setHex(t.color), 
                    undefined !== t.roughness && (i.roughness = t.roughness), 
                    undefined !== t.metalness && (i.metalness = t.metalness), 
                    undefined !== t.emissive && i.emissive.setHex(t.emissive), 
                    undefined !== t.specular && i.specular.setHex(t.specular), undefined !== t.shininess 
                    && (i.shininess = t.shininess), undefined !== t.clearCoat && (i.clearCoat = t.clearCoat), 
                    undefined !== t.clearCoatRoughness && (i.clearCoatRoughness = t.clearCoatRoughness), 
                    undefined !== t.uniforms && (i.uniforms = t.uniforms), undefined !== t.vertexShader 
                    && (i.vertexShader = t.vertexShader), undefined !== t.fragmentShader 
                    && (i.fragmentShader = t.fragmentShader), undefined !== t.vertexColors 
                    && (i.vertexColors = t.vertexColors), undefined !== t.fog && (i.fog = t.fog), 
                    undefined !== t.shading && (i.shading = t.shading), undefined !== t.blending && 
                    (i.blending = t.blending), undefined !== t.side && (i.side = t.side), 
                    undefined !== t.opacity && (i.opacity = t.opacity), undefined !== t.transparent 
                    && (i.transparent = t.transparent), undefined !== t.alphaTest && 
                    (i.alphaTest = t.alphaTest), undefined !== t.depthTest && 
                    (i.depthTest = t.depthTest), undefined !== t.depthWrite && 
                    (i.depthWrite = t.depthWrite), undefined !== t.colorWrite && 
                    (i.colorWrite = t.colorWrite), undefined !== t.wireframe && (i.wireframe = t.wireframe), 
                    undefined !== t.wireframeLinewidth && (i.wireframeLinewidth = t.wireframeLinewidth),
                     undefined !== t.wireframeLinecap && (i.wireframeLinecap = t.wireframeLinecap), undefined !== t.wireframeLinejoin && (i.wireframeLinejoin = t.wireframeLinejoin), undefined !== t.skinning && (i.skinning = t.skinning), undefined !== t.morphTargets && (i.morphTargets = t.morphTargets), undefined !== t.size && (i.size = t.size), undefined !== t.sizeAttenuation && (i.sizeAttenuation = t.sizeAttenuation), undefined !== t.map && (i.map = e(t.map)), undefined !== t.alphaMap && (i.alphaMap = e(t.alphaMap), i.transparent = true), undefined !== t.bumpMap && (i.bumpMap = e(t.bumpMap)), undefined !== t.bumpScale && (i.bumpScale = t.bumpScale), undefined !== t.normalMap && (i.normalMap = e(t.normalMap)), undefined !== t.normalScale) {
                    var a = t.normalScale; ! 1 === Array.isArray(a) && (a = [a, a]),
                    i.normalScale = (new Vector2()).fromArray(a)
                }
                return undefined !== t.displacementMap && (i.displacementMap = e(t.displacementMap)),
                undefined !== t.displacementScale && (i.displacementScale = t.displacementScale),
                undefined !== t.displacementBias && (i.displacementBias = t.displacementBias),
                undefined !== t.roughnessMap && (i.roughnessMap = e(t.roughnessMap)),
                undefined !== t.metalnessMap && (i.metalnessMap = e(t.metalnessMap)),
                undefined !== t.emissiveMap && (i.emissiveMap = e(t.emissiveMap)),
                undefined !== t.emissiveIntensity && (i.emissiveIntensity = t.emissiveIntensity),
                undefined !== t.specularMap && (i.specularMap = e(t.specularMap)),
                undefined !== t.envMap && (i.envMap = e(t.envMap)),
                undefined !== t.reflectivity && (i.reflectivity = t.reflectivity),
                undefined !== t.lightMap && (i.lightMap = e(t.lightMap)),
                undefined !== t.lightMapIntensity && (i.lightMapIntensity = t.lightMapIntensity),
                undefined !== t.aoMap && (i.aoMap = e(t.aoMap)),
                undefined !== t.aoMapIntensity && (i.aoMapIntensity = t.aoMapIntensity),
                undefined !== t.gradientMap && (i.gradientMap = e(t.gradientMap)),
                i
            }
        })
    },
    "6YUT": function(t, e, n) {
        "use strict";

        function i(t, e) {
            this.origin = undefined !== t ? t: new r.a,
            this.direction = undefined !== e ? e: new r.a
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Vector3");
        Object.assign(i.prototype, {
            set: function(t, e) {
                return this.origin.copy(t),
                this.direction.copy(e),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.origin.copy(t.origin),
                this.direction.copy(t.direction),
                this
            },
            at: function(t, e) {
                return (e || new r.a).copy(this.direction).multiplyScalar(t).add(this.origin)
            },
            lookAt: function(t) {
                return this.direction.copy(t).sub(this.origin).normalize(),
                this
            },
            recast: function() {
                var t = new r.a;
                return function(e) {
                    return this.origin.copy(this.at(e, t)),
                    this
                }
            } (),
            closestPointToPoint: function(t, e) {
                var n = e || new r.a;
                n.subVectors(t, this.origin);
                var i = n.dot(this.direction);
                return i < 0 ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(i).add(this.origin)
            },
            distanceToPoint: function(t) {
                return Math.sqrt(this.distanceSqToPoint(t))
            },
            distanceSqToPoint: function() {
                var t = new r.a;
                return function(e) {
                    var n = t.subVectors(e, this.origin).dot(this.direction);
                    return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e))
                }
            } (),
            distanceSqToSegment: function() {
                var t = new r.a,
                e = new r.a,
                n = new r.a;
                return function(i, r, a, o) {
                    t.copy(i).add(r).multiplyScalar(.5),
                    e.copy(r).sub(i).normalize(),
                    n.copy(this.origin).sub(t);
                    var s, u, c, h, l = .5 * i.distanceTo(r),
                    f = -this.direction.dot(e),
                    p = n.dot(this.direction),
                    d = -n.dot(e),
                    m = n.lengthSq(),
                    v = Math.abs(1 - f * f);
                    if (v > 0) if (s = f * d - p, u = f * p - d, h = l * v, s >= 0) if (u >= -h) if (u <= h) {
                        var g = 1 / v;
                        s *= g,
                        u *= g,
                        c = s * (s + f * u + 2 * p) + u * (f * s + u + 2 * d) + m
                    } else u = l,
                    s = Math.max(0, -(f * u + p)),
                    c = -s * s + u * (u + 2 * d) + m;
                    else u = -l,
                    s = Math.max(0, -(f * u + p)),
                    c = -s * s + u * (u + 2 * d) + m;
                    else u <= -h ? (s = Math.max(0, -( - f * l + p)), u = s > 0 ? -l: Math.min(Math.max( - l, -d), l), c = -s * s + u * (u + 2 * d) + m) : u <= h ? (s = 0, u = Math.min(Math.max( - l, -d), l), c = u * (u + 2 * d) + m) : (s = Math.max(0, -(f * l + p)), u = s > 0 ? l: Math.min(Math.max( - l, -d), l), c = -s * s + u * (u + 2 * d) + m);
                    else u = f > 0 ? -l: l,
                    s = Math.max(0, -(f * u + p)),
                    c = -s * s + u * (u + 2 * d) + m;
                    return a && a.copy(this.direction).multiplyScalar(s).add(this.origin),
                    o && o.copy(e).multiplyScalar(u).add(t),
                    c
                }
            } (),
            intersectSphere: function() {
                var t = new r.a;
                return function(e, n) {
                    t.subVectors(e.center, this.origin);
                    var i = t.dot(this.direction),
                    r = t.dot(t) - i * i,
                    a = e.radius * e.radius;
                    if (r > a) return null;
                    var o = Math.sqrt(a - r),
                    s = i - o,
                    u = i + o;
                    return s < 0 && u < 0 ? null: s < 0 ? this.at(u, n) : this.at(s, n)
                }
            } (),
            intersectsSphere: function(t) {
                return this.distanceToPoint(t.center) <= t.radius
            },
            distanceToPlane: function(t) {
                var e = t.normal.dot(this.direction);
                if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                var n = -(this.origin.dot(t.normal) + t.constant) / e;
                return n >= 0 ? n: null
            },
            intersectPlane: function(t, e) {
                var n = this.distanceToPlane(t);
                return null === n ? null: this.at(n, e)
            },
            intersectsPlane: function(t) {
                var e = t.distanceToPoint(this.origin);
                return 0 === e || t.normal.dot(this.direction) * e < 0
            },
            intersectBox: function(t, e) {
                var n, i, r, a, o, s, u = 1 / this.direction.x,
                c = 1 / this.direction.y,
                h = 1 / this.direction.z,
                l = this.origin;
                return u >= 0 ? (n = (t.min.x - l.x) * u, i = (t.max.x - l.x) * u) : (n = (t.max.x - l.x) * u, i = (t.min.x - l.x) * u),
                c >= 0 ? (r = (t.min.y - l.y) * c, a = (t.max.y - l.y) * c) : (r = (t.max.y - l.y) * c, a = (t.min.y - l.y) * c),
                n > a || r > i ? null: ((r > n || n !== n) && (n = r), (a < i || i !== i) && (i = a), h >= 0 ? (o = (t.min.z - l.z) * h, s = (t.max.z - l.z) * h) : (o = (t.max.z - l.z) * h, s = (t.min.z - l.z) * h), n > s || o > i ? null: ((o > n || n !== n) && (n = o), (s < i || i !== i) && (i = s), i < 0 ? null: this.at(n >= 0 ? n: i, e)))
            },
            intersectsBox: function() {
                var t = new r.a;
                return function(e) {
                    return null !== this.intersectBox(e, t)
                }
            } (),
            intersectsBoxInfo: function() {
                var t = new r.a;
                return function(e) {
                    return this.intersectBox(e, t)
                }
            } (),
            intersectTriangle: function() {
                var t = new r.a,
                e = new r.a,
                n = new r.a,
                i = new r.a;
                return function(r, a, o, s, u) {
                    e.subVectors(a, r),
                    n.subVectors(o, r),
                    i.crossVectors(e, n);
                    var c, h = this.direction.dot(i);
                    if (h > 0) {
                        if (s) return null;
                        c = 1
                    } else {
                        if (! (h < 0)) return null;
                        c = -1,
                        h = -h
                    }
                    t.subVectors(this.origin, r);
                    var l = c * this.direction.dot(n.crossVectors(t, n));
                    if (l < 0) return null;
                    var f = c * this.direction.dot(e.cross(t));
                    if (f < 0) return null;
                    if (l + f > h) return null;
                    var p = -c * t.dot(i);
                    return p < 0 ? null: this.at(p / h, u)
                }
            } (),
            applyMatrix4: function(t) {
                return this.origin.applyMatrix4(t),
                this.direction.transformDirection(t),
                this
            },
            equals: function(t) {
                return t.origin.equals(this.origin) && t.direction.equals(this.direction)
            }
        })
    },
    "6f23": function(t, e, n) {
        "use strict";

        function i(t) {
            this.camera = t,
            this.bias = 0,
            this.radius = 1,
            this.mapSize = new Vector2(512, 512),
            this.map = null,
            this.matrix = new Matrix4()

            function i() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
                arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Matrix4"),
        // a = n("Vector2");
        Object.assign(i.prototype, {
            copy: function(t) {
                return this.camera = t.camera.clone(),
                this.bias = t.bias,
                this.radius = t.radius,
                this.mapSize.copy(t.mapSize),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var t = {};
                return 0 !== this.bias && (t.bias = this.bias),
                1 !== this.radius && (t.radius = this.radius),
                512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()),
                t.camera = this.camera.toJSON(false).object,
                delete t.camera.matrix,
                t
            }
        })
    },
    "SpriteMaterial": function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.type = "SpriteMaterial",
            this.color = new a.a(16777215),
            this.map = null,
            this.rotation = 0,
            this.fog = false,
            this.lights = false,
            this.setValues(t)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Material"),
        a = n("Color");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isSpriteMaterial = true,
        i.prototype.copy = function(t) {
            return r.a.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.map = t.map,
            this.rotation = t.rotation,
            this
        }
    },
    "7Hn5": function(t, e, n) {
        "use strict";

        function i(t) {
            this.data = t
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("JJh5"),
        a = n("xcHZ");
        Object.assign(i.prototype, {
            isFont: true,
            generateShapes: function(t, e, n) {
                function i(t, e, i, s) {
                    var u = o.glyphs[t] || o.glyphs["?"];
                    if (u) {
                        var c, h, l, f, p, d, m, v, g, y, _, x = new a.a,
                        b = [];
                        if (u.o) for (var w = u._cachedOutline || (u._cachedOutline = u.o.split(" ")), M = 0, S = w.length; M < S;) {
                            var E = w[M++];
                            switch (E) {
                            case "m":
                                c = w[M++] * e + i,
                                h = w[M++] * e + s,
                                x.moveTo(c, h);
                                break;
                            case "l":
                                c = w[M++] * e + i,
                                h = w[M++] * e + s,
                                x.lineTo(c, h);
                                break;
                            case "q":
                                if (l = w[M++] * e + i, f = w[M++] * e + s, m = w[M++] * e + i, v = w[M++] * e + s, x.quadraticCurveTo(m, v, l, f), _ = b[b.length - 1]) {
                                    p = _.x,
                                    d = _.y;
                                    for (var T = 1; T <= n; T++) {
                                        var A = T / n;
                                        Object(r.c)(A, p, m, l),
                                        Object(r.c)(A, d, v, f)
                                    }
                                }
                                break;
                            case "b":
                                if (l = w[M++] * e + i, f = w[M++] * e + s, m = w[M++] * e + i, v = w[M++] * e + s, g = w[M++] * e + i, y = w[M++] * e + s, x.bezierCurveTo(m, v, g, y, l, f), _ = b[b.length - 1]) {
                                    p = _.x,
                                    d = _.y;
                                    for (var T = 1; T <= n; T++) {
                                        var A = T / n;
                                        Object(r.b)(A, p, m, g, l),
                                        Object(r.b)(A, d, v, y, f)
                                    }
                                }
                            }
                        }
                        return {
                            offsetX: u.ha * e,
                            path: x
                        }
                    }
                }
                undefined === e && (e = 100),
                undefined === n && (n = 4);
                for (var o = this.data,
                s = function(t) {
                    for (var n = String(t).split(""), r = e / o.resolution, a = (o.boundingBox.yMax - o.boundingBox.yMin + o.underlineThickness) * r, s = 0, u = 0, c = [], h = 0; h < n.length; h++) {
                        var l = n[h];
                        if ("\\n" === l) s = 0,
                        u -= a;
                        else {
                            var f = i(l, r, s, u);
                            s += f.offsetX,
                            c.push(f.path)
                        }
                    }
                    return c
                } (t), u = [], c = 0, h = s.length; c < h; c++) Array.prototype.push.apply(u, s[c].toShapes());
                return u
            }
        })
    },
    "7KmG": function(t, e, n) {
        "use strict";

        function i(t, e) {
            r.a.call(this, t, e),
            this.animationsMap = {},
            this.animationsList = [];
            var n = this.geometry.morphTargets.length,
            i = n - 1,
            a = n / 1;
            this.createAnimation("__default", 0, i, a),
            this.setAnimationWeight("__default", 1)
        }
        var r = n("Mesh"),
        a = n("_Math");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.createAnimation = function(t, e, n, i) {
            var r = {
                start: e,
                end: n,
                length: n - e + 1,
                fps: i,
                duration: (n - e) / i,
                lastFrame: 0,
                currentFrame: 0,
                active: false,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: false,
                mirroredLoop: false
            };
            this.animationsMap[t] = r,
            this.animationsList.push(r)
        },
        i.prototype.autoCreateAnimations = function(t) {
            for (var e, n = /([a-z]+)_?(\\d+)/i,
            i = {},
            r = this.geometry,
            a = 0,
            o = r.morphTargets.length; a < o; a++) {
                var s = r.morphTargets[a],
                u = s.name.match(n);
                if (u && u.length > 1) {
                    var c = u[1];
                    i[c] || (i[c] = {
                        start: 1 / 0,
                        end: -Infinity
                    });
                    var h = i[c];
                    a < h.start && (h.start = a),
                    a > h.end && (h.end = a),
                    e || (e = c)
                }
            }
            for (var c in i) {
                var h = i[c];
                this.createAnimation(c, h.start, h.end, t)
            }
            this.firstAnimation = e
        },
        i.prototype.setAnimationDirectionForward = function(t) {
            var e = this.animationsMap[t];
            e && (e.direction = 1, e.directionBackwards = false)
        },
        i.prototype.setAnimationDirectionBackward = function(t) {
            var e = this.animationsMap[t];
            e && (e.direction = -1, e.directionBackwards = true)
        },
        i.prototype.setAnimationFPS = function(t, e) {
            var n = this.animationsMap[t];
            n && (n.fps = e, n.duration = (n.end - n.start) / n.fps)
        },
        i.prototype.setAnimationDuration = function(t, e) {
            var n = this.animationsMap[t];
            n && (n.duration = e, n.fps = (n.end - n.start) / n.duration)
        },
        i.prototype.setAnimationWeight = function(t, e) {
            var n = this.animationsMap[t];
            n && (n.weight = e)
        },
        i.prototype.setAnimationTime = function(t, e) {
            var n = this.animationsMap[t];
            n && (n.time = e)
        },
        i.prototype.getAnimationTime = function(t) {
            var e = 0,
            n = this.animationsMap[t];
            return n && (e = n.time),
            e
        },
        i.prototype.getAnimationDuration = function(t) {
            var e = -1,
            n = this.animationsMap[t];
            return n && (e = n.duration),
            e
        },
        i.prototype.playAnimation = function(t) {
            var e = this.animationsMap[t];
            e ? (e.time = 0, e.active = true) : console.warn("THREE.MorphBlendMesh: animation[" + t + "] undefined in .playAnimation()")
        },
        i.prototype.stopAnimation = function(t) {
            var e = this.animationsMap[t];
            e && (e.active = false)
        },
        i.prototype.update = function(t) {
            for (var e = 0,
            n = this.animationsList.length; e < n; e++) {
                var i = this.animationsList[e];
                if (i.active) {
                    var r = i.duration / i.length;
                    i.time += i.direction * t,
                    i.mirroredLoop ? (i.time > i.duration || i.time < 0) && (i.direction *= -1, i.time > i.duration && (i.time = i.duration, i.directionBackwards = true), i.time < 0 && (i.time = 0, i.directionBackwards = false)) : (i.time = i.time % i.duration, i.time < 0 && (i.time += i.duration));
                    var o = i.start + a.a.clamp(Math.floor(i.time / r), 0, i.length - 1),
                    s = i.weight;
                    o !== i.currentFrame && (this.morphTargetInfluences[i.lastFrame] = 0, this.morphTargetInfluences[i.currentFrame] = 1 * s, this.morphTargetInfluences[o] = 0, i.lastFrame = i.currentFrame, i.currentFrame = o);
                    var u = i.time % r / r;
                    i.directionBackwards && (u = 1 - u),
                    i.currentFrame !== i.lastFrame ? (this.morphTargetInfluences[i.currentFrame] = u * s, this.morphTargetInfluences[i.lastFrame] = (1 - u) * s) : this.morphTargetInfluences[i.currentFrame] = s
                }
            }
        }
    },
    "_Math": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var t, e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                n = new Array(36),
                i = 0;
                return function() {
                    for (var r = 0; r < 36; r++) 8 === r || 13 === r || 18 === r || 23 === r ? n[r] = "-": 14 === r ? n[r] = "4": (i <= 2 && (i = 33554432 + 16777216 * Math.random() | 0), t = 15 & i, i >>= 4, n[r] = e[19 === r ? 3 & t | 8 : t]);
                    return n.join("")
                }
            } (),
            clamp: function(t, e, n) {
                return Math.max(e, Math.min(n, t))
            },
            euclideanModulo: function(t, e) {
                return (t % e + e) % e
            },
            mapLinear: function(t, e, n, i, r) {
                return i + (t - e) * (r - i) / (n - e)
            },
            lerp: function(t, e, n) {
                return (1 - n) * t + n * e
            },
            smoothstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
            },
            smootherstep: function(t, e, n) {
                return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
            },
            randInt: function(t, e) {
                return t + Math.floor(Math.random() * (e - t + 1))
            },
            randFloat: function(t, e) {
                return t + Math.random() * (e - t)
            },
            randFloatSpread: function(t) {
                return t * (.5 - Math.random())
            },
            degToRad: function(t) {
                return t * i.DEG2RAD
            },
            radToDeg: function(t) {
                return t * i.RAD2DEG
            },
            isPowerOfTwo: function(t) {
                return 0 == (t & t - 1) && 0 !== t
            },
            nearestPowerOfTwo: function(t) {
                return Math.pow(2, Math.round(Math.log(t) / Math.LN2))
            },
            nextPowerOfTwo: function(t) {
                return t--,
                t |= t >> 1,
                t |= t >> 2,
                t |= t >> 4,
                t |= t >> 8,
                t |= t >> 16,
                ++t
            }
        }
    },
    "Light": function(t, e, n) {
        "use strict";

        function i(t, e) {
            r.a.call(this),
            this.type = "Light",
            this.color = new a.a(t),
            this.intensity = undefined !== e ? e: 1,
            this.receiveShadow = undefined
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Object3D"),
        a = n("Color");
        i.prototype = Object.assign(Object.create(r.a.prototype), {
            constructor: i,
            isLight: true,
            copy: function(t) {
                return r.a.prototype.copy.call(this, t),
                this.color.copy(t.color),
                this.intensity = t.intensity,
                this
            },
            toJSON: function(t) {
                var e = r.a.prototype.toJSON.call(this, t);
                return e.object.color = this.color.getHex(),
                e.object.intensity = this.intensity,
                undefined !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
                undefined !== this.distance && (e.object.distance = this.distance),
                undefined !== this.angle && (e.object.angle = this.angle),
                undefined !== this.decay && (e.object.decay = this.decay),
                undefined !== this.penumbra && (e.object.penumbra = this.penumbra),
                undefined !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
                e
            }
        })
    },
    "7tNX": function(t, e, n) {
        "use strict";

        function i(t, e) {
            function n() {
                var t = new Float32Array([ - .5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                u = d.createBuffer(),
                c = d.createBuffer(),
                d.bindBuffer(d.ARRAY_BUFFER, u),
                d.bufferData(d.ARRAY_BUFFER, t, d.STATIC_DRAW),
                d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c),
                d.bufferData(d.ELEMENT_ARRAY_BUFFER, e, d.STATIC_DRAW),
                h = i(),
                l = {
                    position: d.getAttribLocation(h, "position"),
                    uv: d.getAttribLocation(h, "uv")
                },
                f = {
                    uvOffset: d.getUniformLocation(h, "uvOffset"),
                    uvScale: d.getUniformLocation(h, "uvScale"),
                    rotation: d.getUniformLocation(h, "rotation"),
                    scale: d.getUniformLocation(h, "scale"),
                    color: d.getUniformLocation(h, "color"),
                    map: d.getUniformLocation(h, "map"),
                    opacity: d.getUniformLocation(h, "opacity"),
                    modelViewMatrix: d.getUniformLocation(h, "modelViewMatrix"),
                    projectionMatrix: d.getUniformLocation(h, "projectionMatrix"),
                    fogType: d.getUniformLocation(h, "fogType"),
                    fogDensity: d.getUniformLocation(h, "fogDensity"),
                    fogNear: d.getUniformLocation(h, "fogNear"),
                    fogFar: d.getUniformLocation(h, "fogFar"),
                    fogColor: d.getUniformLocation(h, "fogColor"),
                    alphaTest: d.getUniformLocation(h, "alphaTest")
                };
                var n = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                n.width = 8,
                n.height = 8;
                var a = n.getContext("2d");
                a.fillStyle = "white",
                a.fillRect(0, 0, 8, 8),
                p = new r.a(n),
                p.needsUpdate = true
            }

            function i() {
                var e = d.createProgram(),
                n = d.createShader(d.VERTEX_SHADER),
                i = d.createShader(d.FRAGMENT_SHADER);
                return d.shaderSource(n, ["precision " + t.getPrecision() + " float;", "#define SHADER_NAME SpriteMaterial", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\\n")),
                d.shaderSource(i, ["precision " + t.getPrecision() + " float;", "#define SHADER_NAME SpriteMaterial", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\\n")),
                d.compileShader(n),
                d.compileShader(i),
                d.attachShader(e, n),
                d.attachShader(e, i),
                d.linkProgram(e),
                e
            }

            function s(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder: t.z !== e.z ? e.z - t.z: e.id - t.id
            }

            // _gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

            var u, c, h, l, f, p, d = t.context,
            m = t.state,
            v = new Vector3(),
            g = new Quaternion(),
            y = new Vector3();
            this.render = function(i, r) {
                if (0 !== e.length) {
                    undefined === h && n(),
                    d.useProgram(h),
                    m.initAttributes(),
                    m.enableAttribute(l.position),
                    m.enableAttribute(l.uv),
                    m.disableUnusedAttributes(),
                    m.disable(d.CULL_FACE),
                    m.enable(d.BLEND),
                    d.bindBuffer(d.ARRAY_BUFFER, u),
                    d.vertexAttribPointer(l.position, 2, d.FLOAT, false, 16, 0),
                    d.vertexAttribPointer(l.uv, 2, d.FLOAT, false, 16, 8),
                    d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, c),
                    d.uniformMatrix4fv(f.projectionMatrix, false, r.projectionMatrix.elements),
                    m.activeTexture(d.TEXTURE0),
                    d.uniform1i(f.map, 0);
                    var a = 0,
                    o = 0,
                    _ = i.fog;
                    _ ? (d.uniform3f(f.fogColor, _.color.r, _.color.g, _.color.b), _.isFog ? 
                        (d.uniform1f(f.fogNear, _.near), d.uniform1f(f.fogFar, _.far), 
                            d.uniform1i(f.fogType, 1), a = 1, o = 1) : _.isFogExp2 && 
                        (d.uniform1f(f.fogDensity, _.density), d.uniform1i(f.fogType, 2), a = 2, o = 2)) : 
                    (d.uniform1i(f.fogType, 0), a = 0, o = 0);
                    for (var x = 0,
                    b = e.length; x < b; x++) {
                        var w = e[x];
                        w.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, w.matrixWorld),
                        w.z = -w.modelViewMatrix.elements[14]
                    }
                    e.sort(s);
                    for (var M = [], x = 0, b = e.length; x < b; x++) {
                        var w = e[x],
                        S = w.material;
                        if (false !== S.visible) {
                            w.onBeforeRender(t, i, r, undefined, S, undefined),
                            d.uniform1f(f.alphaTest, S.alphaTest),
                            d.uniformMatrix4fv(f.modelViewMatrix, false, w.modelViewMatrix.elements),
                            w.matrixWorld.decompose(new Vector3(), new Quaternion(), new Vector3()),
                            M[0] = y.x,
                            M[1] = y.y;
                            var E = 0;
                            i.fog && S.fog && (E = o),
                            a !== E && (d.uniform1i(f.fogType, E), a = E),
                            null !== S.map ? (d.uniform2f(f.uvOffset, S.map.offset.x, S.map.offset.y), 
                                d.uniform2f(f.uvScale, S.map.repeat.x, S.map.repeat.y)) : (d.uniform2f(f.uvOffset, 0, 0), d.uniform2f(f.uvScale, 1, 1)),
                            d.uniform1f(f.opacity, S.opacity),
                            d.uniform3f(f.color, S.color.r, S.color.g, S.color.b),
                            d.uniform1f(f.rotation, S.rotation),
                            d.uniform2fv(f.scale, M),
                            m.setBlending(S.blending, S.blendEquation, S.blendSrc, 
                                S.blendDst, S.blendEquationAlpha, S.blendSrcAlpha, 
                                S.blendDstAlpha, S.premultipliedAlpha),
                            m.buffers.depth.setTest(S.depthTest),
                            m.buffers.depth.setMask(S.depthWrite),
                            S.map ? t.setTexture2D(S.map, 0) : t.setTexture2D(p, 0),
                            d.drawElements(d.TRIANGLES, 6, d.UNSIGNED_SHORT, 0),
                            w.onAfterRender(t, i, r, undefined, S, undefined)
                        }
                    }
                    m.enable(d.CULL_FACE),
                    t.resetGLState()
                }
            }
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("vh+C"),
        a = n("Vector3"),
        o = n("Quaternion")
    },
    "7wWY": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif"
    },
    "85Qu": function(t, e, n) {
        "use strict";

        function i(t) {
            return new r.E({
                defines: Object.assign({},
                t.defines),
                uniforms: r.G.clone(t.uniforms),
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            })
        }
        e.a = i;
        var r = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.)
    },
    "86kX": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_COLOR\\n\\tvarying vec3 vColor;\\n#endif\\n"
    },
    "Object3D": function(t, e, n) {
        "use strict";

        function i() {
            function t() {
                y.setFromEuler(c, false),
                this.setMatrixDirty()
            }

            function e() {
                c.setFromQuaternion(y, undefined, false),
                this.setMatrixDirty()
            }

            function n() {
                x.compose(a, y, _)
            }
            Object.defineProperty(this, "id", {
                value: g++
            }),
            this.uuid = p.a.generateUUID(),
            this.name = "",
            this.type = "Object3D",
            this.parent = null,
            this.children = [],
            this.up = i.DefaultUp.clone();
            var a = new o.a(0, 0, 0, this),
            c = new h.a,
            y = new r.a,
            _ = new o.a(1, 1, 1, this),
            x = new u.a(this),
            b = true,
            w = new d.a(this);
            c.onChange(t.bind(this)),
            y.onChange(e.bind(this)),
            Object.defineProperties(this, {
                attribute: {
                    get: function() {
                        return w
                    }
                },
                position: {
                    enumerable: true,
                    get: function() {
                        return a
                    },
                    set: function(t) {
                        a = new o.a(t.x, t.y, t.z, this),
                        this.setMatrixDirty()
                    }
                },
                rotation: {
                    enumerable: true,
                    value: c
                },
                quaternion: {
                    enumerable: true,
                    value: y
                },
                scale: {
                    enumerable: true,
                    get: function() {
                        return _
                    },
                    set: function(t) {
                        _ = new o.a(t.x, t.y, t.z, this),
                        this.setMatrixDirty()
                    }
                },
                matrix: {
                    enumerable: true,
                    get: function() {
                        return this.dirtyFlags & v.MATRIX_DIRTY && (n(), this.dirtyFlags &= ~v.MATRIX_DIRTY),
                        x
                    },
                    set: function(t) {
                        x.copy(t),
                        this.setMatrixUpdated()
                    }
                },
                matrixWorldNeedsUpdate: {
                    enumerable: true,
                    get: function() {
                        return !! (this.dirtyFlags & v.WORLD_MATRIX_DIRTY)
                    },
                    set: function(t) {
                        1 == t ? this.setMatrixDirty() : this.dirtyFlags &= ~v.WORLD_MATRIX_DIRTY
                    }
                },
                modelViewMatrix: {
                    value: new s.a
                },
                normalMatrix: {
                    value: new f.a
                },
                visible: {
                    get: function() {
                        return b
                    },
                    set: function(t) {
                        t != b && (b = t, this.onChange(m.VISIBILITY_CHANGED))
                    }
                }
            }),
            this.matrixWorld = new s.a,
            this.matrixAutoUpdate = i.DefaultMatrixAutoUpdate,
            this.dirtyFlags = v.WORLD_MATRIX_DIRTY,
            this.layers = new l.a,
            this.castShadow = false,
            this.receiveShadow = false,
            this.frustumCulled = true,
            this.renderOrder = 0,
            this.userData = {}
        }
        n.d(e, "a",
        function() {
            return i
        }),
        n.d(e, "b",
        function() {
            return m
        });
        var r = n("Quaternion"),
        a = n("Vector3"),
        o = n("4eq2"),
        s = n("Matrix4"),
        u = n("j125"),
        c = n("EventDispatcher"),
        h = n("Euler"),
        l = n("vaUk"),
        f = n("Matrix3"),
        p = n("_Math"),
        d = n("+8dW"),
        m = {
            NOCHANGE: 0,
            MATRIX_CHANGED: 1,
            CHILDREN_CHANGED: 2,
            GEOMETRY_CHANGED: 4,
            MATERIAL_CHANGED: 8,
            VISIBILITY_CHANGED: 16,
            ATTRIBUTE_CHANGED: 32
        },
        v = {
            NODIRTY: 0,
            MATRIX_DIRTY: 1,
            WORLD_MATRIX_DIRTY: 2
        },
        g = 0;
        i.DefaultUp = new a.a(0, 1, 0),
        i.DefaultMatrixAutoUpdate = true,
        Object.assign(i.prototype, c.a.prototype, {
            isObject3D: true,
            onBeforeRender: function() {},
            onAfterRender: function() {},
            applyMatrix: function(t) {
                this.matrix.multiplyMatrices(t, this.matrix),
                this.matrix.decompose(this.position, this.quaternion, this.scale),
                this.setMatrixUpdated()
            },
            onChange: function(t) {
                this.dispatchEvent({
                    type: "changed",
                    attachment: t
                })
            },
            setMatrixDirty: function() {
                this.dirtyFlags |= v.MATRIX_DIRTY,
                this.dirtyFlags |= v.WORLD_MATRIX_DIRTY,
                this.onChange(m.MATRIX_CHANGED)
            },
            setGeometryChanged: function() {
                this.dirtyFlags |= v.GEOMETRY_CHANGED,
                this.onChange(m.GEOMETRY_CHANGED)
            },
            setMaterialChanged: function() {
                this.dirtyFlags |= v.MATERIAL_CHANGED,
                this.onChange(m.MATERIAL_CHANGED)
            },
            setMatrixUpdated: function() {
                this.dirtyFlags &= ~v.MATRIX_DIRTY,
                this.dirtyFlags |= v.WORLD_MATRIX_DIRTY,
                this.onChange(m.MATRIX_CHANGED)
            },
            applyQuaternion: function(t) {
                return this.quaternion.premultiply(t),
                this
            },
            setRotationFromAxisAngle: function(t, e) {
                this.quaternion.setFromAxisAngle(t, e)
            },
            setRotationFromEuler: function(t) {
                this.quaternion.setFromEuler(t, true)
            },
            setRotationFromMatrix: function(t) {
                this.quaternion.setFromRotationMatrix(t)
            },
            setRotationFromQuaternion: function(t) {
                this.quaternion.copy(t)
            },
            rotateOnAxis: function() {
                var t = new r.a;
                return function(e, n) {
                    return t.setFromAxisAngle(e, n),
                    this.quaternion.multiply(t),
                    this
                }
            } (),
            rotateX: function() {
                var t = new a.a(1, 0, 0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            } (),
            rotateY: function() {
                var t = new a.a(0, 1, 0);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            } (),
            rotateZ: function() {
                var t = new a.a(0, 0, 1);
                return function(e) {
                    return this.rotateOnAxis(t, e)
                }
            } (),
            translateOnAxis: function() {
                var t = new a.a;
                return function(e, n) {
                    return t.copy(e).applyQuaternion(this.quaternion),
                    this.position.add(t.multiplyScalar(n)),
                    this
                }
            } (),
            translateX: function() {
                var t = new a.a(1, 0, 0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            } (),
            translateY: function() {
                var t = new a.a(0, 1, 0);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            } (),
            translateZ: function() {
                var t = new a.a(0, 0, 1);
                return function(e) {
                    return this.translateOnAxis(t, e)
                }
            } (),
            localToWorld: function(t) {
                return t.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function() {
                var t = new s.a;
                return function(e) {
                    return e.applyMatrix4(t.getInverse(this.matrixWorld))
                }
            } (),
            lookAt: function() {
                var t = new s.a;
                return function(e) {
                    this.isCamera ? t.lookAt(this.position, e, this.up) : t.lookAt(e, this.position, this.up),
                    this.quaternion.setFromRotationMatrix(t)
                }
            } (),
            add: function(t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.onChange(m.ATTRIBUTE_CHANGED), t.attribute.markAllDirty(), null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({
                    type: "added"
                }), null !== t.parent && t.parent.onChange(m.CHILDREN_CHANGED), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
            },
            remove: function(t) {
                if (arguments.length > 1) {
                    for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                var n = this.children.indexOf(t);
                if ( - 1 !== n) {
                    var i = t.parent;
                    t.parent = null,
                    this.children.splice(n, 1),
                    t.dispatchEvent({
                        type: "removed"
                    }),
                    null !== i && i.onChange(m.CHILDREN_CHANGED)
                }
                return this
            },
            setAttribute: function(t, e) {
                this.attribute.setValue(t, e),
                this.onChange(m.ATTRIBUTE_CHANGED)
            },
            getAttribute: function(t) {
                return this.attribute.getValue(t)
            },
            getNetAttribute: function(t, e) {
                return undefined === e ? this.attribute.getNetValue(t, false) : this.attribute.getNetValue(t, e)
            },
            getObjectById: function(t) {
                return this.getObjectByProperty("id", t)
            },
            getObjectByName: function(t) {
                return this.getObjectByProperty("name", t)
            },
            getObjectByProperty: function(t, e) {
                if (this[t] === e) return this;
                for (var n = 0,
                i = this.children.length; n < i; n++) {
                    var r = this.children[n],
                    a = r.getObjectByProperty(t, e);
                    if (undefined !== a) return a
                }
            },
            getWorldPosition: function(t) {
                var e = t || new a.a;
                return this.updateMatrixWorld(true),
                e.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function() {
                var t = new a.a,
                e = new a.a;
                return function(n) {
                    var i = n || new r.a;
                    return this.updateMatrixWorld(true),
                    this.matrixWorld.decompose(t, i, e),
                    i
                }
            } (),
            getWorldRotation: function() {
                var t = new r.a;
                return function(e) {
                    var n = e || new h.a;
                    return this.getWorldQuaternion(t),
                    n.setFromQuaternion(t, this.rotation.order, false)
                }
            } (),
            getWorldScale: function() {
                var t = new a.a,
                e = new r.a;
                return function(n) {
                    var i = n || new a.a;
                    return this.updateMatrixWorld(true),
                    this.matrixWorld.decompose(t, e, i),
                    i
                }
            } (),
            getWorldDirection: function() {
                var t = new r.a;
                return function(e) {
                    var n = e || new a.a;
                    return this.getWorldQuaternion(t),
                    n.set(0, 0, 1).applyQuaternion(t)
                }
            } (),
            raycast: function() {},
            egsRaycast: function() {},
            traverse: function(t) {
                t(this);
                for (var e = this.children,
                n = 0,
                i = e.length; n < i; n++) e[n].traverse(t)
            },
            traverseVisible: function(t) {
                if (false !== this.visible) {
                    t(this);
                    for (var e = this.children,
                    n = 0,
                    i = e.length; n < i; n++) e[n].traverseVisible(t)
                }
            },
            traverseAncestors: function(t) {
                var e = this.parent;
                null !== e && (t(e), e.traverseAncestors(t))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale),
                this.dirtyFlags &= ~v.MATRIX_DIRTY
            },
            updateMatrixWorld: function(t) { (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t = true);
                for (var e = this.children,
                n = 0,
                i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
            },
            toJSONOriginal: function(t) {
                function e(e, n) {
                    return undefined === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                    n.uuid
                }

                function n(t) {
                    var e = [];
                    for (var n in t) {
                        var i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                var i = undefined === t || "" === t,
                r = {};
                i && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                },
                r.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var a = {};
                if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), "{}" !== JSON.stringify(this.attributes) && (a.attributes = this.attributes), true === this.castShadow && (a.castShadow = true), true === this.receiveShadow && (a.receiveShadow = true), false === this.visible && (a.visible = false), a.matrix = this.matrix.toArray(), undefined !== this.geometry && (a.geometry = e(t.geometries, this.geometry)), undefined !== this.material) if (Array.isArray(this.material)) {
                    for (var o = [], s = 0, u = this.material.length; s < u; s++) o.push(e(t.materials, this.material[s]));
                    a.material = o
                } else a.material = e(t.materials, this.material);
                if (this.children.length > 0) {
                    a.children = [];
                    for (var s = 0; s < this.children.length; s++) a.children.push(this.children[s].toJSON(t).object)
                }
                if (i) {
                    var c = n(t.geometries),
                    h = n(t.materials),
                    l = n(t.textures),
                    f = n(t.images);
                    c.length > 0 && (r.geometries = c),
                    h.length > 0 && (r.materials = h),
                    l.length > 0 && (r.textures = l),
                    f.length > 0 && (r.images = f)
                }
                return r.object = a,
                r
            },
            toJSON: function(t) {
                function e(e, n) {
                    return undefined === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                    n.uuid
                }

                function n(t) {
                    var e = [];
                    for (var n in t) {
                        var i = t[n];
                        delete i.metadata,
                        e.push(i)
                    }
                    return e
                }
                var i = undefined === t || "string" == typeof t,
                r = {};
                i && (t = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {}
                },
                r.metadata = {
                    version: 4.5,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var a = {};
                if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), true === this.castShadow && (a.castShadow = true), true === this.receiveShadow && (a.receiveShadow = true), false === this.visible && (a.visible = false), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.matrix = this.matrix.toArray(), undefined !== this.geometry) {
                    a.geometry = e(t.geometries, this.geometry);
                    var o = this.geometry.parameters;
                    if (undefined !== o && undefined !== o.shapes) {
                        var s = o.shapes;
                        if (Array.isArray(s)) for (var u = 0,
                        c = s.length; u < c; u++) {
                            var h = s[u];
                            e(t.shapes, h)
                        } else e(t.shapes, s)
                    }
                }
                if (undefined !== this.material) if (Array.isArray(this.material)) {
                    for (var l = [], u = 0, c = this.material.length; u < c; u++) l.push(e(t.materials, this.material[u]));
                    a.material = l
                } else a.material = e(t.materials, this.material);
                if (this.children.length > 0) {
                    a.children = [];
                    for (var u = 0; u < this.children.length; u++) a.children.push(this.children[u].toJSON(t).object)
                }
                if (i) {
                    var f = n(t.geometries),
                    p = n(t.materials),
                    d = n(t.textures),
                    m = n(t.images),
                    s = n(t.shapes),
                    v = n(t.models),
                    g = n(t.popMaterial);
                    f.length > 0 && (r.geometries = f),
                    p.length > 0 && (r.materials = p),
                    d.length > 0 && (r.textures = d),
                    m.length > 0 && (r.images = m),
                    s.length > 0 && (r.shapes = s),
                    v.length > 0 && (r.models = v),
                    g.length > 0 && (r.popMaterial = g)
                }
                return r.object = a,
                r
            },
            clone: function(t) {
                return (new this.constructor).copy(this, t)
            },
            copy: function(t, e) {
                if (undefined === e && (e = true), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.dirtyFlags = t.dirtyFlags, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), true === e) for (var n = 0; n < t.children.length; n++) {
                    var i = t.children[n];
                    this.add(i.clone())
                }
                return this
            }
        })
    },
    "8CDu": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i = n("CustomerDefine4"),
        r = function() {
            function t() {
                this.lights = new i.a(50)
            }
            return t.prototype.dispose = function() {
                this.lights.forEach(function(t) {
                    t._egsLightId = undefined
                })
            },
            t.prototype.reset = function() {
                this.lights.reset()
            },
            t.prototype.addLight = function(t) {
                var e = this.lights.addItemNoduplicate(t);
                return - 1 !== e && (t._egsLightId = e),
                t._egsLightId
            },
            t.prototype.removeLight = function(t) {
                this.lights.removeItem(t, t._egsLightId),
                t._egsLightId = undefined
            },
            t
        } ()
    },
    "8NN1": function(t, e, n) {
        "use strict";
        n("Matrix4"),
        n("Mesh"),
        n("Group")
    },
    "8PuR": function(t, e, n) {
        "use strict";
        e.a = "uniform samplerCube tCube;\\nuniform float tFlip;\\nuniform float opacity;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\\tgl_FragColor.a *= opacity;\\n}\\n"
    },
    "8Zdr": function(t, e, n) {
        "use strict";

        function i() {
            a.a.apply(this, arguments),
            this.holes = []
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("HDm3"),
        a = n("/wr7");
        i.prototype = Object.assign(Object.create(r.a), {
            constructor: i,
            getPointsHoles: function(t) {
                for (var e = [], n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                return e
            },
            extractAllPoints: function(t) {
                return {
                    shape: this.getPoints(t),
                    holes: this.getPointsHoles(t)
                }
            },
            extractPoints: function(t) {
                return this.extractAllPoints(t)
            }
        })
    },
    "8tXX": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return s
        });
        var i = n("M4fF"),
        r = (n.n(i), n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.)),
        a = n("PO9Y"),
        o = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        s = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.changing = false,
                e.onChange = Object(i.debounce)(function() {
                    e.changing ? (e.dispatchEvent({
                        type: "change-end"
                    }), e.changing = false) : (e.dispatchEvent({
                        type: "change-start"
                    }), e.changing = true)
                },
                500, {
                    leading: true,
                    trailing: true
                }),
                e
            }
            return o(e, t),
            e.prototype.setCamera = function(t) {
                this.camera && this.unwatch(this.camera),
                this.camera = t,
                this.watch(t),
                this.onChange.cancel(),
                this.changing = false
            },
            e.prototype.watch = function(t) {
                var e = this;
                a.a.isArrayCamera(t) ? t.cameras.forEach(function(t) {
                    return e.watch(t)
                }) : t.addEventListener("changed", this.onChange.bind(this))
            },
            e.prototype.unwatch = function(t) {
                var e = this;
                a.a.isArrayCamera(t) ? t.cameras.forEach(function(t) {
                    return e.unwatch(t)
                }) : t.removeEventListener("changed", this.onChange)
            },
            e.prototype.dispose = function() {
                this.camera && (this.unwatch(this.camera), this.camera = undefined),
                this.onChange.cancel(),
                this.changing = false
            },
            e
        } (r.m)
    },
    "9/ke": function(t, e, n) {
        "use strict";

        function i(t) {
            this.manager = undefined !== t ? t: o.a
        }
        var r = n("7Hn5"),
        a = n("w2Sq"),
        o = n("OJZr");
        Object.assign(i.prototype, {
            load: function(t, e, n, i) {
                var r = this;
                new a.a(this.manager).load(t,
                function(t) {
                    var n;
                    try {
                        n = JSON.parse(t)
                    } catch(e) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                        n = JSON.parse(t.substring(65, t.length - 2))
                    }
                    var i = r.parse(n);
                    e && e(i)
                },
                n, i)
            },
            parse: function(t) {
                return new r.a(t)
            }
        })
    },
    "9DcM": function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            if (undefined === t) throw new Error("track name is undefined");
            if (undefined === e || 0 === e.length) throw new Error("no keyframes in track named " + t);
            this.name = t,
            this.times = r.a.convertArray(e, this.TimeBufferType),
            this.values = r.a.convertArray(n, this.ValueBufferType),
            this.setInterpolation(i || this.DefaultInterpolation),
            this.validate(),
            this.optimize()
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("4W4M")
    },
    "9F77": function(t, e, n) {
        "use strict";
        e.a = "varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tvec3\\tspecularColor;\\n\\tfloat\\tspecularShininess;\\n\\tfloat\\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifdef TOON\\n\\t\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\\t#else\\n\\t\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\t\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#endif\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\\t(0)\\n"
    },
    "9Lg+": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_EMISSIVEMAP\\n\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n"
    },
    "9XRc": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i = function() {
            function t(t, e) {
                this.width = t,
                this.height = e
            }
            return t
        } ()
    },
    "9ZQ+": function(t, e, n) {
        "use strict";
        e.a = "uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_particle_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphatest_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n"
    },
    "9aRV": function(t, e, n) {
        "use strict";
        e.a = "#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#ifdef USE_UV_MATRIX\\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n\\tuniform mat3 uvMatrix;\\n#endif\\n#else\\n#include <uv_pars_vertex>\\n#endif\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nuniform vec3 vertexConstant;\\nuniform vec2 vertexParameters;\\nvec3 transformPosition(in vec3 maxLevelPosition) {\\n    float vertexGridSize = vertexParameters.x;\\n    float powPrecision = vertexParameters.y;\\n    vec3 gridPosition = (maxLevelPosition - vertexConstant) / vertexGridSize;\\n    return floor(gridPosition / powPrecision) * powPrecision * vertexGridSize + vertexConstant;\\n}\\nvoid main() {\\n    vec3 position = transformPosition(position);\\n#ifdef USE_UV_MATRIX\\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n    vUv = ( uvMatrix * vec3( uv, 1 ) ).xy;\\n#endif\\n#else\\n    #include <uv_vertex>\\n#endif\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\\tvNormal = normalize( transformedNormal );\\n#endif\\n\\t#include <begin_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvViewPosition = - mvPosition.xyz;\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n"
    },
    "9pX5": function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            function i() {
                if (undefined !== a) return a;
                var n = e.get("EXT_texture_filter_anisotropic");
                return a = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            }

            function r(e) {
                if ("highp" === e) {
                    if (t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision > 0) return "highp";
                    e = "mediump"
                }
                return "mediump" === e && t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision > 0 && t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision > 0 ? "mediump": "lowp"
            }
            var a, o = undefined !== n.precision ? n.precision: "highp",
            s = r(o);
            s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
            var u = true === n.logarithmicDepthBuffer && !!e.get("EXT_frag_depth"),
            c = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
            h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
            l = t.getParameter(t.MAX_TEXTURE_SIZE),
            f = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
            p = t.getParameter(t.MAX_VERTEX_ATTRIBS),
            d = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
            m = t.getParameter(t.MAX_VARYING_VECTORS),
            v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
            g = h > 0,
            y = !!e.get("OES_texture_float");
            return {
                getMaxAnisotropy: i,
                getMaxPrecision: r,
                precision: o,
                logarithmicDepthBuffer: u,
                maxTextures: c,
                maxVertexTextures: h,
                maxTextureSize: l,
                maxCubemapSize: f,
                maxAttributes: p,
                maxVertexUniforms: d,
                maxVaryings: m,
                maxFragmentUniforms: v,
                vertexTextures: g,
                floatFragmentTextures: y,
                floatVertexTextures: g && y
            }
        }
        n.d(e, "a",
        function() {
            return i
        })
    },
    "9qOK": function(t, e, n) {
        "use strict";

        function i(t, e) {
            for (var n = null; o.length > 0;) {
                n = o.pop(),
                t(n);
                for (var i = 0,
                r = n.children.length; i < r; i++) {
                    var a = n.children[i];
                    null != e && false !== e(a) || o.push(a)
                }
            }
        }

        function r(t, e, n) {
            undefined !== t && (null != n && false !== n(t) || (o.push(t), i(e, n)), o.length = 0)
        }
        e.a = r;
        var a = n("I/Ex"),
        o = new a.a(1e4)
    },
    "9uYx": function(t, e, n) {
        "use strict";
        var i = (n("WireframeGeometry"), n("ParametricGeometry||ParametricBufferGeometry"), n("TetrahedronGeometry||TetrahedronBufferGeometry"),
         n("OctahedronGeometry||OctahedronBufferGeometry"), 
            n("IcosahedronGeometry||IcosahedronBufferGeometry"), n("DodecahedronGeometry||DodecahedronBufferGeometry"), n("PolyhedronGeometry||PolyhedronBufferGeometry"), n("TubeGeometry||TubeBufferGeometry"), n("TorusKnotGeometry||TorusKnotBufferGeometry"), n("TorusGeometry||TorusBufferGeometry"), 
            n("TextGeometry||TextBufferGeometry"), n("SphereGeometry||SphereBufferGeometry"), n("RingGeometry||RingBufferGeometry"), n("PlaneGeometry||PlaneBufferGeometry"));
        n.d(e, "a",
        function() {
            return PlaneBufferGeometry
        });
        n("LatheGeometry"),
        n("ShapeGeometry||ShapeBufferGeometry"),
        n("ExtrudeGeometry"),
        n("EdgesGeometry"),
        n("ConeGeometry||ConeBufferGeometry"),
        n("CylinderGeometry||CylinderBufferGeometry"),
        n("XIMZ"),
        n("BoxGeometry||BoxBufferGeometry")
    },
    "A/ey": function(t, e, n) {
        "use strict";
        e.a = "varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n"
    },
    A9tL: function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_MORPHTARGETS\\n\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\t#ifndef USE_MORPHNORMALS\\n\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\t#endif\\n#endif\\n"
    },
    SphereGeometry||SphereBufferGeometry: function(t, e, n) {
        "use strict";

        function i(t, e, n, i, o, s, u) {
            a.a.call(this),
            this.type = "SphereGeometry",
            this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: o,
                thetaStart: s,
                thetaLength: u
            },
            this.fromBufferGeometry(new r(t, e, n, i, o, s, u)),
            this.mergeVertices()
        }

        function r(t, e, n, i, r, a, c) {
            o.a.call(this),
            this.type = "SphereBufferGeometry",
            this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: a,
                thetaLength: c
            },
            t = t || 50,
            e = Math.max(3, Math.floor(e) || 8),
            n = Math.max(2, Math.floor(n) || 6),
            i = undefined !== i ? i: 0,
            r = undefined !== r ? r: 2 * Math.PI,
            a = undefined !== a ? a: 0,
            c = undefined !== c ? c: Math.PI;
            var h, l, f = a + c,
            p = 0,
            d = [],
            m = new u.a,
            v = new u.a,
            g = [],
            y = [],
            _ = [],
            x = [];
            for (l = 0; l <= n; l++) {
                var b = [],
                w = l / n;
                for (h = 0; h <= e; h++) {
                    var M = h / e;
                    m.x = -t * Math.cos(i + M * r) * Math.sin(a + w * c),
                    m.y = t * Math.cos(a + w * c),
                    m.z = t * Math.sin(i + M * r) * Math.sin(a + w * c),
                    y.push(m.x, m.y, m.z),
                    v.set(m.x, m.y, m.z).normalize(),
                    _.push(v.x, v.y, v.z),
                    x.push(M, 1 - w),
                    b.push(p++)
                }
                d.push(b)
            }
            for (l = 0; l < n; l++) for (h = 0; h < e; h++) {
                var S = d[l][h + 1],
                E = d[l][h],
                T = d[l + 1][h],
                A = d[l + 1][h + 1]; (0 !== l || a > 0) && g.push(S, E, A),
                (l !== n - 1 || f < Math.PI) && g.push(E, T, A)
            }
            this.setIndex(g),
            this.addAttribute("position", new s.b(y, 3)),
            this.addAttribute("normal", new s.b(_, 3)),
            this.addAttribute("uv", new s.b(x, 2))
        }
        n.d(e, "a",
        function() {
            return r
        });
        var a = n("Geometry"),
        o = n("BufferGeometry"),
        s = n("BufferAttribute"),
        u = n("Vector3");
        i.prototype = Object.create(a.a.prototype),
        i.prototype.constructor = i,
        r.prototype = Object.create(o.a.prototype),
        r.prototype.constructor = r
    },
    ParametricGeometry||ParametricBufferGeometry: function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            a.a.call(this),
            this.type = "ParametricGeometry",
            this.parameters = {
                func: t,
                slices: e,
                stacks: n
            },
            this.fromBufferGeometry(new r(t, e, n)),
            this.mergeVertices()
        }

        function r(t, e, n) {
            o.a.call(this),
            this.type = "ParametricBufferGeometry",
            this.parameters = {
                func: t,
                slices: e,
                stacks: n
            };
            var i, r, a = [],
            c = [],
            h = [],
            l = [],
            f = new u.a,
            p = new u.a,
            d = new u.a,
            m = new u.a,
            v = new u.a,
            g = e + 1;
            for (i = 0; i <= n; i++) {
                var y = i / n;
                for (r = 0; r <= e; r++) {
                    var _ = r / e;
                    p = t(_, y, p),
                    c.push(p.x, p.y, p.z),
                    _ - 1e-5 >= 0 ? (d = t(_ - 1e-5, y, d), m.subVectors(p, d)) : (d = t(_ + 1e-5, y, d), m.subVectors(d, p)),
                    y - 1e-5 >= 0 ? (d = t(_, y - 1e-5, d), v.subVectors(p, d)) : (d = t(_, y + 1e-5, d), v.subVectors(d, p)),
                    f.crossVectors(m, v).normalize(),
                    h.push(f.x, f.y, f.z),
                    l.push(_, y)
                }
            }
            for (i = 0; i < n; i++) for (r = 0; r < e; r++) {
                var x = i * g + r,
                b = i * g + r + 1,
                w = (i + 1) * g + r + 1,
                M = (i + 1) * g + r;
                a.push(x, b, M),
                a.push(b, w, M)
            }
            this.setIndex(a),
            this.addAttribute("position", new s.b(c, 3)),
            this.addAttribute("normal", new s.b(h, 3)),
            this.addAttribute("uv", new s.b(l, 2))
        }
        var a = n("Geometry"),
        o = n("BufferGeometry"),
        s = n("BufferAttribute"),
        u = n("Vector3");
        i.prototype = Object.create(Geometry.prototype),
        i.prototype.constructor = i,
        r.prototype = Object.create(BufferGeometry.prototype),
        r.prototype.constructor = r
    },
    AoCO: function(t, e, n) {
        "use strict";

        function i(t) {
            return t.isRenderList
        }
        e.a = i
    },


    .D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.
    : function(t, e, n) {
        "use strict";
        var i = n("qoGD"),
        r = (n.n(i), n("ShaderLib"));
        n.d(e, "D",
        function() {
            return ShaderLib;
        });
        var a = (n("yQK5"), n("UniformsUtils"));
        n.d(e, "G",
        function() {
            return UniformsUtils
        });
        var o = (n("WqzK"), n("W6T/"), n("rqIV"), n("Scene"));
        n.d(e, "C",
        function() {
            return Scene
        });
        var s = (n("yAYr"), n("Sprite"), n("LOD"), n("SkinnedMesh"), n("S81n"), n("Bone"), n("Mesh"));
        n.d(e, "q",
        function() {
            return Mesh
        });
        var u = (n("LineSegments"), n("LineLoop"), n("Line"), n("Points"), n("Group"), n("mrYs"), n("DataTexture"));
        n.d(e, "h",
        function() {
            return DataTexture
        });
        var c = (n("iQTO"), n("mUPD"), n("PFnl"), n("Ok5I"), n("vh+C"), n("9uYx"));
        n.d(e, "x",
        function() {
            return PlaneBufferGeometry
        });
        var h = n("eekH");
        n.d(e, "r",
        function() {
            return h.MeshBasicMaterial
        }),
        n.d(e, "s",
        function() {
            return h.MeshDepthMaterial
        }),
        n.d(e, "E",
        function() {
            return h.ShaderMaterial
        });
        var l = (n("KFR5"), n("IF3P"), n("tv9O"), n("N570"), n("6Q3k"), 
            n("TTda"), n("OJZr"), n("FeDS"), n("XJ5Z"), n("9/ke"), n("w2Sq"), 
            n("LWBF"), n("/bYS"), n("nGOy"), n("bO/F"), n("SpotLight"), n("PointLight"), 
            n("RectAreaLight"), n("HemisphereLight"), n("tAH4"), n("DirectionalLight"), n("AmbientLight"), n("6f23"),
             n("Light"), n("StereoCamera"), n("PerspectiveCamera"), n("OrthographicCamera"));
        n.d(e, "w",
        function() {
            return OrthographicCamera
        });

        var f = (n("CubeCamera"), n("cfk7"), n("Camera"), n("AudioListener"), n("5AlW"), n("IASN"), n("2ki8"), 
            n("Audio"), n("j6+M"), n("bv29"), n("RRa1"), n("pINk"), n("h6VZ"), n("onH+"), n("Byt3"), 
            n("2seR"), n("TiW2"), n("4W4M"), n("2Tlm"), n("qICY"), n("JzlU"), n("tzsk"), n("InstancedBufferGeometry"), n("BufferGeometry"));
        n.d(e, "e",
        function() {
            return BufferGeometry
        });
        var p = (n("Geometry"), n("zVJs"), n("g2ae"), n("yKmP"), n("iFCb"), n("BufferAttribute"));
        n.d(e, "d",
        function() {
            return BufferAttribute
        });
        var d = (n("HiwY"), n("Object3D"), n("nBLQ"), n("vaUk"), n("EventDispatcher"));
        n.d(e, "m",
        function() {
            return EventDispatcher
        });
        var m = (n("e/Dv"), n("y6Pz"), n("WVM5"), n("RR+E"), n("E2bl"), n("R+5/"), n("Ee7l"), n("_Math"));
        n.d(e, "M",
        function() {
            return _Math
        });
        var v = (n("iYmo"), n("2ss1"), n("Plane"), n("Frustum"));
        n.d(e, "n",
        function() {
            // return v.a
            return Frustum()
        });

        var g = (n("Sphere"), n("6YUT"), n("Matrix4"));
        n.d(e, "p",
        function() {
            return Matrix4()
        });
        var y = (n("Matrix3"), n("Box3"));
        n.d(e, "c",
        function() {
            return Box3
        });
        var _ = (n("FP58"), n("yErb"), n("Euler"));
        n.d(e, "l",
        function() {
            return Euler
        });
        var x = n("Vector4");
        n.d(e, "K",
        function() {
            return Vector4
        });
        var b = n("Vector3");
        n.d(e, "J",
        function() {
            return Vector3
        });
        var w = n("Vector2");
        n.d(e, "I",
        function() {
            return Vector2()
        });

        var M = (n("Quaternion"), n("Color"));
        n.d(e, "f",
        function() {
            return Color
        });
        var S = (n("7KmG"), n("4J9B"), n("Bixb"),
         n("0bni"), n("h+KY"), n("R6/u"), n("rzcw"), n("0atI"),
          n("PUN1"), n("aEZq"), n("Jlpq"), n("zeL8"), n("xBPj"), n("UoFS"),
           n("CSxx"), n("bA0i"), n("OzF/"), n("KYnm"), n("sTAr"), n("ayiu"), 
           n("Judu"), n("PXdy"), n("uQxt"), n("uDA3"), n("k/v9"), n("+Ro2"), 
           n("8Zdr"), n("/wr7"), n("xcHZ"), n("7Hn5"), n("XAHe"), n("Lk8y"), 
           n("f7ra"), n("8NN1"), n("RBSo"));
        n.d(e, "a",

// var REVISION = '95dev';
//     var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
//     var CullFaceNone = 0;
//     var CullFaceBack = 1;
//     var CullFaceFront = 2;
//     var CullFaceFrontBack = 3;
//     var FrontFaceDirectionCW = 0;
//     var FrontFaceDirectionCCW = 1;
//     var BasicShadowMap = 0;
//     var PCFShadowMap = 1;
//     var PCFSoftShadowMap = 2;
//     var FrontSide = 0;
//     var BackSide = 1;
//     var DoubleSide = 2;
//     var FlatShading = 1;
//     var SmoothShading = 2;
//     var NoColors = 0;
//     var FaceColors = 1;
//     var VertexColors = 2;
//     var NoBlending = 0;
//     var NormalBlending = 1;
//     var AdditiveBlending = 2;
//     var SubtractiveBlending = 3;
//     var MultiplyBlending = 4;
//     var CustomBlending = 5;
//     var AddEquation = 100;
//     var SubtractEquation = 101;
//     var ReverseSubtractEquation = 102;
//     var MinEquation = 103;
//     var MaxEquation = 104;
//     var ZeroFactor = 200;
//     var OneFactor = 201;
//     var SrcColorFactor = 202;
//     var OneMinusSrcColorFactor = 203;
//     var SrcAlphaFactor = 204;
//     var OneMinusSrcAlphaFactor = 205;
//     var DstAlphaFactor = 206;
//     var OneMinusDstAlphaFactor = 207;
//     var DstColorFactor = 208;
//     var OneMinusDstColorFactor = 209;
//     var SrcAlphaSaturateFactor = 210;
//     var NeverDepth = 0;
//     var AlwaysDepth = 1;
//     var LessDepth = 2;
//     var LessEqualDepth = 3;
//     var EqualDepth = 4;
//     var GreaterEqualDepth = 5;
//     var GreaterDepth = 6;
//     var NotEqualDepth = 7;
//     var MultiplyOperation = 0;
//     var MixOperation = 1;
//     var AddOperation = 2;
//     var NoToneMapping = 0;
//     var LinearToneMapping = 1;
//     var ReinhardToneMapping = 2;
//     var Uncharted2ToneMapping = 3;
//     var CineonToneMapping = 4;
//     var UVMapping = 300;
//     var CubeReflectionMapping = 301;
//     var CubeRefractionMapping = 302;
//     var EquirectangularReflectionMapping = 303;
//     var EquirectangularRefractionMapping = 304;
//     var SphericalReflectionMapping = 305;
//     var CubeUVReflectionMapping = 306;
//     var CubeUVRefractionMapping = 307;
//     var RepeatWrapping = 1000;
//     var ClampToEdgeWrapping = 1001;
//     var MirroredRepeatWrapping = 1002;
//     var NearestFilter = 1003;
//     var NearestMipMapNearestFilter = 1004;
//     var NearestMipMapLinearFilter = 1005;
//     var LinearFilter = 1006;
//     var LinearMipMapNearestFilter = 1007;
//     var LinearMipMapLinearFilter = 1008;
//     var UnsignedByteType = 1009;
//     var ByteType = 1010;
//     var ShortType = 1011;
//     var UnsignedShortType = 1012;
//     var IntType = 1013;
//     var UnsignedIntType = 1014;
//     var FloatType = 1015;
//     var HalfFloatType = 1016;
//     var UnsignedShort4444Type = 1017;
//     var UnsignedShort5551Type = 1018;
//     var UnsignedShort565Type = 1019;
//     var UnsignedInt248Type = 1020;
//     var AlphaFormat = 1021;
//     var RGBFormat = 1022;
//     var RGBAFormat = 1023;
//     var LuminanceFormat = 1024;
//     var LuminanceAlphaFormat = 1025;
//     var RGBEFormat = RGBAFormat;
//     var DepthFormat = 1026;
//     var DepthStencilFormat = 1027;
//     var RGB_S3TC_DXT1_Format = 33776;
//     var RGBA_S3TC_DXT1_Format = 33777;
//     var RGBA_S3TC_DXT3_Format = 33778;
//     var RGBA_S3TC_DXT5_Format = 33779;
//     var RGB_PVRTC_4BPPV1_Format = 35840;
//     var RGB_PVRTC_2BPPV1_Format = 35841;
//     var RGBA_PVRTC_4BPPV1_Format = 35842;
//     var RGBA_PVRTC_2BPPV1_Format = 35843;
//     var RGB_ETC1_Format = 36196;
//     var RGBA_ASTC_4x4_Format = 37808;
//     var RGBA_ASTC_5x4_Format = 37809;
//     var RGBA_ASTC_5x5_Format = 37810;
//     var RGBA_ASTC_6x5_Format = 37811;
//     var RGBA_ASTC_6x6_Format = 37812;
//     var RGBA_ASTC_8x5_Format = 37813;
//     var RGBA_ASTC_8x6_Format = 37814;
//     var RGBA_ASTC_8x8_Format = 37815;
//     var RGBA_ASTC_10x5_Format = 37816;
//     var RGBA_ASTC_10x6_Format = 37817;
//     var RGBA_ASTC_10x8_Format = 37818;
//     var RGBA_ASTC_10x10_Format = 37819;
//     var RGBA_ASTC_12x10_Format = 37820;
//     var RGBA_ASTC_12x12_Format = 37821;
//     var LoopOnce = 2200;
//     var LoopRepeat = 2201;
//     var LoopPingPong = 2202;
//     var InterpolateDiscrete = 2300;
//     var InterpolateLinear = 2301;
//     var InterpolateSmooth = 2302;
//     var ZeroCurvatureEnding = 2400;
//     var ZeroSlopeEnding = 2401;
//     var WrapAroundEnding = 2402;
//     var TrianglesDrawMode = 0;
//     var TriangleStripDrawMode = 1;
//     var TriangleFanDrawMode = 2;
//     var LinearEncoding = 3000;
//     var sRGBEncoding = 3001;
//     var GammaEncoding = 3007;
//     var RGBEEncoding = 3002;
//     var LogLuvEncoding = 3003;
//     var RGBM7Encoding = 3004;
//     var RGBM16Encoding = 3005;
//     var RGBDEncoding = 3006;
//     var BasicDepthPacking = 3200;
//     var RGBADepthPacking = 3201;
//     var TangentSpaceNormalMap = 0;
//     var ObjectSpaceNormalMap = 1;

        function() {
            // return S.a
            return 100
        }),
        n.d(e, "b",
        function() {
            // return S.g
            return 3200
        }),
        n.d(e, "g",
        function() {
            return S.r
        }),
        n.d(e, "i",
        function() {
            return S.u
        }),
        n.d(e, "j",
        function() {
            return S.v
        }),
        n.d(e, "k",
        function() {
            return S.w
        }),
        n.d(e, "o",
        function() {
            return S.Q
        }),
        n.d(e, "t",
        function() {
            return S._4
        }),
        n.d(e, "u",
        function() {
            return S._5
        }),
        n.d(e, "v",
        function() {
            return S._9
        }),
        n.d(e, "y",
        function() {
            return S._21
        }),
        n.d(e, "z",
        function() {
            return S._22
        }),
        n.d(e, "A",
        function() {
            return S._30
        }),
        n.d(e, "B",
        function() {
            return S._38
        }),
        n.d(e, "F",
        function() {
            return S._51
        }),
        n.d(e, "H",
        function() {
            return S._53
        }),
        n.d(e, "L",
        function() {
            return S._63
        });
        n("Jjpd")
    },
    B0Bi: function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#else\\n\\t\\tvec3 reflectVec = vReflect;\\n\\t#endif\\n\\t#ifdef ENVMAP_TYPE_CUBE\\n\\t\\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\\t\\tvec2 sampleUV;\\n\\t\\tsampleUV.y = asin( flipNormal * reflectVec.y ) * RECIPROCAL_PI + 0.5;\\n\\t\\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\\t\\tvec4 envColor = texture2D( envMap, sampleUV );\\n\\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\\t\\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\n\\t\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\\t#else\\n\\t\\tvec4 envColor = vec4( 0.0 );\\n\\t#endif\\n\\tenvColor = envMapTexelToLinear( envColor );\\n\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\t\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_MIX )\\n\\t\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\\t#elif defined( ENVMAP_BLENDING_ADD )\\n\\t\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\\t#endif\\n#endif\\n"
    },
    


====Geometry=====
Geometry: function(t, e, n) {
        "use strict";

        function Geometry() {
            return v++
        }

        function r() {
            Object.defineProperty(this, "id", {
                value: i()
            }),
            this.uuid = _Math.generateUUID(),
            this.name = "",
            this.type = "Geometry",
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.elementsNeedUpdate = false,
            this.verticesNeedUpdate = false,
            this.uvsNeedUpdate = false,
            this.normalsNeedUpdate = false,
            this.colorsNeedUpdate = false,
            this.lineDistancesNeedUpdate = false,
            this.groupsNeedUpdate = false
        }
        n.d(e, "b",
        function() {
            return Geometry
        }),
        n.d(e, "a",
        function() {
            return r
        });
        var a = n("EventDispatcher"),
        o = n("HiwY"),
        s = n("Matrix3"),
        u = n("Sphere"),
        c = n("Box3"),
        h = n("Vector3"),
        l = n("Matrix4"),
        p = n("Color"),
        d = n("Object3D"),
        v = 0;
        Object.assign(r.prototype, a.a.prototype, {
            isGeometry: true,
            applyMatrix: function(t) {
                for (var e = (new s.a).getNormalMatrix(t), n = 0, i = this.vertices.length; n < i; n++) {
                    this.vertices[n].applyMatrix4(t)
                }
                for (var n = 0,
                i = this.faces.length; n < i; n++) {
                    var r = this.faces[n];
                    r.normal.applyMatrix3(e).normalize();
                    for (var a = 0,
                    o = r.vertexNormals.length; a < o; a++) r.vertexNormals[a].applyMatrix3(e).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this.verticesNeedUpdate = true,
                this.normalsNeedUpdate = true,
                this
            },
            rotateX: function() {
                var t = new l.a;
                return function(e) {
                    return t.makeRotationX(e),
                    this.applyMatrix(t),
                    this
                }
            } (),
            rotateY: function() {
                var t = new l.a;
                return function(e) {
                    return t.makeRotationY(e),
                    this.applyMatrix(t),
                    this
                }
            } (),
            rotateZ: function() {
                var t = new l.a;
                return function(e) {
                    return t.makeRotationZ(e),
                    this.applyMatrix(t),
                    this
                }
            } (),
            translate: function() {
                var t = new l.a;
                return function(e, n, i) {
                    return t.makeTranslation(e, n, i),
                    this.applyMatrix(t),
                    this
                }
            } (),
            scale: function() {
                var t = new l.a;
                return function(e, n, i) {
                    return t.makeScale(e, n, i),
                    this.applyMatrix(t),
                    this
                }
            } (),
            lookAt: function() {
                var t = new d.a;
                return function(e) {
                    t.lookAt(e),
                    t.updateMatrix(),
                    this.applyMatrix(t.matrix)
                }
            } (),
            fromBufferGeometry: function(t) {
                function e(t, e, i, r) {
                    var a = undefined !== s ? [d[t].clone(), d[e].clone(), d[i].clone()] : [],
                    h = undefined !== u ? [n.colors[t].clone(), n.colors[e].clone(), n.colors[i].clone()] : [],
                    f = new o.a(t, e, i, a, h, r);
                    n.faces.push(f),
                    undefined !== c && n.faceVertexUvs[0].push([m[t].clone(), m[e].clone(), m[i].clone()]),
                    undefined !== l && n.faceVertexUvs[1].push([v[t].clone(), v[e].clone(), v[i].clone()])
                }
                var n = this,
                i = null !== t.index ? t.index.array: undefined,
                r = t.attributes,
                a = r.position.array,
                s = undefined !== r.normal ? r.normal.array: undefined,
                u = undefined !== r.color ? r.color.array: undefined,
                c = undefined !== r.uv ? r.uv.array: undefined,
                l = undefined !== r.uv2 ? r.uv2.array: undefined;
                undefined !== l && (this.faceVertexUvs[1] = []);
                for (var d = [], m = [], v = [], g = 0, y = 0; g < a.length; g += 3, y += 2) 
                    n.vertices.push(new h.a(a[g], a[g + 1], a[g + 2])),
                undefined !== s && d.push(new h.a(s[g], s[g + 1], s[g + 2])),
                undefined !== u && n.colors.push(new p.a(u[g], u[g + 1], u[g + 2])),
                undefined !== c && m.push(new Vector2(c[y], c[y + 1])),
                undefined !== l && v.push(new Vector2(l[y], l[y + 1]));
                var _ = t.groups;
                if (_.length > 0) for (var g = 0; g < _.length; g++) for (var x = _[g], b = x.start, w = x.count, y = b, M = b + w; y < M; y += 3) undefined !== i ? e(i[y], i[y + 1], i[y + 2], x.materialIndex) : e(y, y + 1, y + 2, x.materialIndex);
                else if (undefined !== i) for (var g = 0; g < i.length; g += 3) e(i[g], i[g + 1], i[g + 2]);
                else for (var g = 0; g < a.length / 3; g += 3) e(g, g + 1, g + 2);
                return this.computeFaceNormals(),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                this
            },
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z),
                t
            },
            normalize: function() {
                this.computeBoundingSphere();
                var t = this.boundingSphere.center,
                e = this.boundingSphere.radius,
                n = 0 === e ? 1 : 1 / e,
                i = new l.a;
                return i.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1),
                this.applyMatrix(i),
                this
            },
            computeFaceNormals: function() {
                for (var t = new h.a,
                e = new h.a,
                n = 0,
                i = this.faces.length; n < i; n++) {
                    var r = this.faces[n],
                    a = this.vertices[r.a],
                    o = this.vertices[r.b],
                    s = this.vertices[r.c];
                    t.subVectors(s, o),
                    e.subVectors(a, o),
                    t.cross(e),
                    t.normalize(),
                    r.normal.copy(t)
                }
            },
            computeVertexNormals: function(t) {
                undefined === t && (t = true);
                var e, n, i, r, a, o;
                for (o = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) o[e] = new h.a;
                if (t) {
                    var s, u, c, l = new h.a,
                    f = new h.a;
                    for (i = 0, r = this.faces.length; i < r; i++) a = this.faces[i],
                    s = this.vertices[a.a],
                    u = this.vertices[a.b],
                    c = this.vertices[a.c],
                    l.subVectors(c, u),
                    f.subVectors(s, u),
                    l.cross(f),
                    o[a.a].add(l),
                    o[a.b].add(l),
                    o[a.c].add(l)
                } else for (this.computeFaceNormals(), i = 0, r = this.faces.length; i < r; i++) a = this.faces[i],
                o[a.a].add(a.normal),
                o[a.b].add(a.normal),
                o[a.c].add(a.normal);
                for (e = 0, n = this.vertices.length; e < n; e++) o[e].normalize();
                for (i = 0, r = this.faces.length; i < r; i++) {
                    a = this.faces[i];
                    var p = a.vertexNormals;
                    3 === p.length ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c])) : (p[0] = o[a.a].clone(), p[1] = o[a.b].clone(), p[2] = o[a.c].clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = true)
            },
            computeFlatVertexNormals: function() {
                var t, e, n;
                for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                    n = this.faces[t];
                    var i = n.vertexNormals;
                    3 === i.length ? (i[0].copy(n.normal), i[1].copy(n.normal), i[2].copy(n.normal)) : (i[0] = n.normal.clone(), i[1] = n.normal.clone(), i[2] = n.normal.clone())
                }
                this.faces.length > 0 && (this.normalsNeedUpdate = true)
            },
            computeMorphNormals: function() {
                var t, e, n, i, a;
                for (n = 0, i = this.faces.length; n < i; n++) for (a = this.faces[n], a.__originalFaceNormal ? a.__originalFaceNormal.copy(a.normal) : a.__originalFaceNormal = a.normal.clone(), a.__originalVertexNormals || (a.__originalVertexNormals = []), t = 0, e = a.vertexNormals.length; t < e; t++) a.__originalVertexNormals[t] ? a.__originalVertexNormals[t].copy(a.vertexNormals[t]) : a.__originalVertexNormals[t] = a.vertexNormals[t].clone();
                var o = new r;
                for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                    if (!this.morphNormals[t]) {
                        this.morphNormals[t] = {},
                        this.morphNormals[t].faceNormals = [],
                        this.morphNormals[t].vertexNormals = [];
                        var s, u, c = this.morphNormals[t].faceNormals,
                        l = this.morphNormals[t].vertexNormals;
                        for (n = 0, i = this.faces.length; n < i; n++) s = new h.a,
                        u = {
                            a: new h.a,
                            b: new h.a,
                            c: new h.a
                        },
                        c.push(s),
                        l.push(u)
                    }
                    var f = this.morphNormals[t];
                    o.vertices = this.morphTargets[t].vertices,
                    o.computeFaceNormals(),
                    o.computeVertexNormals();
                    var s, u;
                    for (n = 0, i = this.faces.length; n < i; n++) a = this.faces[n],
                    s = f.faceNormals[n],
                    u = f.vertexNormals[n],
                    s.copy(a.normal),
                    u.a.copy(a.vertexNormals[0]),
                    u.b.copy(a.vertexNormals[1]),
                    u.c.copy(a.vertexNormals[2])
                }
                for (n = 0, i = this.faces.length; n < i; n++) a = this.faces[n],
                a.normal = a.__originalFaceNormal,
                a.vertexNormals = a.__originalVertexNormals
            },
            computeLineDistances: function() {
                for (var t = 0,
                e = this.vertices,
                n = 0,
                i = e.length; n < i; n++) n > 0 && (t += e[n].distanceTo(e[n - 1])),
                this.lineDistances[n] = t
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new c.a),
                this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new u.a),
                this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(t, e, n) {
                if (!t || !t.isGeometry) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t);
                var i, r = this.vertices.length,
                a = this.vertices,
                u = t.vertices,
                c = this.faces,
                h = t.faces,
                l = this.faceVertexUvs[0],
                f = t.faceVertexUvs[0],
                p = this.colors,
                d = t.colors;
                undefined === n && (n = 0),
                undefined !== e && (i = (new s.a).getNormalMatrix(e));
                for (var m = 0,
                v = u.length; m < v; m++) {
                    var g = u[m],
                    y = g.clone();
                    undefined !== e && y.applyMatrix4(e),
                    a.push(y)
                }
                for (var m = 0,
                v = d.length; m < v; m++) p.push(d[m].clone());
                for (m = 0, v = h.length; m < v; m++) {
                    var _, x, b, w = h[m],
                    M = w.vertexNormals,
                    S = w.vertexColors;
                    _ = new o.a(w.a + r, w.b + r, w.c + r),
                    _.normal.copy(w.normal),
                    undefined !== i && _.normal.applyMatrix3(i).normalize();
                    for (var E = 0,
                    T = M.length; E < T; E++) x = M[E].clone(),
                    undefined !== i && x.applyMatrix3(i).normalize(),
                    _.vertexNormals.push(x);
                    _.color.copy(w.color);
                    for (var E = 0,
                    T = S.length; E < T; E++) b = S[E],
                    _.vertexColors.push(b.clone());
                    _.materialIndex = w.materialIndex + n,
                    c.push(_)
                }
                for (m = 0, v = f.length; m < v; m++) {
                    var A = f[m],
                    C = [];
                    if (undefined !== A) {
                        for (var E = 0,
                        T = A.length; E < T; E++) C.push(A[E].clone());
                        l.push(C)
                    }
                }
            },
            mergeMesh: function(t) {
                if (!t || !t.isMesh) return void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t);
                t.matrixAutoUpdate && t.updateMatrix(),
                this.merge(t.geometry, t.matrix)
            },
            mergeVertices: function() {
                var t, e, n, i, r, a, o, s, u = {},
                c = [],
                h = [],
                l = Math.pow(10, 4);
                for (n = 0, i = this.vertices.length; n < i; n++) t = this.vertices[n],
                e = Math.round(t.x * l) + "_" + Math.round(t.y * l) + "_" + Math.round(t.z * l),
                undefined === u[e] ? (u[e] = n, c.push(this.vertices[n]), h[n] = c.length - 1) : h[n] = h[u[e]];
                var f = [];
                for (n = 0, i = this.faces.length; n < i; n++) {
                    r = this.faces[n],
                    r.a = h[r.a],
                    r.b = h[r.b],
                    r.c = h[r.c],
                    a = [r.a, r.b, r.c];
                    for (var p = 0; p < 3; p++) if (a[p] === a[(p + 1) % 3]) {
                        f.push(n);
                        break
                    }
                }
                for (n = f.length - 1; n >= 0; n--) {
                    var d = f[n];
                    for (this.faces.splice(d, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++) this.faceVertexUvs[o].splice(d, 1)
                }
                var m = this.vertices.length - c.length;
                return this.vertices = c,
                m
            },
            sortFacesByMaterialIndex: function() {
                function t(t, e) {
                    return t.materialIndex - e.materialIndex
                }
                for (var e = this.faces,
                n = e.length,
                i = 0; i < n; i++) e[i]._id = i;
                e.sort(t);
                var r, a, o = this.faceVertexUvs[0],
                s = this.faceVertexUvs[1];
                o && o.length === n && (r = []),
                s && s.length === n && (a = []);
                for (var i = 0; i < n; i++) {
                    var u = e[i]._id;
                    r && r.push(o[u]),
                    a && a.push(s[u])
                }
                r && (this.faceVertexUvs[0] = r),
                a && (this.faceVertexUvs[1] = a)
            },
            toJSON: function() {
                function t(t, e, n) {
                    return n ? t | 1 << e: t & ~ (1 << e)
                }

                function e(t) {
                    var e = t.x.toString() + t.y.toString() + t.z.toString();
                    return undefined !== f[e] ? f[e] : (f[e] = l.length / 3, l.push(t.x, t.y, t.z), f[e])
                }

                function n(t) {
                    var e = t.r.toString() + t.g.toString() + t.b.toString();
                    return undefined !== d[e] ? d[e] : (d[e] = p.length, p.push(t.getHex()), d[e])
                }

                function i(t) {
                    var e = t.x.toString() + t.y.toString();
                    return undefined !== v[e] ? v[e] : (v[e] = m.length / 2, m.push(t.x, t.y), v[e])
                }
                var r = {
                    metadata: {
                        version: 4.5,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), undefined !== this.parameters) {
                    var a = this.parameters;
                    for (var o in a) undefined !== a[o] && (r[o] = a[o]);
                    return r
                }
                for (var s = [], u = 0; u < this.vertices.length; u++) {
                    var c = this.vertices[u];
                    s.push(c.x, c.y, c.z)
                }
                for (var h = [], l = [], f = {},
                p = [], d = {},
                m = [], v = {},
                u = 0; u < this.faces.length; u++) {
                    var g = this.faces[u],
                    y = undefined !== this.faceVertexUvs[0][u],
                    _ = g.normal.length() > 0,
                    x = g.vertexNormals.length > 0,
                    b = 1 !== g.color.r || 1 !== g.color.g || 1 !== g.color.b,
                    w = g.vertexColors.length > 0,
                    M = 0;
                    if (M = t(M, 0, 0), M = t(M, 1, true), M = t(M, 2, false), M = t(M, 3, y), M = t(M, 4, _), M = t(M, 5, x), M = t(M, 6, b), M = t(M, 7, w), h.push(M), h.push(g.a, g.b, g.c), h.push(g.materialIndex), y) {
                        var S = this.faceVertexUvs[0][u];
                        h.push(i(S[0]), i(S[1]), i(S[2]))
                    }
                    if (_ && h.push(e(g.normal)), x) {
                        var E = g.vertexNormals;
                        h.push(e(E[0]), e(E[1]), e(E[2]))
                    }
                    if (b && h.push(n(g.color)), w) {
                        var T = g.vertexColors;
                        h.push(n(T[0]), n(T[1]), n(T[2]))
                    }
                }
                return r.data = {},
                r.data.vertices = s,
                r.data.normals = l,
                p.length > 0 && (r.data.colors = p),
                m.length > 0 && (r.data.uvs = [m]),
                r.data.faces = h,
                r
            },
            clone: function() {
                return (new r).copy(this)
            },
            copy: function(t) {
                var e, n, i, r, a, o;
                this.vertices = [],
                this.colors = [],
                this.faces = [],
                this.faceVertexUvs = [[]],
                this.morphTargets = [],
                this.morphNormals = [],
                this.skinWeights = [],
                this.skinIndices = [],
                this.lineDistances = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.name = t.name;
                var s = t.vertices;
                for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
                var u = t.colors;
                for (e = 0, n = u.length; e < n; e++) this.colors.push(u[e].clone());
                var c = t.faces;
                for (e = 0, n = c.length; e < n; e++) this.faces.push(c[e].clone());
                for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                    var h = t.faceVertexUvs[e];
                    for (undefined === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), i = 0, r = h.length; i < r; i++) {
                        var l = h[i],
                        f = [];
                        for (a = 0, o = l.length; a < o; a++) {
                            var p = l[a];
                            f.push(p.clone())
                        }
                        this.faceVertexUvs[e].push(f)
                    }
                }
                var d = t.morphTargets;
                for (e = 0, n = d.length; e < n; e++) {
                    var m = {};
                    if (m.name = d[e].name, undefined !== d[e].vertices) for (m.vertices = [], i = 0, r = d[e].vertices.length; i < r; i++) m.vertices.push(d[e].vertices[i].clone());
                    if (undefined !== d[e].normals) for (m.normals = [], i = 0, r = d[e].normals.length; i < r; i++) m.normals.push(d[e].normals[i].clone());
                    this.morphTargets.push(m)
                }
                var v = t.morphNormals;
                for (e = 0, n = v.length; e < n; e++) {
                    var g = {};
                    if (undefined !== v[e].vertexNormals) for (g.vertexNormals = [], i = 0, r = v[e].vertexNormals.length; i < r; i++) {
                        var y = v[e].vertexNormals[i],
                        _ = {};
                        _.a = y.a.clone(),
                        _.b = y.b.clone(),
                        _.c = y.c.clone(),
                        g.vertexNormals.push(_)
                    }
                    if (undefined !== v[e].faceNormals) for (g.faceNormals = [], i = 0, r = v[e].faceNormals.length; i < r; i++) g.faceNormals.push(v[e].faceNormals[i].clone());
                    this.morphNormals.push(g)
                }
                var x = t.skinWeights;
                for (e = 0, n = x.length; e < n; e++) this.skinWeights.push(x[e].clone());
                var b = t.skinIndices;
                for (e = 0, n = b.length; e < n; e++) this.skinIndices.push(b[e].clone());
                var w = t.lineDistances;
                for (e = 0, n = w.length; e < n; e++) this.lineDistances.push(w[e]);
                var M = t.boundingBox;
                null !== M && (this.boundingBox = M.clone());
                var S = t.boundingSphere;
                return null !== S && (this.boundingSphere = S.clone()),
                this.elementsNeedUpdate = t.elementsNeedUpdate,
                this.verticesNeedUpdate = t.verticesNeedUpdate,
                this.uvsNeedUpdate = t.uvsNeedUpdate,
                this.normalsNeedUpdate = t.normalsNeedUpdate,
                this.colorsNeedUpdate = t.colorsNeedUpdate,
                this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate,
                this.groupsNeedUpdate = t.groupsNeedUpdate,
                this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        })
    },
====Geometry=====



    BP0C: function(t, e, n) {
        "use strict";
        e.a = "float getShadowMask() {\\n\\tfloat shadow = 1.0;\\n\\t#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\tDirectionalLight directionalLight;\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\tSpotLight spotLight;\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\t\\tspotLight = spotLights[ i ];\\n\\t\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\tPointLight pointLight;\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\t\\tpointLight = pointLights[ i ];\\n\\t\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\\t}\\n\\t#endif\\n\\t#endif\\n\\treturn shadow;\\n}\\n"
    },
    Bixb: function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            this.object = t,
            this.size = undefined !== e ? e: 1;
            var r = undefined !== n ? n: 16711680,
            a = undefined !== i ? i: 1,
            h = 0,
            l = this.object.geometry;
            l && l.isGeometry ? h = 3 * l.faces.length: l && l.isBufferGeometry && (h = l.attributes.normal.count);
            var f = new c.a,
            p = new u.b(2 * h * 3, 3);
            f.addAttribute("position", p),
            o.a.call(this, f, new s.a({
                color: r,
                linewidth: a
            })),
            this.matrixAutoUpdate = false,
            this.update()
        }
        var r = n("Matrix3"),
        a = n("Vector3"),
        o = n("LineSegments"),
        s = n("LineBasicMaterial"),
        u = n("BufferAttribute"),
        c = n("BufferGeometry");
        i.prototype = Object.create(o.a.prototype),
        i.prototype.constructor = i,
        i.prototype.update = function() {
            var t = new a.a,
            e = new a.a,
            n = new r.a;
            return function() {
                var i = ["a", "b", "c"];
                this.object.updateMatrixWorld(true),
                n.getNormalMatrix(this.object.matrixWorld);
                var r = this.object.matrixWorld,
                a = this.geometry.attributes.position,
                o = this.object.geometry;
                if (o && o.isGeometry) for (var s = o.vertices,
                u = o.faces,
                c = 0,
                h = 0,
                l = u.length; h < l; h++) for (var f = u[h], p = 0, d = f.vertexNormals.length; p < d; p++) {
                    var m = s[f[i[p]]],
                    v = f.vertexNormals[p];
                    t.copy(m).applyMatrix4(r),
                    e.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
                    a.setXYZ(c, t.x, t.y, t.z),
                    c += 1,
                    a.setXYZ(c, e.x, e.y, e.z),
                    c += 1
                } else if (o && o.isBufferGeometry) for (var g = o.attributes.position,
                y = o.attributes.normal,
                c = 0,
                p = 0,
                d = g.count; p < d; p++) t.set(g.getX(p), g.getY(p), g.getZ(p)).applyMatrix4(r),
                e.set(y.getX(p), y.getY(p), y.getZ(p)),
                e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
                a.setXYZ(c, t.x, t.y, t.z),
                c += 1,
                a.setXYZ(c, e.x, e.y, e.z),
                c += 1;
                a.needsUpdate = true
            }
        } ()
    },
    BmNd: function(t, e, n) {
        "use strict";
        e.a = "#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_DISPLACEMENTMAP\\n\\t\\t#include <beginnormal_vertex>\\n\\t\\t#include <morphnormal_vertex>\\n\\t\\t#include <skinnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <displacementmap_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n}\\n"
    },
    BufferGeometry: function(t, e, n) {
        "use strict";

        function BufferGeometry() {
            Object.defineProperty(this, "id", {
                value: Object(m.b)()
            }),
            this.uuid = p.a.generateUUID(),
            this.name = "",
            this.type = "BufferGeometry",
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null,
            this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }
        n.d(e, "a",
        function() {
            return BufferGeometry
        });
        var r = n("Vector3"),
        a = n("Box3"),
        o = n("EventDispatcher"),
        s = n("BufferAttribute"),
        u = n("Sphere"),
        c = n("DirectGeometry"),
        h = n("Object3D"),
        l = n("Matrix4"),
        f = n("Matrix3"),
        p = n("_Math"),
        d = n("pAuK"),
        m = n("Geometry");
        i.MaxIndex = 65535,
        Object.assign(i.prototype, o.a.prototype, {
            isBufferGeometry: true,
            getIndex: function() {
                return this.index
            },
            setIndex: function(t) {
                Array.isArray(t) ? this.index = new(Object(d.a)(t) > 65535 ? s.d: s.c)(t, 1) : this.index = t
            },
            addAttribute: function(t, e) {
                return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(e)) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(t, new s.a(arguments[1], arguments[2])))
            },
            getAttribute: function(t) {
                return this.attributes[t]
            },
            removeAttribute: function(t) {
                return delete this.attributes[t],
                this
            },
            addGroup: function(t, e, n) {
                this.groups.push({
                    start: t,
                    count: e,
                    materialIndex: undefined !== n ? n: 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(t, e) {
                this.drawRange.start = t,
                this.drawRange.count = e
            },
            applyMatrix: function(t) {
                var e = this.attributes.position;
                undefined !== e && (t.applyToBufferAttribute(e), e.needsUpdate = true);
                var n = this.attributes.normal;
                if (undefined !== n) { (new f.a).getNormalMatrix(t).applyToBufferAttribute(n),
                    n.needsUpdate = true
                }
                return null !== this.boundingBox && this.computeBoundingBox(),
                null !== this.boundingSphere && this.computeBoundingSphere(),
                this
            },
            rotateX: function() {
                var t = new l.a;
                return function(e) {
                    return t.makeRotationX(e),
                    this.applyMatrix(t),
                    this
                }
            } (),
            rotateY: function() {
                var t = new l.a;
                return function(e) {
                    return t.makeRotationY(e),
                    this.applyMatrix(t),
                    this
                }
            } (),
            rotateZ: function() {
                var t = new l.a;
                return function(e) {
                    return t.makeRotationZ(e),
                    this.applyMatrix(t),
                    this
                }
            } (),
            translate: function() {
                var t = new l.a;
                return function(e, n, i) {
                    return t.makeTranslation(e, n, i),
                    this.applyMatrix(t),
                    this
                }
            } (),
            scale: function() {
                var t = new l.a;
                return function(e, n, i) {
                    return t.makeScale(e, n, i),
                    this.applyMatrix(t),
                    this
                }
            } (),
            lookAt: function() {
                var t = new h.a;
                return function(e) {
                    t.lookAt(e),
                    t.updateMatrix(),
                    this.applyMatrix(t.matrix)
                }
            } (),
            center: function() {
                this.computeBoundingBox();
                var t = this.boundingBox.getCenter().negate();
                return this.translate(t.x, t.y, t.z),
                t
            },
            setFromObject: function(t) {
                var e = t.geometry;
                if (t.isPoints || t.isLine) {
                    var n = new s.b(3 * e.vertices.length, 3),
                    i = new s.b(3 * e.colors.length, 3);
                    if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                        var r = new s.b(e.lineDistances.length, 1);
                        this.addAttribute("lineDistance", r.copyArray(e.lineDistances))
                    }
                    null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
                    null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                return this
            },
            updateFromObject: function(t) {
                var geometry = t.geometry;
                if (t.isMesh) {
                    var n = geometry.__directGeometry;
                    if (true === .elementsNeedUpdate && (n = undefined, geometry.elementsNeedUpdate = false), undefined === n) return this.fromGeometry(e);
                    n.verticesNeedUpdate = geometry.verticesNeedUpdate,
                    n.normalsNeedUpdate = geometry.normalsNeedUpdate,
                    n.colorsNeedUpdate = geometry.colorsNeedUpdate,
                    n.uvsNeedUpdate = geometry.uvsNeedUpdate,
                    n.groupsNeedUpdate = geometry.groupsNeedUpdate,
                    geometry.verticesNeedUpdate = false,
                    geometry.normalsNeedUpdate = false,
                    geometry.colorsNeedUpdate = false,
                    geometry.uvsNeedUpdate = false,
                    geometry.groupsNeedUpdate = false,
                    geometry = n
                }
                var i;
                if(geometry.verticesNeedUpdate == true) {
                    i = this.attributes.position;
                    if(undefined !== i) {
                        i.copyVector3sArray(geometry.vertices);
                        i.needsUpdate = true;
                    }
                    geometry.verticesNeedUpdate = false;
                }

                if(geometry.normalsNeedUpdate == ture) {
                    i = this.attributes.normal;
                    if(undefined !== i) {
                        i.copyVector3sArray(geometry.normals);
                        i.needsUpdate = true;
                    }
                    geometry.normalsNeedUpdate = false;
                }

                if(geometry.colorsNeedUpdate == true) {
                    i = this.attributes.color;
                    if(undefined !== i) {
                        i.copyColorsArray(geometry.colors);
                        i.needsUpdate = true;
                    }
                    geometry.colorsNeedUpdate = false;
                }

                if ( geometry.uvsNeedUpdate ) {

                    attribute = this.attributes.uv;

                    if ( attribute !== undefined ) {

                        attribute.copyVector2sArray( geometry.uvs );
                        attribute.needsUpdate = true;

                    }

                    geometry.uvsNeedUpdate = false;

                }

                if ( geometry.lineDistancesNeedUpdate ) {

                    attribute = this.attributes.lineDistance;

                    if ( attribute !== undefined ) {

                        attribute.copyArray( geometry.lineDistances );
                        attribute.needsUpdate = true;

                    }

                    geometry.lineDistancesNeedUpdate = false;

                }

                if ( geometry.groupsNeedUpdate ) {

                    geometry.computeGroups( object.geometry );
                    this.groups = geometry.groups;

                    geometry.groupsNeedUpdate = false;

                }

                return this;

                // return ! 0 === e.verticesNeedUpdate && 
                // (i = this.attributes.position, undefined !== i && 
                //     (i.copyVector3sArray(e.vertices), i.needsUpdate = true), 
                //     e.verticesNeedUpdate = false),
                // true === e.normalsNeedUpdate && (i = this.attributes.normal, 
                //     undefined !== i && (i.copyVector3sArray(e.normals), i.needsUpdate = true),
                //      e.normalsNeedUpdate = false),
                // true === e.colorsNeedUpdate && (i = this.attributes.color, undefined !== i 
                //     && (i.copyColorsArray(e.colors), i.needsUpdate = true), e.colorsNeedUpdate = false),
                // e.uvsNeedUpdate && (i = this.attributes.uv, undefined !== i && 
                //     (i.copyVector2sArray(e.uvs), i.needsUpdate = true), 
                //     e.uvsNeedUpdate = false),
                // e.lineDistancesNeedUpdate && 
                // (i = this.attributes.lineDistance, undefined !== i && 
                //     (i.copyArray(e.lineDistances), i.needsUpdate = true), 
                //     e.lineDistancesNeedUpdate = false),
                // e.groupsNeedUpdate && 
                // (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = false),
                this
            },
            fromGeometry: function(t) {
                return t.__directGeometry = (new c.a).fromGeometry(t),
                this.fromDirectGeometry(t.__directGeometry)
            },
            fromDirectGeometry: function(t) {
                var e = new Float32Array(3 * t.vertices.length);
                if (this.addAttribute("position", new s.a(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                    var n = new Float32Array(3 * t.normals.length);
                    this.addAttribute("normal", new s.a(n, 3).copyVector3sArray(t.normals))
                }
                if (t.colors.length > 0) {
                    var i = new Float32Array(3 * t.colors.length);
                    this.addAttribute("color", new s.a(i, 3).copyColorsArray(t.colors))
                }
                if (t.uvs.length > 0) {
                    var r = new Float32Array(2 * t.uvs.length);
                    this.addAttribute("uv", new s.a(r, 2).copyVector2sArray(t.uvs))
                }
                if (t.uvs2.length > 0) {
                    var a = new Float32Array(2 * t.uvs2.length);
                    this.addAttribute("uv2", new s.a(a, 2).copyVector2sArray(t.uvs2))
                }
                if (t.indices.length > 0) {
                    var o = Object(d.a)(t.indices) > 65535 ? Uint32Array: Uint16Array,
                    u = new o(3 * t.indices.length);
                    this.setIndex(new s.a(u, 1).copyIndicesArray(t.indices))
                }
                this.groups = t.groups;
                for (var c in t.morphTargets) {
                    for (var h = [], l = t.morphTargets[c], f = 0, p = l.length; f < p; f++) {
                        var m = l[f],
                        v = new s.b(3 * m.length, 3);
                        h.push(v.copyVector3sArray(m))
                    }
                    this.morphAttributes[c] = h
                }
                if (t.skinIndices.length > 0) {
                    var g = new s.b(4 * t.skinIndices.length, 4);
                    this.addAttribute("skinIndex", g.copyVector4sArray(t.skinIndices))
                }
                if (t.skinWeights.length > 0) {
                    var y = new s.b(4 * t.skinWeights.length, 4);
                    this.addAttribute("skinWeight", y.copyVector4sArray(t.skinWeights))
                }
                return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
                null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
                this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new a.a);
                var t = this.attributes.position;
                undefined !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(),
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                var t = new a.a,
                e = new r.a;
                return function() {
                    null === this.boundingSphere && (this.boundingSphere = new u.a);
                    var n = this.attributes.position;
                    if (n) {
                        var i = this.boundingSphere.center;
                        t.setFromBufferAttribute(n),
                        t.getCenter(i);
                        for (var r = 0,
                        a = 0,
                        o = n.count; a < o; a++) e.x = n.getX(a),
                        e.y = n.getY(a),
                        e.z = n.getZ(a),
                        r = Math.max(r, i.distanceToSquared(e));
                        this.boundingSphere.radius = Math.sqrt(r),
                        isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            } (),
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var t = this.index,
                e = this.attributes,
                n = this.groups;
                if (e.position) {
                    var i = e.position.array;
                    if (undefined === e.normal) this.addAttribute("normal", new s.a(new Float32Array(i.length), 3));
                    else for (var a = e.normal.array,
                    o = 0,
                    u = a.length; o < u; o++) a[o] = 0;
                    var c, h, l, f = e.normal.array,
                    p = new r.a,
                    d = new r.a,
                    m = new r.a,
                    v = new r.a,
                    g = new r.a;
                    if (t) {
                        var y = t.array;
                        0 === n.length && this.addGroup(0, y.length);
                        for (var _ = 0,
                        x = n.length; _ < x; ++_) for (var b = n[_], w = b.start, M = b.count, o = w, u = w + M; o < u; o += 3) c = 3 * y[o + 0],
                        h = 3 * y[o + 1],
                        l = 3 * y[o + 2],
                        p.fromArray(i, c),
                        d.fromArray(i, h),
                        m.fromArray(i, l),
                        v.subVectors(m, d),
                        g.subVectors(p, d),
                        v.cross(g),
                        f[c] += v.x,
                        f[c + 1] += v.y,
                        f[c + 2] += v.z,
                        f[h] += v.x,
                        f[h + 1] += v.y,
                        f[h + 2] += v.z,
                        f[l] += v.x,
                        f[l + 1] += v.y,
                        f[l + 2] += v.z
                    } else for (var o = 0,
                    u = i.length; o < u; o += 9) p.fromArray(i, o),
                    d.fromArray(i, o + 3),
                    m.fromArray(i, o + 6),
                    v.subVectors(m, d),
                    g.subVectors(p, d),
                    v.cross(g),
                    f[o] = v.x,
                    f[o + 1] = v.y,
                    f[o + 2] = v.z,
                    f[o + 3] = v.x,
                    f[o + 4] = v.y,
                    f[o + 5] = v.z,
                    f[o + 6] = v.x,
                    f[o + 7] = v.y,
                    f[o + 8] = v.z;
                    this.normalizeNormals(),
                    e.normal.needsUpdate = true
                }
            },
            merge: function(t, e) {
                if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                undefined === e && (e = 0);
                var n = this.attributes;
                for (var i in n) if (undefined !== t.attributes[i]) for (var r = n[i], a = r.array, o = t.attributes[i], s = o.array, u = o.itemSize, c = 0, h = u * e; c < s.length; c++, h++) a[h] = s[c];
                return this
            },
            normalizeNormals: function() {
                for (var t, e, n, i, r = this.attributes.normal,
                a = 0,
                o = r.count; a < o; a++) t = r.getX(a),
                e = r.getY(a),
                n = r.getZ(a),
                i = 1 / Math.sqrt(t * t + e * e + n * n),
                r.setXYZ(a, t * i, e * i, n * i)
            },
            toNonIndexed: function() {
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
                var t = new i,
                e = this.index.array,
                n = this.attributes;
                for (var r in n) {
                    for (var a = n[r], o = a.array, u = a.itemSize, c = new o.constructor(e.length * u), h = 0, l = 0, f = 0, p = e.length; f < p; f++) {
                        h = e[f] * u;
                        for (var d = 0; d < u; d++) c[l++] = o[h++]
                    }
                    t.addAttribute(r, new s.a(c, u))
                }
                return t
            },
            toJSON: function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), undefined !== this.parameters) {
                    var e = this.parameters;
                    for (var n in e) undefined !== e[n] && (t[n] = e[n]);
                    return t
                }
                t.data = {
                    attributes: {}
                };
                var i = this.index;
                if (null !== i) {
                    var r = Array.prototype.slice.call(i.array);
                    t.data.index = {
                        type: i.array.constructor.name,
                        array: r
                    }
                }
                var a = this.attributes;
                for (var n in a) {
                    var o = a[n],
                    r = Array.prototype.slice.call(o.array);
                    t.data.attributes[n] = {
                        itemSize: o.itemSize,
                        type: o.array.constructor.name,
                        array: r,
                        normalized: o.normalized
                    }
                }
                var s = this.groups;
                s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                var u = this.boundingSphere;
                return null !== u && (t.data.boundingSphere = {
                    center: u.center.toArray(),
                    radius: u.radius
                }),
                t
            },
            clone: function() {
                return (new i).copy(this)
            },
            copy: function(t) {
                var e, n, i;
                this.index = null,
                this.attributes = {},
                this.morphAttributes = {},
                this.groups = [],
                this.boundingBox = null,
                this.boundingSphere = null,
                this.name = t.name;
                var r = t.index;
                null !== r && this.setIndex(r.clone());
                var a = t.attributes;
                for (e in a) {
                    var o = a[e];
                    this.addAttribute(e, o.clone())
                }
                var s = t.morphAttributes;
                for (e in s) {
                    var u = [],
                    c = s[e];
                    for (n = 0, i = c.length; n < i; n++) u.push(c[n].clone());
                    this.morphAttributes[e] = u
                }
                var h = t.groups;
                for (n = 0, i = h.length; n < i; n++) {
                    var l = h[n];
                    this.addGroup(l.start, l.count, l.materialIndex)
                }
                var f = t.boundingBox;
                null !== f && (this.boundingBox = f.clone());
                var p = t.boundingSphere;
                return null !== p && (this.boundingSphere = p.clone()),
                this.drawRange.start = t.drawRange.start,
                this.drawRange.count = t.drawRange.count,
                this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        })
    },
    Byt3: function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            this.binding = t,
            this.valueSize = n;
            var i, r = Float64Array;
            switch (e) {
            case "quaternion":
                i = this._slerp;
                break;
            case "string":
            case "bool":
                r = Array,
                i = this._select;
                break;
            default:
                i = this._lerp
            }
            this.buffer = new r(4 * n),
            this._mixBufferRegion = i,
            this.cumulativeWeight = 0,
            this.useCount = 0,
            this.referenceCount = 0
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Quaternion");
        Object.assign(i.prototype, {
            accumulate: function(t, e) {
                var n = this.buffer,
                i = this.valueSize,
                r = t * i + i,
                a = this.cumulativeWeight;
                if (0 === a) {
                    for (var o = 0; o !== i; ++o) n[r + o] = n[o];
                    a = e
                } else {
                    a += e;
                    var s = e / a;
                    this._mixBufferRegion(n, r, 0, s, i)
                }
                this.cumulativeWeight = a
            },
            apply: function(t) {
                var e = this.valueSize,
                n = this.buffer,
                i = t * e + e,
                r = this.cumulativeWeight,
                a = this.binding;
                if (this.cumulativeWeight = 0, r < 1) {
                    var o = 3 * e;
                    this._mixBufferRegion(n, i, o, 1 - r, e)
                }
                for (var s = e,
                u = e + e; s !== u; ++s) if (n[s] !== n[s + e]) {
                    a.setValue(n, i);
                    break
                }
            },
            saveOriginalState: function() {
                var t = this.binding,
                e = this.buffer,
                n = this.valueSize,
                i = 3 * n;
                t.getValue(e, i);
                for (var r = n,
                a = i; r !== a; ++r) e[r] = e[i + r % n];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                var t = 3 * this.valueSize;
                this.binding.setValue(this.buffer, t)
            },
            _select: function(t, e, n, i, r) {
                if (i >= .5) for (var a = 0; a !== r; ++a) t[e + a] = t[n + a]
            },
            _slerp: function(t, e, n, i) {
                r.a.slerpFlat(t, e, t, e, t, n, i)
            },
            _lerp: function(t, e, n, i, r) {
                for (var a = 1 - i,
                o = 0; o !== r; ++o) {
                    var s = e + o;
                    t[s] = t[s] * a + t[n + o] * i
                }
            }
        })
    },
    LineDashedMaterial: function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.type = "LineDashedMaterial",
            this.color = new a.a(16777215),
            this.linewidth = 1,
            this.scale = 1,
            this.dashSize = 3,
            this.gapSize = 1,
            this.lights = false,
            this.setValues(t)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Material"),
        a = n("Color");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isLineDashedMaterial = true,
        i.prototype.copy = function(t) {
            return r.a.prototype.copy.call(this, t),
            this.color.copy(t.color),
            this.linewidth = t.linewidth,
            this.scale = t.scale,
            this.dashSize = t.dashSize,
            this.gapSize = t.gapSize,
            this
        }
    },
    BzvE: function(t, e, n) {
        "use strict";

        function i() {}

        function r(t, e, n) {
            this.fn = t,
            this.context = e,
            this.once = n || false
        }

        function a() {
            this._events = new i,
            this._eventsCount = 0
        }
        var o = Object.prototype.hasOwnProperty,
        s = "~";
        Object.create && (i.prototype = Object.create(null), (new i).__proto__ || (s = false)),
        a.prototype.eventNames = function() {
            var t, e, n = [];
            if (0 === this._eventsCount) return n;
            for (e in t = this._events) o.call(t, e) && n.push(s ? e.slice(1) : e);
            return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(t)) : n
        },
        a.prototype.listeners = function(t, e) {
            var n = s ? s + t: t,
            i = this._events[n];
            if (e) return !! i;
            if (!i) return [];
            if (i.fn) return [i.fn];
            for (var r = 0,
            a = i.length,
            o = new Array(a); r < a; r++) o[r] = i[r].fn;
            return o
        },
        a.prototype.emit = function(t, e, n, i, r, a) {
            var o = s ? s + t: t;
            if (!this._events[o]) return ! 1;
            var u, c, h = this._events[o],
            l = arguments.length;
            if (h.fn) {
                switch (h.once && this.removeListener(t, h.fn, undefined, true), l) {
                case 1:
                    return h.fn.call(h.context),
                    true;
                case 2:
                    return h.fn.call(h.context, e),
                    true;
                case 3:
                    return h.fn.call(h.context, e, n),
                    true;
                case 4:
                    return h.fn.call(h.context, e, n, i),
                    true;
                case 5:
                    return h.fn.call(h.context, e, n, i, r),
                    true;
                case 6:
                    return h.fn.call(h.context, e, n, i, r, a),
                    true
                }
                for (c = 1, u = new Array(l - 1); c < l; c++) u[c - 1] = arguments[c];
                h.fn.apply(h.context, u)
            } else {
                var f, p = h.length;
                for (c = 0; c < p; c++) switch (h[c].once && this.removeListener(t, h[c].fn, undefined, true), l) {
                case 1:
                    h[c].fn.call(h[c].context);
                    break;
                case 2:
                    h[c].fn.call(h[c].context, e);
                    break;
                case 3:
                    h[c].fn.call(h[c].context, e, n);
                    break;
                case 4:
                    h[c].fn.call(h[c].context, e, n, i);
                    break;
                default:
                    if (!u) for (f = 1, u = new Array(l - 1); f < l; f++) u[f - 1] = arguments[f];
                    h[c].fn.apply(h[c].context, u)
                }
            }
            return ! 0
        },
        a.prototype.on = function(t, e, n) {
            var i = new r(e, n || this),
            a = s ? s + t: t;
            return this._events[a] ? this._events[a].fn ? this._events[a] = [this._events[a], i] : this._events[a].push(i) : (this._events[a] = i, this._eventsCount++),
            this
        },
        a.prototype.once = function(t, e, n) {
            var i = new r(e, n || this, true),
            a = s ? s + t: t;
            return this._events[a] ? this._events[a].fn ? this._events[a] = [this._events[a], i] : this._events[a].push(i) : (this._events[a] = i, this._eventsCount++),
            this
        },
        a.prototype.removeListener = function(t, e, n, r) {
            var a = s ? s + t: t;
            if (!this._events[a]) return this;
            if (!e) return 0 == --this._eventsCount ? this._events = new i: delete this._events[a],
            this;
            var o = this._events[a];
            if (o.fn) o.fn !== e || r && !o.once || n && o.context !== n || (0 == --this._eventsCount ? this._events = new i: delete this._events[a]);
            else {
                for (var u = 0,
                c = [], h = o.length; u < h; u++)(o[u].fn !== e || r && !o[u].once || n && o[u].context !== n) && c.push(o[u]);
                c.length ? this._events[a] = 1 === c.length ? c[0] : c: 0 == --this._eventsCount ? this._events = new i: delete this._events[a]
            }
            return this
        },
        a.prototype.removeAllListeners = function(t) {
            var e;
            return t ? (e = s ? s + t: t, this._events[e] && (0 == --this._eventsCount ? this._events = new i: delete this._events[e])) : (this._events = new i, this._eventsCount = 0),
            this
        },
        a.prototype.off = a.prototype.removeListener,
        a.prototype.addListener = a.prototype.on,
        a.prototype.setMaxListeners = function() {
            return this
        },
        a.prefixed = s,
        a.EventEmitter = a,
        t.exports = a
    },
    CJFc: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i; !
        function(t) {
            t[t.Roamer = 0] = "Roamer",
            t[t.View3D = 1] = "View3D"
        } (i || (i = {}))
    },
    CNFg: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return f
        });
        var i, r = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        a = n("PO9Y"),
        o = n("uiDP"),
        s = new r.I(0, 0),
        u = new r.J,
        c = new r.J,
        h = 89 / 180 * Math.PI,
        l = -89 / 180 * Math.PI; !
        function(t) {
            t[t.View3D = 0] = "View3D",
            t[t.Roamer = 1] = "Roamer"
        } (i || (i = {}));
        var f = function() {
            function t() {
                this.camera = null,
                this.updateCamera = true
            }
            return t.prototype.resize = function(t) {
                a.a.isPerspectiveCamera(this.camera) && (this.camera.aspect = t.width / t.height, this.camera.updateProjectionMatrix())
            },
            t.prototype.setViewer = function(t) {
                this.viewer = t;
                var e = t.getEngine();
                this.setCamera(e.camera);
                var n = e.camera;
                this.cameraState = new o.a,
                this.cameraState.up.copy(n.up),
                this.cameraState.position.copy(n.position),
                this.cameraState.target.copy(e.sceneDoc.scene.position),
                this.cameraState.copyProjection(n),
                this.setState(this.cameraState)
            },
            t.prototype.getState = function() {
                var t = new o.a;
                return t.position.copy(this.cameraState.position),
                t.target.copy(this.cameraState.target),
                t.up.copy(this.cameraState.up),
                t.copyProjection(this.camera),
                t
            },
            t.prototype.setState = function(t) {
                this.cameraState.copy(t),
                this.updateCamera && (this.camera.position.copy(t.position), this.camera.up.copy(t.up), this.camera.lookAt(t.target), t.setProjection(this.camera))
            },
            t.prototype.setCamera = function(t) {
                this.camera = t,
                window.camera = t
            },
            t.prototype.move = function(t) {
                var e = this.cameraState.position.clone().sub(this.cameraState.target),
                n = Math.atan2(e.y, e.x),
                i = new r.I( - t.y, -t.x).rotateAround(s, n);
                i.multiplyScalar(.001 * e.length()),
                u.copy(this.cameraState.position),
                u.x = u.x + i.x,
                u.y = u.y + i.y,
                c.copy(this.cameraState.target),
                c.x = c.x + i.x,
                c.y = c.y + i.y,
                this.cameraState.position.copy(u),
                this.cameraState.target.copy(c),
                this.setState(this.cameraState)
            },
            t.prototype.rotate = function(t) {
                var e = this.viewer.getSize(),
                n = t.x / e.width * Math.PI * 1,
                i = t.y / e.height * Math.PI * 1,
                a = this.cameraState.target.clone().sub(this.cameraState.position).normalize(),
                o = new r.I(a.x, a.y),
                s = Math.atan2(a.z, o.length()) + i;
                s = r.M.clamp(s, l, h);
                var c = o.angle() + n,
                f = 3e3 * Math.cos(s);
                u.z = 3e3 * Math.sin(s),
                u.x = f * Math.cos(c),
                u.y = f * Math.sin(c),
                this.cameraState.target.copy(u.add(this.camera.position)),
                this.setState(this.cameraState)
            },
            t.prototype.rotateAround = function(t) {
                var e = this.viewer.getSize(),
                n = -t.x / e.width * Math.PI * 2.5,
                i = t.y / e.height * Math.PI * 2.5,
                a = this.cameraState.position.clone().sub(this.cameraState.target),
                o = a.length(),
                s = new r.I(a.x, a.y),
                c = Math.atan2(a.z, s.length()) + i;
                c = r.M.clamp(c, l, h);
                var f = s.angle() + n,
                p = o * Math.cos(c);
                u.z = o * Math.sin(c),
                u.x = p * Math.cos(f),
                u.y = p * Math.sin(f),
                this.cameraState.position.copy(u.add(this.cameraState.target)),
                this.setState(this.cameraState)
            },
            t.prototype.zoom = function(t) {
                var e = this.cameraState.position.clone().sub(this.cameraState.target);
                u.copy(e.multiplyScalar(t)),
                this.cameraState.position.copy(u.add(this.cameraState.target)),
                this.setState(this.cameraState)
            },
            t.prototype.moveUp = function(t) {
                this.cameraState.position.z += t,
                this.cameraState.target.z += t,
                this.setState(this.cameraState)
            },
            t.prototype.tweenState = function(t, e, n) {
                var i = this,
                r = (new o.a).copy(t),
                a = 0,
                s = function o() {
                    a < 45 ? (r.interpolate(t, e, a / 45), i.setState(r), requestAnimationFrame(o), ++a) : n()
                };
                requestAnimationFrame(s)
            },
            t
        } ()
    },
    CPX2: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return c
        });
        var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        r = n("TQJV"),
        a = n("07ZH"),
        o = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        s = new i.I,
        u = new i.I,
        c = function(t) {
            function e() {
                return t.call(this) || this
            }
            return o(e, t),
            e.prototype.activate = function(e) {
                if (undefined === e && (e = true), t.prototype.activate.call(this), e) {
                    var n = this.controller.getState(),
                    i = n.clone();
                    i.position.copy(n.target),
                    i.target.sub(n.position).setZ(0).add(n.target),
                    this.controller.tweenState(n, i)
                }
            },
            e.prototype.keyDown = function(t) {
                t === r.a.W && this.controller.move(s.set(0, -4)),
                t === r.a.S && this.controller.move(s.set(0, 4)),
                t === r.a.A && this.controller.move(s.set( - 4, 0)),
                t === r.a.D && this.controller.move(s.set(4, 0)),
                t === r.a.ARROW_UP && this.controller.rotate(u.set(0, -4)),
                t === r.a.ARROW_DOWN && this.controller.rotate(u.set(0, 4)),
                t === r.a.ARROW_LEFT && this.controller.rotate(u.set(4, 0)),
                t === r.a.ARROW_RIGHT && this.controller.rotate(u.set( - 4, 0)),
                t !== r.a.Q && t !== r.a.E || this.keyQEDown(t === r.a.Q)
            },
            e.prototype.leftMouseMove = function(t) {
                t.y *= -1,
                this.controller.rotate(t)
            },
            e.prototype.keyQEDown = function(t) {
                var e = t ? 100 : -100;
                this.controller.moveUp(e)
            },
            e
        } (a.a)
    },
    CSxx: function(t, e, n) {
        "use strict";

        function i(t, e, n, i, d, m) {
            u.a.call(this),
            undefined === i && (i = 16776960),
            undefined === n && (n = 1),
            undefined === d && (d = .2 * n),
            undefined === m && (m = .2 * d),
            undefined === r && (r = new s.a, r.addAttribute("position", new o.b([0, 0, 0, 0, 1, 0], 3)), a = new c.a(0, .5, 1, 5, 1), a.translate(0, -.5, 0)),
            this.position.copy(e),
            this.line = new p.a(r, new l.a({
                color: i
            })),
            this.line.matrixAutoUpdate = false,
            this.add(this.line),
            this.cone = new f.a(a, new h.a({
                color: i
            })),
            this.cone.matrixAutoUpdate = false,
            this.add(this.cone),
            this.setDirection(t),
            this.setLength(n, d, m)
        }
        var r, a, o = n("BufferAttribute"),
        s = n("BufferGeometry"),
        u = n("Object3D"),
        c = n("CylinderGeometry||CylinderBufferGeometry"),
        h = n("MeshBasicMaterial"),
        l = n("LineBasicMaterial"),
        f = n("Mesh"),
        p = n("Line"),
        d = n("Vector3");
        i.prototype = Object.create(u.a.prototype),
        i.prototype.constructor = i,
        i.prototype.setDirection = function() {
            var t, e = new d.a;
            return function(n) {
                n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
            }
        } (),
        i.prototype.setLength = function(t, e, n) {
            undefined === e && (e = .2 * t),
            undefined === n && (n = .2 * e),
            this.line.scale.set(1, Math.max(0, t - e), 1),
            this.line.updateMatrix(),
            this.cone.scale.set(n, e, n),
            this.cone.position.y = t,
            this.cone.updateMatrix()
        },
        i.prototype.setColor = function(t) {
            this.line.material.color.copy(t),
            this.cone.material.color.copy(t)
        }
    },
    Cd7q: function(t, e, n) {
        "use strict";
        e.a = "struct PhysicalMaterial {\\n\\tvec3\\tdiffuseColor;\\n\\tfloat\\tspecularRoughness;\\n\\tvec3\\tspecularColor;\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoat;\\n\\t\\tfloat clearCoatRoughness;\\n\\t#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t\\tvec3 normal = geometry.normal;\\n\\t\\tvec3 viewDir = geometry.viewDir;\\n\\t\\tvec3 position = geometry.position;\\n\\t\\tvec3 lightPos = rectAreaLight.position;\\n\\t\\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\\t\\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\\t\\tvec3 lightColor = rectAreaLight.color;\\n\\t\\tfloat roughness = material.specularRoughness;\\n\\t\\tvec3 rectCoords[ 4 ];\\n\\t\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\t\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\n\\t\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\n\\t\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\n\\t\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\\t\\tfloat norm = texture2D( ltcMag, uv ).a;\\n\\t\\tvec4 t = texture2D( ltcMat, uv );\\n\\t\\tmat3 mInv = mat3(\\n\\t\\t\\tvec3(   1,   0, t.y ),\\n\\t\\t\\tvec3(   0, t.z,   0 ),\\n\\t\\t\\tvec3( t.w,   0, t.x )\\n\\t\\t);\\n\\t\\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\\t\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\\n\\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\\tvec3 irradiance = dotNL * directLight.color;\\n\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\\t\\tirradiance *= PI;\\n\\t#endif\\n\\t#ifndef STANDARD\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\\t#ifndef STANDARD\\n\\t\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\t\\tfloat dotNL = dotNV;\\n\\t\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\n\\t#else\\n\\t\\tfloat clearCoatDHR = 0.0;\\n\\t#endif\\n\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n\\t#ifndef STANDARD\\n\\t\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\n\\t#endif\\n}\\n#define RE_Direct\\t\\t\\t\\tRE_Direct_Physical\\n#define RE_Direct_RectArea\\t\\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\\t\\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\\t\\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n"
    },
    ChZQ: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return i
        });
        var i; !
        function(t) {
            t[t.SHADING = 0] = "SHADING",
            t[t.OUTLINE_ONLY = 1] = "OUTLINE_ONLY",
            t[t.OUTLINE_WITH_SHADING = 2] = "OUTLINE_WITH_SHADING"
        } (i || (i = {}))
    },
    ExtrudeGeometry: function(t, e, n) {
        "use strict";

        function i(t, e) {
            a.a.call(this),
            this.type = "ExtrudeGeometry",
            this.parameters = {
                shapes: t,
                options: e
            },
            this.fromBufferGeometry(new r(t, e)),
            this.mergeVertices()
        }

        function r(t, e) {
            undefined !== t && (o.a.call(this), this.type = "ExtrudeBufferGeometry", t = Array.isArray(t) ? t: [t], this.addShapeList(t, e), this.computeVertexNormals())
        }
        n.d(e, "a",
        function() {
            return r
        });
        var a = n("Geometry"),
        o = n("BufferGeometry"),
        s = n("BufferAttribute"),
        u = n("Vector2"),
        c = n("Vector3"),
        h = n("f7ra");
        i.prototype = Object.create(a.a.prototype),
        i.prototype.constructor = i,
        r.prototype = Object.create(o.a.prototype),
        r.prototype.constructor = r,
        r.prototype.getArrays = function() {
            var t = this.getAttribute("position"),
            e = t ? Array.prototype.slice.call(t.array) : [],
            n = this.getAttribute("uv"),
            i = n ? Array.prototype.slice.call(n.array) : [],
            r = this.index;
            return {
                position: e,
                uv: i,
                index: r ? Array.prototype.slice.call(r.array) : []
            }
        },
        r.prototype.addShapeList = function(t, e) {
            var n = t.length;
            e.arrays = this.getArrays();
            for (var i = 0; i < n; i++) {
                var r = t[i];
                this.addShape(r, e)
            }
            this.setIndex(e.arrays.index),
            this.addAttribute("position", new s.b(e.arrays.position, 3)),
            this.addAttribute("uv", new s.b(e.arrays.uv, 2))
        },
        r.prototype.addShape = function(t, e) {
            function n(t, e, n) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                e.clone().multiplyScalar(n).add(t)
            }

            function r(t, e, n) {
                var i, r, a, o = t.x - e.x,
                s = t.y - e.y,
                c = n.x - t.x,
                h = n.y - t.y,
                l = o * o + s * s,
                f = o * h - s * c;
                if (Math.abs(f) > Number.EPSILON) {
                    var p = Math.sqrt(l),
                    d = Math.sqrt(c * c + h * h),
                    m = e.x - s / p,
                    v = e.y + o / p,
                    g = n.x - h / d,
                    y = n.y + c / d,
                    _ = ((g - m) * h - (y - v) * c) / (o * h - s * c);
                    i = m + o * _ - t.x,
                    r = v + s * _ - t.y;
                    var x = i * i + r * r;
                    if (x <= 2) return new u.a(i, r);
                    a = Math.sqrt(x / 2)
                } else {
                    var b = false;
                    o > Number.EPSILON ? c > Number.EPSILON && (b = true) : o < -Number.EPSILON ? c < -Number.EPSILON && (b = true) : Math.sign(s) === Math.sign(h) && (b = true),
                    b ? (i = -s, r = o, a = Math.sqrt(l)) : (i = o, r = s, a = Math.sqrt(l / 2))
                }
                return new u.a(i / a, r / a)
            }

            function a(t, e) {
                var n, i;
                for ($ = t.length; --$ >= 0;) {
                    n = $,
                    i = $ - 1,
                    i < 0 && (i = t.length - 1);
                    var r = 0,
                    a = R + 2 * C;
                    for (r = 0; r < a; r++) {
                        var o = J * r,
                        s = J * (r + 1);
                        f(e + n + o, e + i + o, e + i + s, e + n + s, t, r, a, n, i)
                    }
                }
            }

            function o(t, e, n) {
                S.push(t),
                S.push(e),
                S.push(n)
            }

            function l(t, e, n) {
                p(t),
                p(e),
                p(n);
                var i = b.length / 3,
                r = N.generateTopUV(z, b, i - 3, i - 2, i - 1);
                d(r[0]),
                d(r[1]),
                d(r[2])
            }

            function f(t, e, n, i, r, a, o, s, u) {
                p(t),
                p(e),
                p(i),
                p(e),
                p(n),
                p(i);
                var c = b.length / 3,
                h = N.generateSideWallUV(z, b, c - 6, c - 3, c - 2, c - 1);
                d(h[0]),
                d(h[1]),
                d(h[3]),
                d(h[1]),
                d(h[2]),
                d(h[3])
            }

            function p(t) {
                w.push(b.length / 3),
                b.push(S[3 * t + 0]),
                b.push(S[3 * t + 1]),
                b.push(S[3 * t + 2])
            }

            function d(t) {
                M.push(t.x),
                M.push(t.y)
            }
            var m, v, g, y, _, x = e.arrays ? e.arrays: this.getArrays(),
            b = x.position,
            w = x.index,
            M = x.uv,
            S = [],
            E = undefined !== e.amount ? e.amount: 100,
            T = undefined !== e.bevelThickness ? e.bevelThickness: 6,
            A = undefined !== e.bevelSize ? e.bevelSize: T - 2,
            C = undefined !== e.bevelSegments ? e.bevelSegments: 3,
            P = undefined === e.bevelEnabled || e.bevelEnabled,
            L = undefined !== e.curveSegments ? e.curveSegments: 12,
            R = undefined !== e.steps ? e.steps: 1,
            I = e.extrudePath,
            O = false,
            N = undefined !== e.UVGenerator ? e.UVGenerator: i.WorldUVGenerator;
            I && (m = I.getSpacedPoints(R), O = true, P = false, v = undefined !== e.frames ? e.frames: I.computeFrenetFrames(R, false), g = new c.a, y = new c.a, _ = new c.a),
            P || (C = 0, T = 0, A = 0);
            var D, U, B, z = this,
            F = t.extractPoints(L),
            j = F.shape,
            k = F.holes;
            if (!h.a.isClockWise(j)) for (j = j.reverse(), U = 0, B = k.length; U < B; U++) D = k[U],
            h.a.isClockWise(D) && (k[U] = D.reverse());
            var V = h.a.triangulateShape(j, k),
            G = j;
            for (U = 0, B = k.length; U < B; U++) D = k[U],
            j = j.concat(D);
            for (var H, W, X, q, Y, Z, J = j.length,
            Q = V.length,
            K = [], $ = 0, tt = G.length, et = tt - 1, nt = $ + 1; $ < tt; $++, et++, nt++) et === tt && (et = 0),
            nt === tt && (nt = 0),
            K[$] = r(G[$], G[et], G[nt]);
            var it, rt = [],
            at = K.concat();
            for (U = 0, B = k.length; U < B; U++) {
                for (D = k[U], it = [], $ = 0, tt = D.length, et = tt - 1, nt = $ + 1; $ < tt; $++, et++, nt++) et === tt && (et = 0),
                nt === tt && (nt = 0),
                it[$] = r(D[$], D[et], D[nt]);
                rt.push(it),
                at = at.concat(it)
            }
            for (H = 0; H < C; H++) {
                for (X = H / C, q = T * Math.cos(X * Math.PI / 2), W = A * Math.sin(X * Math.PI / 2), $ = 0, tt = G.length; $ < tt; $++) Y = n(G[$], K[$], W),
                o(Y.x, Y.y, -q);
                for (U = 0, B = k.length; U < B; U++) for (D = k[U], it = rt[U], $ = 0, tt = D.length; $ < tt; $++) Y = n(D[$], it[$], W),
                o(Y.x, Y.y, -q)
            }
            for (W = A, $ = 0; $ < J; $++) Y = P ? n(j[$], at[$], W) : j[$],
            O ? (y.copy(v.normals[0]).multiplyScalar(Y.x), g.copy(v.binormals[0]).multiplyScalar(Y.y), _.copy(m[0]).add(y).add(g), o(_.x, _.y, _.z)) : o(Y.x, Y.y, 0);
            var ot;
            for (ot = 1; ot <= R; ot++) for ($ = 0; $ < J; $++) Y = P ? n(j[$], at[$], W) : j[$],
            O ? (y.copy(v.normals[ot]).multiplyScalar(Y.x), g.copy(v.binormals[ot]).multiplyScalar(Y.y), _.copy(m[ot]).add(y).add(g), o(_.x, _.y, _.z)) : o(Y.x, Y.y, E / R * ot);
            for (H = C - 1; H >= 0; H--) {
                for (X = H / C, q = T * Math.cos(X * Math.PI / 2), W = A * Math.sin(X * Math.PI / 2), $ = 0, tt = G.length; $ < tt; $++) Y = n(G[$], K[$], W),
                o(Y.x, Y.y, E + q);
                for (U = 0, B = k.length; U < B; U++) for (D = k[U], it = rt[U], $ = 0, tt = D.length; $ < tt; $++) Y = n(D[$], it[$], W),
                O ? o(Y.x, Y.y + m[R - 1].y, m[R - 1].x + q) : o(Y.x, Y.y, E + q)
            } !
            function() {
                var t = b.length / 3;
                if (P) {
                    var n = 0,
                    i = J * n;
                    for ($ = 0; $ < Q; $++) Z = V[$],
                    l(Z[2] + i, Z[1] + i, Z[0] + i);
                    for (n = R + 2 * C, i = J * n, $ = 0; $ < Q; $++) Z = V[$],
                    l(Z[0] + i, Z[1] + i, Z[2] + i)
                } else {
                    for ($ = 0; $ < Q; $++) Z = V[$],
                    l(Z[2], Z[1], Z[0]);
                    for ($ = 0; $ < Q; $++) Z = V[$],
                    l(Z[0] + J * R, Z[1] + J * R, Z[2] + J * R)
                }
                z.addGroup(t, b.length / 3 - t, undefined !== e.material ? e.material: 0)
            } (),
            function() {
                var t = b.length / 3,
                n = 0;
                for (a(G, n), n += G.length, U = 0, B = k.length; U < B; U++) D = k[U],
                a(D, n),
                n += D.length;
                z.addGroup(t, b.length / 3 - t, undefined !== e.extrudeMaterial ? e.extrudeMaterial: 1)
            } (),
            e.arrays || (this.setIndex(w), this.addAttribute("position", new s.b(b, 3)), this.addAttribute("uv", new s.b(e.arrays.uv, 2)))
        },
        i.WorldUVGenerator = {
            generateTopUV: function(t, e, n, i, r) {
                var a = e[3 * n],
                o = e[3 * n + 1],
                s = e[3 * i],
                c = e[3 * i + 1],
                h = e[3 * r],
                l = e[3 * r + 1];
                return [new u.a(a, o), new u.a(s, c), new u.a(h, l)]
            },
            generateSideWallUV: function(t, e, n, i, r, a) {
                var o = e[3 * n],
                s = e[3 * n + 1],
                c = e[3 * n + 2],
                h = e[3 * i],
                l = e[3 * i + 1],
                f = e[3 * i + 2],
                p = e[3 * r],
                d = e[3 * r + 1],
                m = e[3 * r + 2],
                v = e[3 * a],
                g = e[3 * a + 1],
                y = e[3 * a + 2];
                return Math.abs(s - l) < .01 ? [new u.a(o, 1 - c), new u.a(h, 1 - f), new u.a(p, 1 - m), new u.a(v, 1 - y)] : [new u.a(s, 1 - c), new u.a(l, 1 - f), new u.a(d, 1 - m), new u.a(g, 1 - y)]
            }
        }
    },
    "D+VX": function(t, e, n) {
        "use strict";
        e.a = "varying vec2 vUv;\\nuniform vec2 texelSize;\\nuniform sampler2D sourceMap;\\nvoid main() {\\n    vec3 color = vec3(0.0);\\n    color += texture2D(sourceMap, vUv + texelSize * vec2(0.0, 0.0)).rgb;\\n    color += texture2D(sourceMap, vUv + texelSize * vec2(1.0, 0.0)).rgb;\\n    color += texture2D(sourceMap, vUv + texelSize * vec2(0.0, 1.0)).rgb;\\n    color += texture2D(sourceMap, vUv + texelSize * vec2(1.0, 1.0)).rgb;\\n    color *= 0.25;\\n    gl_FragColor = vec4(color, 1.0);\\n}\\n"
    },
    PopPhongMaterial: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return p
        });
        var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        r = n("R+Hm"),
        a = n("9aRV"),
        o = n("DtoS"),
        s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ?
        function(t) {
            return typeof t
        }: function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol": typeof t
        },
        u = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        c = this && this.__decorate ||
        function(t, e, n, i) {
            var r, a = arguments.length,
            o = a < 3 ? e: null === i ? i = Object.getOwnPropertyDescriptor(e, n) : i;
            if ("object" === ("undefined" == typeof Reflect ? "undefined": s(Reflect)) && "function" == typeof Reflect.decorate) o = Reflect.decorate(t, e, n, i);
            else for (var u = t.length - 1; u >= 0; u--)(r = t[u]) && (o = (a < 3 ? r(o) : a > 3 ? r(e, n, o) : r(e, n)) || o);
            return a > 3 && o && Object.defineProperty(e, n, o),
            o
        },
        h = {
            uvMatrix: {
                value: null
            },
            vertexConstant: {
                value: new i.J(0, 0, 0)
            },
            vertexParameters: {
                value: new i.I(0, 0)
            }
        },
        l = o.b.getDefineToggle(),
        f = o.b.getUniformMapping(),
        p = function(t) {
            function e(e) {
                var n = t.call(this, {
                    vertexShader: a.a,
                    fragmentShader: r.a,
                    uniforms: o.b.cloneUniforms(h)
                }) || this;
                return n.uvMatrix = null,
                e && n.setValues(e),
                n
            }
            return u(e, t),
            e.prototype.copy = function(e) {
                return t.prototype.copy.call(this, e),
                this.uvMatrix = e.uvMatrix,
                this
            },
            e.prototype.myStringfy = function(t) {
                return {
                    r: t.r,
                    g: t.g,
                    b: t.b
                }
            },
            e.prototype.toJSON = function(t) {
                var e = {};
                return e.uuid = this.uuid,
                e.name = this.name,
                e.diffuseTextureUrl = this.diffuseTextureUrl,
                e.map = null,
                e.opacity = this.uniforms.opacity.value,
                e.color = this.myStringfy(this.uniforms.diffuse.value),
                this.uniforms.map && this.uniforms.map.value && (e.map = this.uniforms.map.value.toJSON(t).uuid),
                e
            },
            c([l("USE_UV_MATRIX"), f()], e.prototype, "uvMatrix", undefined),
            c([f()], e.prototype, "vertexConstant", undefined),
            c([f()], e.prototype, "vertexParameters", undefined),
            e
        } (o.a)
    },
    Camera: function(t, e, n) {
        "use strict";

        function i() {
            o.a.call(this),
            this.type = "Camera",
            this.matrixWorldInverse = new r.a,
            this.projectionMatrix = new r.a
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Matrix4"),
        a = n("Quaternion"),
        o = n("Object3D"),
        s = n("Vector3");
        i.prototype = Object.assign(Object.create(o.a.prototype), {
            constructor: i,
            isCamera: true,
            copy: function(t, e) {
                return o.a.prototype.copy.call(this, t, e),
                this.matrixWorldInverse.copy(t.matrixWorldInverse),
                this.projectionMatrix.copy(t.projectionMatrix),
                this
            },
            getWorldDirection: function() {
                var t = new a.a;
                return function(e) {
                    var n = e || new s.a;
                    return this.getWorldQuaternion(t),
                    n.set(0, 0, -1).applyQuaternion(t)
                }
            } (),
            updateMatrixWorld: function(t) {
                o.a.prototype.updateMatrixWorld.call(this, t),
                this.matrixWorldInverse.getInverse(this.matrixWorld)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        })
    },
    TubeGeometry||TubeBufferGeometry: function(t, e, n) {
        "use strict";

        function i(t, e, n, i, o, s) {
            a.a.call(this),
            this.type = "TubeGeometry",
            this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: i,
                closed: o
            },
            undefined !== s && console.warn("THREE.TubeGeometry: taper has been removed.");
            var u = new r(t, e, n, i, o);
            this.tangents = u.tangents,
            this.normals = u.normals,
            this.binormals = u.binormals,
            this.fromBufferGeometry(u),
            this.mergeVertices()
        }

        function r(t, e, n, i, r) {
            function a(r) {
                var a = t.getPointAt(r / e),
                o = f.normals[r],
                s = f.binormals[r];
                for (d = 0; d <= i; d++) {
                    var u = d / i * Math.PI * 2,
                    c = Math.sin(u),
                    h = -Math.cos(u);
                    v.x = h * o.x + c * s.x,
                    v.y = h * o.y + c * s.y,
                    v.z = h * o.z + c * s.z,
                    v.normalize(),
                    _.push(v.x, v.y, v.z),
                    m.x = a.x + n * v.x,
                    m.y = a.y + n * v.y,
                    m.z = a.z + n * v.z,
                    y.push(m.x, m.y, m.z)
                }
            }

            function h() {
                for (d = 1; d <= e; d++) for (p = 1; p <= i; p++) {
                    var t = (i + 1) * (d - 1) + (p - 1),
                    n = (i + 1) * d + (p - 1),
                    r = (i + 1) * d + p,
                    a = (i + 1) * (d - 1) + p;
                    b.push(t, n, a),
                    b.push(n, r, a)
                }
            }

            function l() {
                for (p = 0; p <= e; p++) for (d = 0; d <= i; d++) g.x = p / e,
                g.y = d / i,
                x.push(g.x, g.y)
            }
            o.a.call(this),
            this.type = "TubeBufferGeometry",
            this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: i,
                closed: r
            },
            e = e || 64,
            n = n || 1,
            i = i || 8,
            r = r || false;
            var f = t.computeFrenetFrames(e, r);
            this.tangents = f.tangents,
            this.normals = f.normals,
            this.binormals = f.binormals;
            var p, d, m = new c.a,
            v = new c.a,
            g = new u.a,
            y = [],
            _ = [],
            x = [],
            b = []; !
            function() {
                for (p = 0; p < e; p++) a(p);
                a(false === r ? e: 0),
                l(),
                h()
            } (),
            this.setIndex(b),
            this.addAttribute("position", new s.b(y, 3)),
            this.addAttribute("normal", new s.b(_, 3)),
            this.addAttribute("uv", new s.b(x, 2))
        }
        var a = n("Geometry"),
        o = n("BufferGeometry"),
        s = n("BufferAttribute"),
        u = n("Vector2"),
        c = n("Vector3");
        i.prototype = Object.create(a.a.prototype),
        i.prototype.constructor = i,
        r.prototype = Object.create(o.a.prototype),
        r.prototype.constructor = r
    },
    PopModel: function(t, e, n) {
        "use strict";

        function i(t) {
            if (!h.includes(t)) throw new l(t)
        }

        function r(t) {
            return t > 65535 ? Uint32Array: Uint16Array
        }
        n.d(e, "a",
        function() {
            return f
        });
        var a = n("PopModelItem1"),
        o = n("PopModelData"),
        s = n("PopModelBlock"),
        u = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        c = this && this.__assign || Object.assign ||
        function(t) {
            for (var e, n = 1,
            i = arguments.length; n < i; n++) {
                e = arguments[n];
                for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r])
            }
            return t
        },
        h = [0, 1],
        l = function(t) {
            function e(e) {
                return t.call(this, "Unknown popbuffer version: " + e) || this
            }
            return u(e, t),
            e
        } (Error),
        f = function() {
            function t(t) {
                this.version = t.version,
                this.attributes = c({},
                t.attributes),
                this.initialize(),
                i(this.version)
            }
            return t.prototype.initialize = function() {
                var t = this.attributes,
                e = t.faceCount,
                n = t.vertexCount,
                i = t.blockNames,
                a = t.blockFaceCounts,
                o = r(n - 1);
                this.indices = new o(3 * e),
                this.vertices = new Float32Array(3 * n),
                this.normals = new Float32Array(3 * n),
                this.textures = new Float32Array(2 * n);
                var u = 0;
                this.blocks = i.map(function(t, e) {
                    var n = u,
                    i = 3 * a[e];
                    return u += i,
                    new PopModelBlock(e, t, n, i)
                }),
                this.levelPrecisions = [],
                this.currentVertexCount = 0,
                this.currentBlockFaceCounts = new Array(i.length).fill(0)
            },
            t.prototype.addGroup = function(t) {
                var e = this,
                n = t.chunks,
                i = new Array(this.blocks.length).fill(0);
                n.forEach(function(t) {
                    var n = t.content,
                    r = t.header.objIndex,
                    a = n.indices,
                    o = e.processNormals(n.normals),
                    s = e.processTextures(n.textures),
                    u = e.processMaxLevelVertices(n.vertices),
                    c = e.blocks[r],
                    h = e.currentVertexCount,
                    l = e.currentBlockFaceCounts[r],
                    f = a.length / 3,
                    p = u.length / 3;
                    e.vertices.set(u, 3 * h),
                    e.normals.set(o, 3 * h),
                    e.textures.set(s, 2 * h),
                    e.indices.set(a, c.start + 3 * l),
                    e.currentBlockFaceCounts[r] += f,
                    e.currentVertexCount += p,
                    i[r] += f
                }),
                this.blocks.forEach(function(t, e) {
                    t.levelFaceCounts.push(i[e])
                });
                var r = this.levelPrecisions.length + 1 === this.attributes.groupCount,
                a = r ? 0 : Math.max(1, t.minLevel) - 1;
                this.levelPrecisions.push(a)
            },
            t.prototype.processNormals = function(t) {
                for (var e = this.attributes.normalScale,
                n = 0; n < t.length; n++) t[n] /= e;
                return t
            },
            t.prototype.processTextures = function(t) {
                for (var e = this.attributes.textureScale,
                n = 0; n < t.length; n++) t[n] /= e;
                return t
            },
            t.prototype.processMaxLevelVertices = function(t) {
                for (var e = this.attributes,
                n = e.vertexGridSize,
                i = e.boxMin,
                r = 0; r < t.length; r += 3) t[r] = (t[r] + .5) * n + i.x,
                t[r + 1] = (t[r + 1] + .5) * n + i.y,
                t[r + 2] = (t[r + 2] + .5) * n + i.z;
                return t
            },
            t.decode = function(e) {
                var n = new Uint8Array(e),
                i = new PopModelItem1();
                i.readFromStream(new PopModelData(n));
                var r = new PopModel(i.header);
                return i.groups.forEach(function(t) {
                    return r.addGroup(t)
                }),
                r
            },
            t
        } ()
    },
    DsDr: function(t, e, n) {
        "use strict";
        e.a = "#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <lights_lambert_vertex>\\n\\t#include <shadowmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n"
    },
    DtoS: function(t, e, n) {
        "use strict";
        var i = n("POlw");
        n.d(e, "b",
        function() {
            return i.a
        });
        var r = n("gukr");
        n.d(e, "a",
        function() {
            return r.a
        })
    },
    DuR2: function(t, e) {
        var n;
        n = function() {
            return this
        } ();
        try {
            n = n || Function("return this")() || (0, eval)("this")
        } catch(t) {
            "object" == typeof window && (n = window)
        }
        t.exports = n
    },
    E2bl: function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            a.a.call(this, t, e, n, i),
            this._weightPrev = -0,
            this._offsetPrev = -0,
            this._weightNext = -0,
            this._offsetNext = -0
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("RBSo"),
        a = n("R+5/");
        i.prototype = Object.assign(Object.create(a.a.prototype), {
            constructor: i,
            DefaultSettings_: {
                endingStart: r._62,
                endingEnd: r._62
            },
            intervalChanged_: function(t, e, n) {
                var i = this.parameterPositions,
                a = t - 2,
                o = t + 1,
                s = i[a],
                u = i[o];
                if (undefined === s) switch (this.getSettings_().endingStart) {
                case r._64:
                    a = t,
                    s = 2 * e - n;
                    break;
                case r._61:
                    a = i.length - 2,
                    s = e + i[a] - i[a + 1];
                    break;
                default:
                    a = t,
                    s = n
                }
                if (undefined === u) switch (this.getSettings_().endingEnd) {
                case r._64:
                    o = t,
                    u = 2 * n - e;
                    break;
                case r._61:
                    o = 1,
                    u = n + i[1] - i[0];
                    break;
                default:
                    o = t - 1,
                    u = e
                }
                var c = .5 * (n - e),
                h = this.valueSize;
                this._weightPrev = c / (e - s),
                this._weightNext = c / (u - n),
                this._offsetPrev = a * h,
                this._offsetNext = o * h
            },
            interpolate_: function(t, e, n, i) {
                for (var r = this.resultBuffer,
                a = this.sampleValues,
                o = this.valueSize,
                s = t * o,
                u = s - o,
                c = this._offsetPrev,
                h = this._offsetNext,
                l = this._weightPrev,
                f = this._weightNext,
                p = (n - e) / (i - e), d = p * p, m = d * p, v = -l * m + 2 * l * d - l * p, g = (1 + l) * m + ( - 1.5 - 2 * l) * d + ( - .5 + l) * p + 1, y = ( - 1 - f) * m + (1.5 + f) * d + .5 * p, _ = f * m - f * d, x = 0; x !== o; ++x) r[x] = v * a[c + x] + g * a[u + x] + y * a[s + x] + _ * a[h + x];
                return r
            }
        })
    },
    Ee7l: function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            this.a = undefined !== t ? t: new r.a,
            this.b = undefined !== e ? e: new r.a,
            this.c = undefined !== n ? n: new r.a
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Vector3"),
        a = n("yErb"),
        o = n("Plane");
        Object.assign(i, {
            normal: function() {
                var t = new r.a;
                return function(e, n, i, a) {
                    var o = a || new r.a;
                    o.subVectors(i, n),
                    t.subVectors(e, n),
                    o.cross(t);
                    var s = o.lengthSq();
                    return s > 0 ? o.multiplyScalar(1 / Math.sqrt(s)) : o.set(0, 0, 0)
                }
            } (),
            barycoordFromPoint: function() {
                var t = new r.a,
                e = new r.a,
                n = new r.a;
                return function(i, a, o, s, u) {
                    t.subVectors(s, a),
                    e.subVectors(o, a),
                    n.subVectors(i, a);
                    var c = t.dot(t),
                    h = t.dot(e),
                    l = t.dot(n),
                    f = e.dot(e),
                    p = e.dot(n),
                    d = c * f - h * h,
                    m = u || new r.a;
                    if (0 === d) return m.set( - 2, -1, -1);
                    var v = 1 / d,
                    g = (f * l - h * p) * v,
                    y = (c * p - h * l) * v;
                    return m.set(1 - g - y, y, g)
                }
            } (),
            containsPoint: function() {
                var t = new r.a;
                return function(e, n, r, a) {
                    var o = i.barycoordFromPoint(e, n, r, a, t);
                    return o.x >= 0 && o.y >= 0 && o.x + o.y <= 1
                }
            } ()
        }),
        Object.assign(i.prototype, {
            set: function(t, e, n) {
                return this.a.copy(t),
                this.b.copy(e),
                this.c.copy(n),
                this
            },
            setFromPointsAndIndices: function(t, e, n, i) {
                return this.a.copy(t[e]),
                this.b.copy(t[n]),
                this.c.copy(t[i]),
                this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.a.copy(t.a),
                this.b.copy(t.b),
                this.c.copy(t.c),
                this
            },
            area: function() {
                var t = new r.a,
                e = new r.a;
                return function() {
                    return t.subVectors(this.c, this.b),
                    e.subVectors(this.a, this.b),
                    .5 * t.cross(e).length()
                }
            } (),
            midpoint: function(t) {
                return (t || new r.a).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            normal: function(t) {
                return i.normal(this.a, this.b, this.c, t)
            },
            plane: function(t) {
                return (t || new o.a).setFromCoplanarPoints(this.a, this.b, this.c)
            },
            barycoordFromPoint: function(t, e) {
                return i.barycoordFromPoint(t, this.a, this.b, this.c, e)
            },
            containsPoint: function(t) {
                return i.containsPoint(t, this.a, this.b, this.c)
            },
            closestPointToPoint: function() {
                var t = new o.a,
                e = [new a.a, new a.a, new a.a],
                n = new r.a,
                i = new r.a;
                return function(a, o) {
                    var s = o || new r.a,
                    u = 1 / 0;
                    if (t.setFromCoplanarPoints(this.a, this.b, this.c), t.projectPoint(a, n), true === this.containsPoint(n)) s.copy(n);
                    else {
                        e[0].set(this.a, this.b),
                        e[1].set(this.b, this.c),
                        e[2].set(this.c, this.a);
                        for (var c = 0; c < e.length; c++) {
                            e[c].closestPointToPoint(n, true, i);
                            var h = n.distanceToSquared(i);
                            h < u && (u = h, s.copy(i))
                        }
                    }
                    return s
                }
            } (),
            equals: function(t) {
                return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            }
        })
    },
    OrthographicCamera: function(t, e, n) {
        "use strict";

        function OrthographicCamera(t, e, n, i, a, o) {
            r.a.call(this),
            this.type = "OrthographicCamera",
            this.zoom = 1,
            this.view = null,
            this.left = t,
            this.right = e,
            this.top = n,
            this.bottom = i,
            this.near = undefined !== a ? a: .1,
            this.far = undefined !== o ? o: 2e3,
            this.updateProjectionMatrix()
        }
        n.d(e, "a",
        function() {
            return OrthographicCamera
        });
        var r = n("Camera"),
        a = n("Object3D");
        i.prototype = Object.assign(Object.create(r.a.prototype), {
            constructor: i,
            isOrthographicCamera: true,
            copy: function(t, e) {
                return r.a.prototype.copy.call(this, t, e),
                this.left = t.left,
                this.right = t.right,
                this.top = t.top,
                this.bottom = t.bottom,
                this.near = t.near,
                this.far = t.far,
                this.zoom = t.zoom,
                this.view = null === t.view ? null: Object.assign({},
                t.view),
                this
            },
            setViewOffset: function(t, e, n, i, r, a) {
                this.view = {
                    fullWidth: t,
                    fullHeight: e,
                    offsetX: n,
                    offsetY: i,
                    width: r,
                    height: a
                },
                this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view = null,
                this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var t = (this.right - this.left) / (2 * this.zoom),
                e = (this.top - this.bottom) / (2 * this.zoom),
                n = (this.right + this.left) / 2,
                i = (this.top + this.bottom) / 2,
                r = n - t,
                a = n + t,
                o = i + e,
                s = i - e;
                if (null !== this.view) {
                    var u = this.zoom / (this.view.width / this.view.fullWidth),
                    c = this.zoom / (this.view.height / this.view.fullHeight),
                    h = (this.right - this.left) / this.view.width,
                    l = (this.top - this.bottom) / this.view.height;
                    r += h * (this.view.offsetX / u),
                    a = r + h * (this.view.width / u),
                    o -= l * (this.view.offsetY / c),
                    s = o - l * (this.view.height / c)
                }
                this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far)
            },
            toJSON: function(t) {
                var e = a.a.prototype.toJSON.call(this, t);
                return e.object.zoom = this.zoom,
                e.object.left = this.left,
                e.object.right = this.right,
                e.object.top = this.top,
                e.object.bottom = this.bottom,
                e.object.near = this.near,
                e.object.far = this.far,
                null !== this.view && (e.object.view = Object.assign({},
                this.view)),
                e
            }
        })
    },
    EfZs: function(t, e, n) {
        "use strict";
        e.a = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvarying vec2 vUv2;\\n#endif"
    },
    "CustomerDefine4": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i = 0,
        r = function() {
            function t(t) {
                this.length = 0,
                this._duplicateId = 0,
                this.data = new Array(t),
                this.tombList = [],
                this._id = i,
                i++
            }
            return t.prototype.setIndex = function(t, e) {
                this.data[e] = t,
                this.length > this.data.length && (this.data.length *= 2),
                t.__smartArrayFlags || (t.__smartArrayFlags = {}),
                t.__smartArrayFlags[this._id] = this._duplicateId
            },
            t.prototype.forEach = function(t) {
                for (var e = 0; e < this.length; e++) {
                    var n = this.data[e];
                    n.__smartArrayFlags[this._id] === this._duplicateId && t(n)
                }
            },
            t.prototype.addItemNoduplicate = function(t) {
                return t.__smartArrayFlags && t.__smartArrayFlags[this._id] === this._duplicateId ? -1 : this.addItem(t)
            },
            t.prototype.addItem = function(t) {
                var e;
                if (this.length < this.data.length) this.setIndex(t, this.length),
                e = this.length,
                this.length++;
                else if (this.tombList.length > 0) {
                    var n = this.tombList.pop();
                    this.setIndex(t, n),
                    e = n
                } else this.data.length *= 2,
                this.setIndex(t, this.length),
                e = this.length,
                this.length++;
                return e
            },
            t.prototype.removeItem = function(t, e) {
                return ! (!t.__smartArrayFlags || t.__smartArrayFlags[this._id] !== this._duplicateId) && (this.tombList.push(e), t.__smartArrayFlags[this._id] = -1, true)
            },
            t.prototype.reset = function() {
                this.length = 0,
                this._duplicateId++
            },
            t
        } ()
    },
    Bone: function(t, e, n) {
        "use strict";

        function i() {
            r.a.call(this),
            this.type = "Bone"
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Object3D");
        i.prototype = Object.assign(Object.create(r.a.prototype), {
            constructor: i,
            isBone: true
        })
    },
    ConeGeometry||ConeBufferGeometry: function(t, e, n) {
        "use strict";

        function i(t, e, n, i, r, o, s) {
            a.b.call(this, 0, t, e, n, i, r, o, s),
            this.type = "ConeGeometry",
            this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: o,
                thetaLength: s
            }
        }

        function r(t, e, n, i, r, o, s) {
            a.a.call(this, 0, t, e, n, i, r, o, s),
            this.type = "ConeBufferGeometry",
            this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: o,
                thetaLength: s
            }
        }
        var a = n("CylinderGeometry||CylinderBufferGeometry");
        i.prototype = Object.create(a.b.prototype),
        i.prototype.constructor = i,
        r.prototype = Object.create(a.a.prototype),
        r.prototype.constructor = r
    },
    FP58: function(t, e, n) {
        "use strict";

        function i(t, e) {
            this.min = undefined !== t ? t: new r.a(1 / 0, 1 / 0),
            this.max = undefined !== e ? e: new r.a( - 1 / 0, -Infinity)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Vector2");
        Object.assign(i.prototype, {
            set: function(t, e) {
                return this.min.copy(t),
                this.max.copy(e),
                this
            },
            setFromPoints: function(t) {
                this.makeEmpty();
                for (var e = 0,
                n = t.length; e < n; e++) this.expandByPoint(t[e]);
                return this
            },
            setFromCenterAndSize: function() {
                var t = new r.a;
                return function(e, n) {
                    var i = t.copy(n).multiplyScalar(.5);
                    return this.min.copy(e).sub(i),
                    this.max.copy(e).add(i),
                    this
                }
            } (),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.min.copy(t.min),
                this.max.copy(t.max),
                this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = 1 / 0,
                this.max.x = this.max.y = -Infinity,
                this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function(t) {
                var e = t || new r.a;
                return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(t) {
                var e = t || new r.a;
                return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
            },
            expandByPoint: function(t) {
                return this.min.min(t),
                this.max.max(t),
                this
            },
            expandByVector: function(t) {
                return this.min.sub(t),
                this.max.add(t),
                this
            },
            expandByScalar: function(t) {
                return this.min.addScalar( - t),
                this.max.addScalar(t),
                this
            },
            containsPoint: function(t) {
                return ! (t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
            },
            containsBox: function(t) {
                return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
            },
            getParameter: function(t, e) {
                return (e || new r.a).set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(t) {
                return ! (t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
            },
            clampPoint: function(t, e) {
                return (e || new r.a).copy(t).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var t = new r.a;
                return function(e) {
                    return t.copy(e).clamp(this.min, this.max).sub(e).length()
                }
            } (),
            intersect: function(t) {
                return this.min.max(t.min),
                this.max.min(t.max),
                this
            },
            union: function(t) {
                return this.min.min(t.min),
                this.max.max(t.max),
                this
            },
            translate: function(t) {
                return this.min.add(t),
                this.max.add(t),
                this
            },
            equals: function(t) {
                return t.min.equals(this.min) && t.max.equals(this.max)
            }
        })
    },
    Fa8a: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return s
        });
        var i = n("2Jtw"),
        r = n("PO9Y"),
        a = n("Oc0e"),
        o = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        s = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.onActiveChange = function(t) {
                    t !== e.active && (e.active = t, e.aoIntensity.current = 0)
                },
                e.onAoIntensityChange = function(t) {
                    e.aoIntensity.target = t
                },
                e
            }
            return o(e, t),
            e.prototype.initialize = function() {
                t.prototype.initialize.call(this),
                this.ssaoPass = new i.a,
                this.aoIntensity = {
                    current: 0,
                    target: this.ssaoPass.aoIntensity
                },
                this.config.addValueListener("engine/ao/active", this.onActiveChange),
                this.config.addValueListener("engine/ao/aoIntensity", this.onAoIntensityChange)
            },
            e.prototype.updateAoIntensity = function() {
                var t = this.aoIntensity,
                e = t.current,
                n = t.target;
                e < n && (this.aoIntensity.current = Math.min(e + .02, n), this.ssaoPass.aoIntensity = this.aoIntensity.current)
            },
            Object.defineProperty(e.prototype, "animationInProgress", {
                get: function() {
                    return this.active && this.aoIntensity.current < this.aoIntensity.target
                },
                enumerable: true,
                configurable: true
            }),
            e.prototype.render = function(t, e) {
                this.updateAoIntensity();
                var n = this.renderer.autoClear;
                this.renderer.autoClear = false,
                this.renderer.clear(),
                this.renderer.render(t, e),
                r.a.isPerspectiveCamera(e) && (this.ssaoPass.setup(t, e), this.ssaoPass.render(this.renderer)),
                this.renderer.autoClear = n
            },
            e.prototype.setSize = function(t, e) {
                this.renderer.setSize(t, e);
                var n = this.renderer.getDrawingBufferSize(),
                i = n.width,
                r = n.height;
                this.ssaoPass.setSize(i, r)
            },
            e.prototype.dispose = function() {
                t.prototype.dispose.call(this),
                this.ssaoPass.dispose(),
                this.config.removeValueListener("engine/ao/active", this.onActiveChange),
                this.config.removeValueListener("engine/ao/aoIntensity", this.onAoIntensityChange)
            },
            e
        } (a.a)
    },
    FeDS: function(t, e, n) {
        "use strict";

        function i(t) {
            "boolean" == typeof t && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), t = undefined),
            this.manager = undefined !== t ? t: p.a,
            this.withCredentials = false
        }
        var r = n("LWBF"),
        a = n("JzlU"),
        o = n("Vector3"),
        s = n("Vector4"),
        u = n("Color"),
        c = n("Vector2"),
        h = n("HiwY"),
        l = n("Geometry"),
        f = n("w2Sq"),
        p = n("OJZr");
        Object.assign(i.prototype, {
            load: function(t, e, n, i) {
                var a = this,
                o = this.texturePath && "string" == typeof this.texturePath ? this.texturePath: r.a.prototype.extractUrlBase(t),
                s = new f.a(this.manager);
                s.setWithCredentials(this.withCredentials),
                s.load(t,
                function(n) {
                    var i = JSON.parse(n),
                    r = i.metadata;
                    if (undefined !== r) {
                        var s = r.type;
                        if (undefined !== s) {
                            if ("object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.ObjectLoader instead.");
                            if ("scene" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + t + " should be loaded with THREE.SceneLoader instead.")
                        }
                    }
                    var u = a.parse(i, o);
                    e(u.geometry, u.materials)
                },
                n, i)
            },
            setTexturePath: function(t) {
                this.texturePath = t
            },
            parse: function() {
                function t(t, e) {
                    function n(t, e) {
                        return t & 1 << e
                    }
                    var i, r, a, s, l, f, p, d, m, v, g, y, _, x, b, w, M, S, E, T, A, C, P, L, R, I, O, N = t.faces,
                    D = t.vertices,
                    U = t.normals,
                    B = t.colors,
                    z = t.scale,
                    F = 0;
                    if (undefined !== t.uvs) {
                        for (i = 0; i < t.uvs.length; i++) t.uvs[i].length && F++;
                        for (i = 0; i < F; i++) e.faceVertexUvs[i] = []
                    }
                    for (s = 0, l = D.length; s < l;) S = new o.a,
                    S.x = D[s++] * z,
                    S.y = D[s++] * z,
                    S.z = D[s++] * z,
                    e.vertices.push(S);
                    for (s = 0, l = N.length; s < l;) if (v = N[s++], g = n(v, 0), y = n(v, 1), _ = n(v, 3), x = n(v, 4), b = n(v, 5), w = n(v, 6), M = n(v, 7), g) {
                        if (T = new h.a, T.a = N[s], T.b = N[s + 1], T.c = N[s + 3], A = new h.a, A.a = N[s + 1], A.b = N[s + 2], A.c = N[s + 3], s += 4, y && (m = N[s++], T.materialIndex = m, A.materialIndex = m), a = e.faces.length, _) for (i = 0; i < F; i++) for (L = t.uvs[i], e.faceVertexUvs[i][a] = [], e.faceVertexUvs[i][a + 1] = [], r = 0; r < 4; r++) d = N[s++],
                        I = L[2 * d],
                        O = L[2 * d + 1],
                        R = new c.a(I, O),
                        2 !== r && e.faceVertexUvs[i][a].push(R),
                        0 !== r && e.faceVertexUvs[i][a + 1].push(R);
                        if (x && (p = 3 * N[s++], T.normal.set(U[p++], U[p++], U[p]), A.normal.copy(T.normal)), b) for (i = 0; i < 4; i++) p = 3 * N[s++],
                        P = new o.a(U[p++], U[p++], U[p]),
                        2 !== i && T.vertexNormals.push(P),
                        0 !== i && A.vertexNormals.push(P);
                        if (w && (f = N[s++], C = B[f], T.color.setHex(C), A.color.setHex(C)), M) for (i = 0; i < 4; i++) f = N[s++],
                        C = B[f],
                        2 !== i && T.vertexColors.push(new u.a(C)),
                        0 !== i && A.vertexColors.push(new u.a(C));
                        e.faces.push(T),
                        e.faces.push(A)
                    } else {
                        if (E = new h.a, E.a = N[s++], E.b = N[s++], E.c = N[s++], y && (m = N[s++], E.materialIndex = m), a = e.faces.length, _) for (i = 0; i < F; i++) for (L = t.uvs[i], e.faceVertexUvs[i][a] = [], r = 0; r < 3; r++) d = N[s++],
                        I = L[2 * d],
                        O = L[2 * d + 1],
                        R = new c.a(I, O),
                        e.faceVertexUvs[i][a].push(R);
                        if (x && (p = 3 * N[s++], E.normal.set(U[p++], U[p++], U[p])), b) for (i = 0; i < 3; i++) p = 3 * N[s++],
                        P = new o.a(U[p++], U[p++], U[p]),
                        E.vertexNormals.push(P);
                        if (w && (f = N[s++], E.color.setHex(B[f])), M) for (i = 0; i < 3; i++) f = N[s++],
                        E.vertexColors.push(new u.a(B[f]));
                        e.faces.push(E)
                    }
                }

                function e(t, e) {
                    var n = undefined !== t.influencesPerVertex ? t.influencesPerVertex: 2;
                    if (t.skinWeights) for (var i = 0,
                    r = t.skinWeights.length; i < r; i += n) {
                        var a = t.skinWeights[i],
                        o = n > 1 ? t.skinWeights[i + 1] : 0,
                        u = n > 2 ? t.skinWeights[i + 2] : 0,
                        c = n > 3 ? t.skinWeights[i + 3] : 0;
                        e.skinWeights.push(new s.a(a, o, u, c))
                    }
                    if (t.skinIndices) for (var i = 0,
                    r = t.skinIndices.length; i < r; i += n) {
                        var h = t.skinIndices[i],
                        l = n > 1 ? t.skinIndices[i + 1] : 0,
                        f = n > 2 ? t.skinIndices[i + 2] : 0,
                        p = n > 3 ? t.skinIndices[i + 3] : 0;
                        e.skinIndices.push(new s.a(h, l, f, p))
                    }
                    e.bones = t.bones,
                    e.bones && e.bones.length > 0 && (e.skinWeights.length !== e.skinIndices.length || e.skinIndices.length !== e.vertices.length) && console.warn("When skinning, number of vertices (" + e.vertices.length + "), skinIndices (" + e.skinIndices.length + "), and skinWeights (" + e.skinWeights.length + ") should match.")
                }

                function n(t, e) {
                    var n = t.scale;
                    if (undefined !== t.morphTargets) for (var i = 0,
                    r = t.morphTargets.length; i < r; i++) {
                        e.morphTargets[i] = {},
                        e.morphTargets[i].name = t.morphTargets[i].name,
                        e.morphTargets[i].vertices = [];
                        for (var a = e.morphTargets[i].vertices, s = t.morphTargets[i].vertices, u = 0, c = s.length; u < c; u += 3) {
                            var h = new o.a;
                            h.x = s[u] * n,
                            h.y = s[u + 1] * n,
                            h.z = s[u + 2] * n,
                            a.push(h)
                        }
                    }
                    if (undefined !== t.morphColors && t.morphColors.length > 0) {
                        console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                        for (var l = e.faces,
                        f = t.morphColors[0].colors, i = 0, r = l.length; i < r; i++) l[i].color.fromArray(f, 3 * i)
                    }
                }

                function i(t, e) {
                    var n = [],
                    i = [];
                    undefined !== t.animation && i.push(t.animation),
                    undefined !== t.animations && (t.animations.length ? i = i.concat(t.animations) : i.push(t.animations));
                    for (var r = 0; r < i.length; r++) {
                        var o = a.a.parseAnimation(i[r], e.bones);
                        o && n.push(o)
                    }
                    if (e.morphTargets) {
                        var s = a.a.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
                        n = n.concat(s)
                    }
                    n.length > 0 && (e.animations = n)
                }
                return function(a, o) {
                    undefined !== a.data && (a = a.data),
                    undefined !== a.scale ? a.scale = 1 / a.scale: a.scale = 1;
                    var s = new l.a;
                    return t(a, s),
                    e(a, s),
                    n(a, s),
                    i(a, s),
                    s.computeFaceNormals(),
                    s.computeBoundingSphere(),
                    undefined === a.materials || 0 === a.materials.length ? {
                        geometry: s
                    }: {
                        geometry: s,
                        materials: r.a.prototype.initMaterials(a.materials, o, this.crossOrigin)
                    }
                }
            } ()
        })
    },
    LineLoop: function(t, e, n) {
        "use strict";

        function i(t, e) {
            r.a.call(this, t, e),
            this.type = "LineLoop"
        }
        var r = n("Line");
        i.prototype = Object.assign(Object.create(r.a.prototype), {
            constructor: i,
            isLineLoop: true
        })
    },
    Fp3w: function(t, e, n) {
        "use strict";
        e.a = "#ifdef PREMULTIPLIED_ALPHA\\n\\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n"
    },
    HemisphereLight: function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            r.a.call(this, t, n),
            this.type = "HemisphereLight",
            this.castShadow = undefined,
            this.position.copy(o.a.DefaultUp),
            this.updateMatrix(),
            this.groundColor = new a.a(e)
        }
        var r = n("Light"),
        a = n("Color"),
        o = n("Object3D");
        i.prototype = Object.assign(Object.create(r.a.prototype), {
            constructor: i,
            isHemisphereLight: true,
            copy: function(t) {
                return r.a.prototype.copy.call(this, t),
                this.groundColor.copy(t.groundColor),
                this
            }
        })
    },
    Fs5Y: function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_MORPHNORMALS\\n\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n"
    },
    FxUv: function(t, e, n) {
        "use strict";
        e.a = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\\t\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\\t\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\\t\\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\\t\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\\t}\\n\\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\\tfloat a2 = pow2( alpha );\\n\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat alpha = pow2( roughness );\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\\tfloat D = D_GGX( alpha, dotNH );\\n\\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\\tconst float LUT_SIZE  = 64.0;\\n\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\n\\tfloat theta = acos( dot( N, V ) );\\n\\tvec2 uv = vec2(\\n\\t\\tsqrt( saturate( roughness ) ),\\n\\t\\tsaturate( theta / ( 0.5 * PI ) ) );\\n\\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\\tfloat l = length( f );\\n\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\\tfloat x = dot( v1, v2 );\\n\\tfloat y = abs( x );\\n\\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\\n\\tfloat b = 3.45068 + (4.18814 + y) * y;\\n\\tfloat v = a / b;\\n\\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\\n\\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\\tvec3 lightNormal = cross( v1, v2 );\\n\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\\tvec3 T1, T2;\\n\\tT1 = normalize( V - N * dot( V, N ) );\\n\\tT2 = - cross( N, T1 );\\n\\tmat3 mat = mInv * transpose( mat3( T1, T2, N ) );\\n\\tvec3 coords[ 4 ];\\n\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\\tvec3 vectorFormFactor = vec3( 0.0 );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\\n\\treturn result;\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\\tvec4 r = roughness * c0 + c1;\\n\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\\tvec3 F = F_Schlick( specularColor, dotLH );\\n\\tfloat G = G_BlinnPhong_Implicit( );\\n\\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n"
    },
    GDAY: function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            function m(e, n, i, a) {
                var o = e.geometry,
                s = null,
                u = P,
                c = e.customDepthMaterial;
                if (i && (u = L, c = e.customDistanceMaterial), c) s = c;
                else {
                    var h = false;
                    n.morphTargets && (o && o.isBufferGeometry ? h = o.morphAttributes && o.morphAttributes.position && o.morphAttributes.position.length > 0 : o && o.isGeometry && (h = o.morphTargets && o.morphTargets.length > 0)),
                    e.isSkinnedMesh && false === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                    var l = e.isSkinnedMesh && n.skinning,
                    f = 0;
                    h && (f |= T),
                    l && (f |= A),
                    s = u[f]
                }
                if (t.localClippingEnabled && true === n.clipShadows && 0 !== n.clippingPlanes.length) {
                    var p = s.uuid,
                    d = n.uuid,
                    m = R[p];
                    undefined === m && (m = {},
                    R[p] = m);
                    var v = m[d];
                    undefined === v && (v = s.clone(), m[d] = v),
                    s = v
                }
                s.visible = n.visible,
                s.wireframe = n.wireframe;
                var g = n.side;
                return G.renderSingleSided && g == r.u && (g = r.E),
                G.renderReverseSided && (g === r.E ? g = r.f: g === r.f && (g = r.E)),
                s.side = g,
                s.clipShadows = n.clipShadows,
                s.clippingPlanes = n.clippingPlanes,
                s.wireframeLinewidth = n.wireframeLinewidth,
                s.linewidth = n.linewidth,
                i && undefined !== s.uniforms.lightPos && s.uniforms.lightPos.value.copy(a),
                s
            }

            function v(e, i, r, a) {
                if (false !== e.visible) {
                    if (e.layers.test(i.layers) && 
                        (e.isMesh || e.isLine || e.isPoints) && 
                        e.castShadow && (!e.frustumCulled || _.intersectsObject(e))) {
                        e.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, e.matrixWorld);
                        var o = n.update(e),
                        s = e.material;
                        if (Array.isArray(s)) for (var u = o.groups,
                        c = 0,
                        h = u.length; c < h; c++) {
                            var l = u[c],
                            f = s[l.materialIndex];
                            if (f && f.visible) {
                                var p = m(e, f, a, E);
                                t.renderBufferDirect(r, null, o, p, e, l)
                            }
                        } else if (s.visible) {
                            var p = m(e, s, a, E);
                            t.renderBufferDirect(r, null, o, p, e, null)
                        }
                    }
                    for (var d = e.children,
                    g = 0,
                    y = d.length; g < y; g++) v(d[g], i, r, a)
                }
            }
            var g = t.context,
            y = t.state,
            _ = new d.a,
            x = new p.a,
            b = e.shadows,
            w = new f.a,
            M = new f.a(i.maxTextureSize, i.maxTextureSize),
            S = new l.a,
            E = new l.a,
            T = 1,
            A = 2,
            C = 1 + (T | A),
            P = new Array(C),
            L = new Array(C),
            R = {},
            I = [new l.a(1, 0, 0), new l.a( - 1, 0, 0), new l.a(0, 0, 1), new l.a(0, 0, -1), new l.a(0, 1, 0), new l.a(0, -1, 0)],
            O = [new l.a(0, 1, 0), new l.a(0, 1, 0), new l.a(0, 1, 0), new l.a(0, 1, 0), new l.a(0, 0, 1), new l.a(0, 0, -1)],
            N = [new h.a, new h.a, new h.a, new h.a, new h.a, new h.a],
            D = new c.a;
            D.depthPacking = r._21,
            D.clipping = true;
            for (var U = u.a.distanceRGBA,
            B = s.a.clone(U.uniforms), z = 0; z !== C; ++z) {
                var F = 0 != (z & T),
                j = 0 != (z & A),
                k = D.clone();
                k.morphTargets = F,
                k.skinning = j,
                P[z] = k;
                var V = new o.a({
                    defines: {
                        USE_SHADOWMAP: ""
                    },
                    uniforms: B,
                    vertexShader: U.vertexShader,
                    fragmentShader: U.fragmentShader,
                    morphTargets: F,
                    skinning: j,
                    clipping: true
                });
                L[z] = V
            }
            var G = this;
            this.enabled = false,
            this.autoUpdate = true,
            this.needsUpdate = false,
            this.type = r._19,
            this.renderReverseSided = true,
            this.renderSingleSided = true,
            this.render = function(e, n) {
                if (false !== G.enabled && (false !== G.autoUpdate || false !== G.needsUpdate) && 0 !== b.length) {
                    y.disable(g.BLEND),
                    y.buffers.color.setClear(1, 1, 1, 1),
                    y.buffers.depth.setTest(true),
                    y.setScissorTest(false);
                    for (var i, o = 0,
                    s = b.length; o < s; o++) {
                        var u = b[o],
                        c = u.shadow,
                        h = u && u.isPointLight;
                        if (undefined !== c) {
                            var l = c.camera;
                            if (w.copy(c.mapSize), w.min(M), h) {
                                var f = w.x,
                                p = w.y;
                                N[0].set(2 * f, p, f, p),
                                N[1].set(0, p, f, p),
                                N[2].set(3 * f, p, f, p),
                                N[3].set(f, p, f, p),
                                N[4].set(3 * f, 0, f, p),
                                N[5].set(f, 0, f, p),
                                w.x *= 4,
                                w.y *= 2
                            }
                            if (null === c.map) {
                                var d = {
                                    minFilter: r._5,
                                    magFilter: r._5,
                                    format: r._22
                                };
                                c.map = new a.a(w.x, w.y, d),
                                c.map.texture.name = u.name + ".shadowMap",
                                l.updateProjectionMatrix()
                            }
                            c.isSpotLightShadow && c.update(u);
                            var m = c.map,
                            T = c.matrix;
                            E.setFromMatrixPosition(u.matrixWorld),
                            l.position.copy(E),
                            h ? (i = 6, T.makeTranslation( - E.x, -E.y, -E.z)) : (i = 1, S.setFromMatrixPosition(u.target.matrixWorld), l.lookAt(S), l.updateMatrixWorld(), T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), T.multiply(l.projectionMatrix), T.multiply(l.matrixWorldInverse)),
                            t.setRenderTarget(m),
                            t.clear();
                            for (var A = 0; A < i; A++) {
                                if (h) {
                                    S.copy(l.position),
                                    S.add(I[A]),
                                    l.up.copy(O[A]),
                                    l.lookAt(S),
                                    l.updateMatrixWorld();
                                    var C = N[A];
                                    y.viewport(C)
                                }
                                x.multiplyMatrices(l.projectionMatrix, l.matrixWorldInverse),
                                _.setFromMatrix(x),
                                v(e, n, l, h)
                            }
                        } else console.warn("THREE.WebGLShadowMap:", u, "has no shadow.")
                    }
                    var P = t.getClearColor(),
                    L = t.getClearAlpha();
                    t.setClearColor(P, L),
                    G.needsUpdate = false
                }
            }
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("RBSo"),
        a = n("v504"),
        o = n("ShaderMaterial"),
        s = n("UniformsUtils"),
        u = n("ShaderLib"),
        c = n("MeshDepthMaterial"),
        h = n("Vector4"),
        l = n("Vector3"),
        f = n("Vector2"),
        p = n("Matrix4"),
        d = n("Frustum")
    },
    "GGw+": function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvarying vec3 vWorldPosition;\\n\\t#else\\n\\t\\tvarying vec3 vReflect;\\n\\t\\tuniform float refractionRatio;\\n\\t#endif\\n#endif\\n"
    },

    ==Plane===
    Plane: function(t, e, n) {
        "use strict";

        function i(t, e) {
            this.normal = undefined !== t ? t: new a.a(1, 0, 0),
            this.constant = undefined !== e ? e: 0
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Matrix3"),
        a = n("Vector3");
        Object.assign(i.prototype, {
            set: function(t, e) {
                return this.normal.copy(t),
                this.constant = e,
                this
            },
            setComponents: function(t, e, n, i) {
                return this.normal.set(t, e, n),
                this.constant = i,
                this
            },
            setFromNormalAndCoplanarPoint: function(t, e) {
                return this.normal.copy(t),
                this.constant = -e.dot(this.normal),
                this
            },
            setFromCoplanarPoints: function() {
                var t = new a.a,
                e = new a.a;
                return function(n, i, r) {
                    var a = t.subVectors(r, i).cross(e.subVectors(n, i)).normalize();
                    return this.setFromNormalAndCoplanarPoint(a, n),
                    this
                }
            } (),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                return this.normal.copy(t.normal),
                this.constant = t.constant,
                this
            },
            normalize: function() {
                var t = 1 / this.normal.length();
                return this.normal.multiplyScalar(t),
                this.constant *= t,
                this
            },
            negate: function() {
                return this.constant *= -1,
                this.normal.negate(),
                this
            },
            distanceToPoint: function(t) {
                return this.normal.dot(t) + this.constant
            },
            distanceToSphere: function(t) {
                return this.distanceToPoint(t.center) - t.radius
            },
            projectPoint: function(t, e) {
                return this.orthoPoint(t, e).sub(t).negate()
            },
            orthoPoint: function(t, e) {
                var n = this.distanceToPoint(t);
                return (e || new a.a).copy(this.normal).multiplyScalar(n)
            },
            intersectLine: function() {
                var t = new a.a;
                return function(e, n) {
                    var i = n || new a.a,
                    r = e.delta(t),
                    o = this.normal.dot(r);
                    if (0 !== o) {
                        var s = -(e.start.dot(this.normal) + this.constant) / o;
                        if (! (s < 0 || s > 1)) return i.copy(r).multiplyScalar(s).add(e.start)
                    } else if (0 === this.distanceToPoint(e.start)) return i.copy(e.start)
                }
            } (),
            intersectsLine: function(t) {
                var e = this.distanceToPoint(t.start),
                n = this.distanceToPoint(t.end);
                return e < 0 && n > 0 || n < 0 && e > 0
            },
            intersectsBox: function(t) {
                return t.intersectsPlane(this)
            },
            intersectsSphere: function(t) {
                return t.intersectsPlane(this)
            },
            coplanarPoint: function(t) {
                return (t || new a.a).copy(this.normal).multiplyScalar( - this.constant)
            },
            applyMatrix4: function() {
                var t = new a.a,
                e = new r.a;
                return function(n, i) {
                    var r = this.coplanarPoint(t).applyMatrix4(n),
                    a = i || e.getNormalMatrix(n),
                    o = this.normal.applyMatrix3(a).normalize();
                    return this.constant = -r.dot(o),
                    this
                }
            } (),
            translate: function(t) {
                return this.constant = this.constant - t.dot(this.normal),
                this
            },
            equals: function(t) {
                return t.normal.equals(this.normal) && t.constant === this.constant
            }
        })
    },
    HDm3: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return h
        });
        var i = n("XAHe"),
        r = n("PXdy"),
        a = n("uQxt"),
        o = n("Vector2"),
        s = n("uDA3"),
        u = n("k/v9"),
        c = n("+Ro2"),
        h = Object.assign(Object.create(i.a.prototype), {
            fromPoints: function(t) {
                this.moveTo(t[0].x, t[0].y);
                for (var e = 1,
                n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
            },
            moveTo: function(t, e) {
                this.currentPoint.set(t, e)
            },
            lineTo: function(t, e) {
                var n = new c.a(this.currentPoint.clone(), new o.a(t, e));
                this.curves.push(n),
                this.currentPoint.set(t, e)
            },
            quadraticCurveTo: function(t, e, n, i) {
                var r = new u.a(this.currentPoint.clone(), new o.a(t, e), new o.a(n, i));
                this.curves.push(r),
                this.currentPoint.set(n, i)
            },
            bezierCurveTo: function(t, e, n, i, r, a) {
                var u = new s.a(this.currentPoint.clone(), new o.a(t, e), new o.a(n, i), new o.a(r, a));
                this.curves.push(u),
                this.currentPoint.set(r, a)
            },
            splineThru: function(t) {
                var e = [this.currentPoint.clone()].concat(t),
                n = new a.a(e);
                this.curves.push(n),
                this.currentPoint.copy(t[t.length - 1])
            },
            arc: function(t, e, n, i, r, a) {
                var o = this.currentPoint.x,
                s = this.currentPoint.y;
                this.absarc(t + o, e + s, n, i, r, a)
            },
            absarc: function(t, e, n, i, r, a) {
                this.absellipse(t, e, n, n, i, r, a)
            },
            ellipse: function(t, e, n, i, r, a, o, s) {
                var u = this.currentPoint.x,
                c = this.currentPoint.y;
                this.absellipse(t + u, e + c, n, i, r, a, o, s)
            },
            absellipse: function(t, e, n, i, a, o, s, u) {
                var c = new r.a(t, e, n, i, a, o, s, u);
                if (this.curves.length > 0) {
                    var h = c.getPoint(0);
                    h.equals(this.currentPoint) || this.lineTo(h.x, h.y)
                }
                this.curves.push(c);
                var l = c.getPoint(1);
                this.currentPoint.copy(l)
            }
        })
    },
    HQOz: function(t, e, n) {
        "use strict";
        e.a = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n#endif\\n"
    },
    HiwY: function(t, e, n) {
        "use strict";

        function i(t, e, n, i, o, s) {
            this.a = t,
            this.b = e,
            this.c = n,
            this.normal = i && i.isVector3 ? i: new a.a,
            this.vertexNormals = Array.isArray(i) ? i: [],
            this.color = o && o.isColor ? o: new r.a,
            this.vertexColors = Array.isArray(o) ? o: [],
            this.materialIndex = undefined !== s ? s: 0
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Color"),
        a = n("Vector3");
        Object.assign(i.prototype, {
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(t) {
                this.a = t.a,
                this.b = t.b,
                this.c = t.c,
                this.normal.copy(t.normal),
                this.color.copy(t.color),
                this.materialIndex = t.materialIndex;
                for (var e = 0,
                n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                for (var e = 0,
                n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                return this
            }
        })
    },
    "I/Ex": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i = this && this.__extends ||
        function() {
            var t = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array &&
            function(t, e) {
                t.__proto__ = e
            } ||
            function(t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
            };
            return function(e, n) {
                function i() {
                    this.constructor = e
                }
                t(e, n),
                e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
            }
        } (),
        r = function() {
            function t(t) {
                this.length = 0,
                this.data = new Array(t)
            }
            return t.prototype.push = function(t) {
                return this.data[this.length++] = t,
                this.length > this.data.length && (this.data.length *= 2),
                this
            },
            t.prototype.pop = function() {
                if (this.length > 0) {
                    var t = this.data[this.length - 1];
                    return this.length--,
                    t
                }
                return null
            },
            t.prototype.forEach = function(t) {
                for (var e = 0; e < this.length; e++) t(this.data[e])
            },
            t.prototype.sort = function(t) {
                this.data.sort(t)
            },
            t.prototype.reset = function() {
                this.length = 0
            },
            t.prototype.dispose = function() {
                this.reset(),
                this.data && (this.data.length = 0, this.data = [])
            },
            t.prototype.concat = function(t) {
                if (0 !== t.length) {
                    this.length + t.length > this.data.length && (this.data.length = 2 * (this.length + t.length));
                    for (var e = 0; e < t.length; e++) this.data[this.length++] = (t.data || t)[e];
                    return this
                }
            },
            t.prototype.indexOf = function(t) {
                var e = this.data.indexOf(t);
                return e >= this.length ? -1 : e
            },
            t.prototype.contains = function(t) {
                return - 1 !== this.data.indexOf(t)
            },
            t
        } (); !
        function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e._duplicateId = 0,
                e
            }
            i(e, t),
            e.prototype.push = function(e) {
                return t.prototype.push.call(this, e),
                e.__smartArrayFlags || (e.__smartArrayFlags = {}),
                e.__smartArrayFlags[this._id] = this._duplicateId,
                this
            },
            e.prototype.pushNoDuplicate = function(t) {
                return (!t.__smartArrayFlags || t.__smartArrayFlags[this._id] !== this._duplicateId) && (this.push(t), true)
            },
            e.prototype.reset = function() {
                t.prototype.reset.call(this),
                this._duplicateId++
            },
            e.prototype.concatWithNoDuplicate = function(t) {
                if (0 !== t.length) {
                    this.length + t.length > this.data.length && (this.data.length = 2 * (this.length + t.length));
                    for (var e = 0; e < t.length; e++) {
                        var n = (t.data || t)[e];
                        this.pushNoDuplicate(n)
                    }
                }
            }
        } (r)
    },
    I4yL: function(t, e, n) {
        "use strict";

        function i() {
            var t = {};
            return {
                get: function(e) {
                    if (undefined !== t[e.id]) return t[e.id];
                    var n;
                    switch (e.type) {
                    case "DirectionalLight":
                        n = {
                            direction: new a.a,
                            color: new r.a,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new o.a
                        };
                        break;
                    case "SpotLight":
                        n = {
                            position: new a.a,
                            direction: new a.a,
                            color: new r.a,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new o.a
                        };
                        break;
                    case "PointLight":
                        n = {
                            position: new a.a,
                            color: new r.a,
                            distance: 0,
                            decay: 0,
                            shadow: false,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new o.a
                        };
                        break;
                    case "HemisphereLight":
                        n = {
                            direction: new a.a,
                            skyColor: new r.a,
                            groundColor: new r.a
                        };
                        break;
                    case "RectAreaLight":
                        n = {
                            color: new r.a,
                            position: new a.a,
                            halfWidth: new a.a,
                            halfHeight: new a.a
                        }
                    }
                    return t[e.id] = n,
                    n
                }
            }
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Color"),
        a = n("Vector3"),
        o = n("Vector2")
    },
    I87F: function(t, e, n) {
        "use strict";
        e.a = "#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\n\\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\nvoid main() {\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\\n"
    },
    IASN: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i, r = {
            getContext: function() {
                return undefined === i && (i = new(window.AudioContext || window.webkitAudioContext)),
                i
            },
            setContext: function(t) {
                i = t
            }
        }
    },
    IF3P: function(t, e, n) {
        "use strict";

        function i(t) {
            this.manager = undefined !== t ? t: s.a,
            this._parser = null
        }
        var r = n("RBSo"),
        a = n("w2Sq"),
        o = n("DataTexture"),
        s = n("OJZr");
        Object.assign(i.prototype, {
            load: function(t, e, n, i) {
                var s = this,
                u = new o.a,
                c = new a.a(this.manager);
                return c.setResponseType("arraybuffer"),
                c.load(t,
                function(t) {
                    var n = s._parser(t);
                    n && (undefined !== n.image ? u.image = n.image: undefined !== n.data && (u.image.width = n.width, u.image.height = n.height, u.image.data = n.data), u.wrapS = undefined !== n.wrapS ? n.wrapS: r.j, u.wrapT = undefined !== n.wrapT ? n.wrapT: r.j, u.magFilter = undefined !== n.magFilter ? n.magFilter: r.Q, u.minFilter = undefined !== n.minFilter ? n.minFilter: r.R, u.anisotropy = undefined !== n.anisotropy ? n.anisotropy: 1, undefined !== n.format && (u.format = n.format), undefined !== n.type && (u.type = n.type), undefined !== n.mipmaps && (u.mipmaps = n.mipmaps), 1 === n.mipmapCount && (u.minFilter = r.Q), u.needsUpdate = true, e && e(u, n))
                },
                n, i),
                u
            }
        })
    },
    Ioe4: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i = n("M4fF"),
        r = (n.n(i),
        function() {
            function t() {
                this.curFpsSampleIndex = 0,
                this.rafBeginTime = 0,
                this._timeSpentBeforeRendering = 0,
                this.setSamplesOfAverageFps(10)
            }
            return Object.defineProperty(t.prototype, "frameBeginTime", {
                get: function() {
                    return this._frameBeginTime
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(t.prototype, "frameEndTime", {
                get: function() {
                    return this._frameSpentTime
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(t.prototype, "framePastTime", {
                get: function() {
                    return performance.now() - this._frameBeginTime
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(t.prototype, "timeSpentBeforeRendering", {
                get: function() {
                    return this._timeSpentBeforeRendering
                },
                enumerable: true,
                configurable: true
            }),
            t.prototype.setSamplesOfAverageFps = function(t) {
                this.numfpsSamples = Math.min(t, 100),
                this.fpsSamples = new Array(this.numfpsSamples),
                this.fpsSamples.length = this.numfpsSamples,
                this.fpsSamples.fill(60, 0, this.numfpsSamples)
            },
            t.prototype.beginFrame = function() {
                this._frameBeginTime = performance.now(),
                this.rafBeginTime || (this.rafBeginTime = this._frameBeginTime),
                this._timeSpentBeforeRendering = this._frameBeginTime - this.rafBeginTime
            },
            t.prototype.endFrame = function() {
                this._frameSpentTime = performance.now() - this.rafBeginTime,
                this.curFpsSampleIndex = (this.curFpsSampleIndex + 1) % this.numfpsSamples,
                this.fpsSamples[this.curFpsSampleIndex] = 1e3 / this._frameSpentTime
            },
            t.prototype.getAverageFps = function() {
                return Object(i.mean)(this.fpsSamples)
            },
            t.prototype.resetAverageFps = function() {
                this.fpsSamples.fill(60, 0, this.numfpsSamples)
            },
            t.prototype.getLastFps = function() {
                var t = (this.curFpsSampleIndex + this.numfpsSamples + 1) % this.numfpsSamples;
                return this.fpsSamples[t]
            },
            t
        } ())
    },
    IriH: function(t, e, n) {
        "use strict";

        function i(t, e) {
            function n() {
                var t = new Float32Array([ - 1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                e = new Uint16Array([0, 1, 2, 0, 2, 3]);
                s = m.createBuffer(),
                u = m.createBuffer(),
                m.bindBuffer(m.ARRAY_BUFFER, s),
                m.bufferData(m.ARRAY_BUFFER, t, m.STATIC_DRAW),
                m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, u),
                m.bufferData(m.ELEMENT_ARRAY_BUFFER, e, m.STATIC_DRAW),
                p = m.createTexture(),
                d = m.createTexture(),
                v.bindTexture(m.TEXTURE_2D, p),
                m.texImage2D(m.TEXTURE_2D, 0, m.RGB, 16, 16, 0, m.RGB, m.UNSIGNED_BYTE, null),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
                v.bindTexture(m.TEXTURE_2D, d),
                m.texImage2D(m.TEXTURE_2D, 0, m.RGBA, 16, 16, 0, m.RGBA, m.UNSIGNED_BYTE, null),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_S, m.CLAMP_TO_EDGE),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_WRAP_T, m.CLAMP_TO_EDGE),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MAG_FILTER, m.NEAREST),
                m.texParameteri(m.TEXTURE_2D, m.TEXTURE_MIN_FILTER, m.NEAREST),
                c = {
                    vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\\n"),
                    fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\\n")
                },
                h = i(c),
                l = {
                    vertex: m.getAttribLocation(h, "position"),
                    uv: m.getAttribLocation(h, "uv")
                },
                f = {
                    renderType: m.getUniformLocation(h, "renderType"),
                    map: m.getUniformLocation(h, "map"),
                    occlusionMap: m.getUniformLocation(h, "occlusionMap"),
                    opacity: m.getUniformLocation(h, "opacity"),
                    color: m.getUniformLocation(h, "color"),
                    scale: m.getUniformLocation(h, "scale"),
                    rotation: m.getUniformLocation(h, "rotation"),
                    screenPosition: m.getUniformLocation(h, "screenPosition")
                }
            }

            function i(e) {
                var n = m.createProgram(),
                i = m.createShader(m.FRAGMENT_SHADER),
                r = m.createShader(m.VERTEX_SHADER),
                a = "precision " + t.getPrecision() + " float;\\n";
                return m.shaderSource(i, a + e.fragmentShader),
                m.shaderSource(r, a + e.vertexShader),
                m.compileShader(i),
                m.compileShader(r),
                m.attachShader(n, i),
                m.attachShader(n, r),
                m.linkProgram(n),
                n
            }
            var s, u, c, h, l, f, p, d, m = t.context,
            v = t.state;
            this.render = function(i, c, g) {
                if (0 !== e.length) {
                    var y = new o.a,
                    _ = g.w / g.z,
                    x = .5 * g.z,
                    b = .5 * g.w,
                    w = 16 / g.w,
                    M = new a.a(w * _, w),
                    S = new o.a(1, 1, 0),
                    E = new a.a(1, 1),
                    T = new r.a;
                    T.min.set(g.x, g.y),
                    T.max.set(g.x + (g.z - 16), g.y + (g.w - 16)),
                    undefined === h && n(),
                    m.useProgram(h),
                    v.initAttributes(),
                    v.enableAttribute(l.vertex),
                    v.enableAttribute(l.uv),
                    v.disableUnusedAttributes(),
                    m.uniform1i(f.occlusionMap, 0),
                    m.uniform1i(f.map, 1),
                    m.bindBuffer(m.ARRAY_BUFFER, s),
                    m.vertexAttribPointer(l.vertex, 2, m.FLOAT, false, 16, 0),
                    m.vertexAttribPointer(l.uv, 2, m.FLOAT, false, 16, 8),
                    m.bindBuffer(m.ELEMENT_ARRAY_BUFFER, u),
                    v.disable(m.CULL_FACE),
                    v.buffers.depth.setMask(false);
                    for (var A = 0,
                    C = e.length; A < C; A++) {
                        w = 16 / g.w,
                        M.set(w * _, w);
                        var P = e[A];
                        if (y.set(P.matrixWorld.elements[12], P.matrixWorld.elements[13], P.matrixWorld.elements[14]), y.applyMatrix4(c.matrixWorldInverse), y.applyMatrix4(c.projectionMatrix), S.copy(y), E.x = g.x + S.x * x + x - 8, E.y = g.y + S.y * b + b - 8, true === T.containsPoint(E)) {
                            v.activeTexture(m.TEXTURE0),
                            v.bindTexture(m.TEXTURE_2D, null),
                            v.activeTexture(m.TEXTURE1),
                            v.bindTexture(m.TEXTURE_2D, p),
                            m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGB, E.x, E.y, 16, 16, 0),
                            m.uniform1i(f.renderType, 0),
                            m.uniform2f(f.scale, M.x, M.y),
                            m.uniform3f(f.screenPosition, S.x, S.y, S.z),
                            v.disable(m.BLEND),
                            v.enable(m.DEPTH_TEST),
                            m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                            v.activeTexture(m.TEXTURE0),
                            v.bindTexture(m.TEXTURE_2D, d),
                            m.copyTexImage2D(m.TEXTURE_2D, 0, m.RGBA, E.x, E.y, 16, 16, 0),
                            m.uniform1i(f.renderType, 1),
                            v.disable(m.DEPTH_TEST),
                            v.activeTexture(m.TEXTURE1),
                            v.bindTexture(m.TEXTURE_2D, p),
                            m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0),
                            P.positionScreen.copy(S),
                            P.customUpdateCallback ? P.customUpdateCallback(P) : P.updateLensFlares(),
                            m.uniform1i(f.renderType, 2),
                            v.enable(m.BLEND);
                            for (var L = 0,
                            R = P.lensFlares.length; L < R; L++) {
                                var I = P.lensFlares[L];
                                I.opacity > .001 && I.scale > .001 && (S.x = I.x, S.y = I.y, S.z = I.z, w = I.size * I.scale / g.w, M.x = w * _, M.y = w, m.uniform3f(f.screenPosition, S.x, S.y, S.z), m.uniform2f(f.scale, M.x, M.y), m.uniform1f(f.rotation, I.rotation), m.uniform1f(f.opacity, I.opacity), m.uniform3f(f.color, I.color.r, I.color.g, I.color.b), v.setBlending(I.blending, I.blendEquation, I.blendSrc, I.blendDst), t.setTexture2D(I.texture, 1), m.drawElements(m.TRIANGLES, 6, m.UNSIGNED_SHORT, 0))
                            }
                        }
                    }
                    v.enable(m.CULL_FACE),
                    v.enable(m.DEPTH_TEST),
                    v.buffers.depth.setMask(true),
                    t.resetGLState()
                }
            }
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("FP58"),
        a = n("Vector2"),
        o = n("Vector3")
    },
    J08l: function(t, e, n) {
        "use strict";
        e.a = "vec3 packNormalToRGB( const in vec3 normal ) {\\n\\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\\treturn 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\\tr.yzw -= r.xyz * ShiftRight8;\\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n"
    },
    JJh5: function(t, e, n) {
        "use strict";

        function i(t, e, n, i, r) {
            var a = .5 * (i - e),
            o = .5 * (r - n),
            s = t * t;
            return (2 * n - 2 * i + a + o) * (t * s) + ( - 3 * n + 3 * i - 2 * a - o) * s + a * t + n
        }

        function r(t, e) {
            var n = 1 - t;
            return n * n * e
        }

        function a(t, e) {
            return 2 * (1 - t) * t * e
        }

        function o(t, e) {
            return t * t * e
        }

        function s(t, e, n, i) {
            return r(t, e) + a(t, n) + o(t, i)
        }

        function u(t, e) {
            var n = 1 - t;
            return n * n * n * e
        }

        function c(t, e) {
            var n = 1 - t;
            return 3 * n * n * t * e
        }

        function h(t, e) {
            return 3 * (1 - t) * t * t * e
        }

        function l(t, e) {
            return t * t * t * e
        }

        function f(t, e, n, i, r) {
            return u(t, e) + c(t, n) + h(t, i) + l(t, r)
        }
        n.d(e, "a",
        function() {
            return i
        }),
        n.d(e, "c",
        function() {
            return s
        }),
        n.d(e, "b",
        function() {
            return f
        })
    },
    JLlh: function(t, e, n) {
        "use strict";
        e.a = "#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n"
    },
    "Audio": function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.type = "Audio",
            this.context = t.context,
            this.gain = this.context.createGain(),
            this.gain.connect(t.getInput()),
            this.autoplay = false,
            this.buffer = null,
            this.loop = false,
            this.startTime = 0,
            this.playbackRate = 1,
            this.isPlaying = false,
            this.hasPlaybackControl = true,
            this.sourceType = "empty",
            this.filters = []
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Object3D");
        i.prototype = Object.assign(Object.create(r.a.prototype), {
            constructor: i,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(t) {
                return this.hasPlaybackControl = false,
                this.sourceType = "audioNode",
                this.source = t,
                this.connect(),
                this
            },
            setBuffer: function(t) {
                return this.buffer = t,
                this.sourceType = "buffer",
                this.autoplay && this.play(),
                this
            },
            play: function() {
                if (true === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                if (false === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                var t = this.context.createBufferSource();
                return t.buffer = this.buffer,
                t.loop = this.loop,
                t.onended = this.onEnded.bind(this),
                t.playbackRate.setValueAtTime(this.playbackRate, this.startTime),
                t.start(0, this.startTime),
                this.isPlaying = true,
                this.source = t,
                this.connect()
            },
            pause: function() {
                return ! 1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = false, this)
            },
            stop: function() {
                return ! 1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = 0, this.isPlaying = false, this)
            },
            connect: function() {
                if (this.filters.length > 0) {
                    this.source.connect(this.filters[0]);
                    for (var t = 1,
                    e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (this.filters.length > 0) {
                    this.source.disconnect(this.filters[0]);
                    for (var t = 1,
                    e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(t) {
                return t || (t = []),
                true === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t,
                this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(t) {
                return this.setFilters(t ? [t] : [])
            },
            setPlaybackRate: function(t) {
                return ! 1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = t, true === this.isPlaying && this.source.playbackRate.setValueAtTime(this.playbackRate, this.context.currentTime), this)
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = false
            },
            getLoop: function() {
                return ! 1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop
            },
            setLoop: function(t) {
                return ! 1 === this.hasPlaybackControl ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.loop = t, true === this.isPlaying && (this.source.loop = this.loop), this)
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(t) {
                return this.gain.gain.value = t,
                this
            }
        })
    },
    Jjpd: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        });
        var i = n("Object3D"),
        r = function() {
            function t(t, e) {
                var n = this;
                this.worldMatrixUpdateTimestamp = 0,
                this.netVisiblity = true,
                this.netVisiblityUpdateTimestamp = 0,
                this.attributeUpdateTimeStamp = 0,
                this.doc = null,
                this.obj = null,
                this._changes = i.b.NOCHANGE,
                this._needsUpdate = true,
                this.subMeshWorldAABBs = [],
                this.onObjectChanged = function(t) {
                    t.attachment && (n._changes |= t.attachment),
                    n.setAndPropagateNeedsUpdate(),
                    n.doc.onObjectChanged(t.target)
                },
                this.onObjectRemoved = function(t) {
                    var e = t.target;
                    e.removeEventListener("removed", n.onObjectRemoved),
                    n.doc.onObjectRemoved(e)
                },
                this.doc = t,
                this.obj = e,
                e.addEventListener("changed", this.onObjectChanged),
                e.addEventListener("removed", this.onObjectRemoved)
            }
            return Object.defineProperty(t.prototype, "changes", {
                get: function() {
                    return this._changes
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(t.prototype, "needsUpdate", {
                get: function() {
                    return this._needsUpdate
                },
                enumerable: true,
                configurable: true
            }),
            Object.defineProperty(t.prototype, "sceneDoc", {
                get: function() {
                    return this.doc
                },
                enumerable: true,
                configurable: true
            }),
            t.prototype.setNodeUpdated = function() {
                this._changes = 0,
                this._needsUpdate = false
            },
            t.prototype.setAndPropagateNeedsUpdate = function() {
                if (!this._needsUpdate && (this._needsUpdate = true, this.obj.parent)) {
                    var t = this.obj.parent.sceneNode;
                    t && t.setAndPropagateNeedsUpdate()
                }
            },
            t
        } ()
    },
    Jlpq: function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            this.object = t,
            this.size = undefined !== e ? e: 1;
            var r = undefined !== n ? n: 16776960,
            a = undefined !== i ? i: 1,
            h = 0,
            l = this.object.geometry;
            l && l.isGeometry ? h = l.faces.length: console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
            var f = new c.a,
            p = new u.b(2 * h * 3, 3);
            f.addAttribute("position", p),
            o.a.call(this, f, new s.a({
                color: r,
                linewidth: a
            })),
            this.matrixAutoUpdate = false,
            this.update()
        }
        var r = n("Matrix3"),
        a = n("Vector3"),
        o = n("LineSegments"),
        s = n("LineBasicMaterial"),
        u = n("BufferAttribute"),
        c = n("BufferGeometry");
        i.prototype = Object.create(o.a.prototype),
        i.prototype.constructor = i,
        i.prototype.update = function() {
            var t = new a.a,
            e = new a.a,
            n = new r.a;
            return function() {
                this.object.updateMatrixWorld(true),
                n.getNormalMatrix(this.object.matrixWorld);
                for (var i = this.object.matrixWorld,
                r = this.geometry.attributes.position,
                a = this.object.geometry,
                o = a.vertices,
                s = a.faces,
                u = 0,
                c = 0,
                h = s.length; c < h; c++) {
                    var l = s[c],
                    f = l.normal;
                    t.copy(o[l.a]).add(o[l.b]).add(o[l.c]).divideScalar(3).applyMatrix4(i),
                    e.copy(f).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t),
                    r.setXYZ(u, t.x, t.y, t.z),
                    u += 1,
                    r.setXYZ(u, e.x, e.y, e.z),
                    u += 1
                }
                r.needsUpdate = true
            }
        } ()
    },
    Euler: function(t, e, n) {
        "use strict";

        function i(t, e, n, r) {
            this._x = t || 0,
            this._y = e || 0,
            this._z = n || 0,
            this._order = r || i.DefaultOrder
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Quaternion"),
        a = n("Vector3"),
        o = n("Matrix4"),
        s = n("_Math");
        i.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"],
        i.DefaultOrder = "XYZ",
        Object.defineProperties(i.prototype, {
            x: {
                get: function() {
                    return this._x
                },
                set: function(t) {
                    this._x = t,
                    this.onChangeCallback()
                }
            },
            y: {
                get: function() {
                    return this._y
                },
                set: function(t) {
                    this._y = t,
                    this.onChangeCallback()
                }
            },
            z: {
                get: function() {
                    return this._z
                },
                set: function(t) {
                    this._z = t,
                    this.onChangeCallback()
                }
            },
            order: {
                get: function() {
                    return this._order
                },
                set: function(t) {
                    this._order = t,
                    this.onChangeCallback()
                }
            }
        }),
        Object.assign(i.prototype, {
            isEuler: true,
            set: function(t, e, n, i) {
                return this._x = t,
                this._y = e,
                this._z = n,
                this._order = i || this._order,
                this.onChangeCallback(),
                this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function(t) {
                return this._x = t._x,
                this._y = t._y,
                this._z = t._z,
                this._order = t._order,
                this.onChangeCallback(),
                this
            },
            setFromRotationMatrix: function(t, e, n) {
                var i = s.a.clamp,
                r = t.elements,
                a = r[0],
                o = r[4],
                u = r[8],
                c = r[1],
                h = r[5],
                l = r[9],
                f = r[2],
                p = r[6],
                d = r[10];
                return e = e || this._order,
                "XYZ" === e ? (this._y = Math.asin(i(u, -1, 1)), Math.abs(u) < .99999 ? (this._x = Math.atan2( - l, d), this._z = Math.atan2( - o, a)) : (this._x = Math.atan2(p, h), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin( - i(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(u, d), this._z = Math.atan2(c, h)) : (this._y = Math.atan2( - f, a), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(i(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2( - f, d), this._z = Math.atan2( - o, h)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === e ? (this._y = Math.asin( - i(f, -1, 1)), Math.abs(f) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2( - o, h))) : "YZX" === e ? (this._z = Math.asin(i(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2( - l, h), this._y = Math.atan2( - f, a)) : (this._x = 0, this._y = Math.atan2(u, d))) : "XZY" === e ? (this._z = Math.asin( - i(o, -1, 1)), Math.abs(o) < .99999 ? (this._x = Math.atan2(p, h), this._y = Math.atan2(u, a)) : (this._x = Math.atan2( - l, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e),
                this._order = e,
                false !== n && this.onChangeCallback(),
                this
            },
            setFromQuaternion: function() {
                var t = new o.a;
                return function(e, n, i) {
                    return t.makeRotationFromQuaternion(e),
                    this.setFromRotationMatrix(t, n, i)
                }
            } (),
            setFromVector3: function(t, e) {
                return this.set(t.x, t.y, t.z, e || this._order)
            },
            reorder: function() {
                var t = new r.a;
                return function(e) {
                    return t.setFromEuler(this),
                    this.setFromQuaternion(t, e)
                }
            } (),
            equals: function(t) {
                return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
            },
            fromArray: function(t) {
                return this._x = t[0],
                this._y = t[1],
                this._z = t[2],
                undefined !== t[3] && (this._order = t[3]),
                this.onChangeCallback(),
                this
            },
            toArray: function(t, e) {
                return undefined === t && (t = []),
                undefined === e && (e = 0),
                t[e] = this._x,
                t[e + 1] = this._y,
                t[e + 2] = this._z,
                t[e + 3] = this._order,
                t
            },
            toVector3: function(t) {
                return t ? t.set(this._x, this._y, this._z) : new a.a(this._x, this._y, this._z)
            },
            onChange: function(t) {
                return this.onChangeCallback = t,
                this
            },
            onChangeCallback: function() {}
        })
    },
    Judu: function(t, e, n) {
        "use strict";

        function i(t, e, n, i, a, o) {
            r.a.call(this, t, e, n, n, i, a, o)
        }
        var r = n("PXdy");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i
    },
    JzlU: function(t, e, n) {
        "use strict";

        function i(t, e, n) {
            this.name = t,
            this.tracks = n,
            this.duration = undefined !== e ? e: -1,
            this.uuid = c.a.generateUUID(),
            this.duration < 0 && this.resetDuration(),
            this.optimize()
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("j6+M"),
        a = n("RRa1"),
        o = n("pINk"),
        s = n("4W4M"),
        u = n("TiW2"),
        c = n("_Math");
        Object.assign(i, {
            parse: function(t) {
                for (var e = [], n = t.tracks, r = 1 / (t.fps || 1), a = 0, o = n.length; a !== o; ++a) e.push(u.a.parse(n[a]).scale(r));
                return new i(t.name, t.duration, e)
            },
            toJSON: function(t) {
                for (var e = [], n = t.tracks, i = {
                    name: t.name,
                    duration: t.duration,
                    tracks: e
                },
                r = 0, a = n.length; r !== a; ++r) e.push(u.a.toJSON(n[r]));
                return i
            },
            CreateFromMorphTargetSequence: function(t, e, n, r) {
                for (var a = e.length,
                u = [], c = 0; c < a; c++) {
                    var h = [],
                    l = [];
                    h.push((c + a - 1) % a, c, (c + 1) % a),
                    l.push(0, 1, 0);
                    var f = s.a.getKeyframeOrder(h);
                    h = s.a.sortedArray(h, 1, f),
                    l = s.a.sortedArray(l, 1, f),
                    r || 0 !== h[0] || (h.push(a), l.push(l[0])),
                    u.push(new o.a(".morphTargetInfluences[" + e[c].name + "]", h, l).scale(1 / n))
                }
                return new i(t, -1, u)
            },
            findByName: function(t, e) {
                var n = t;
                if (!Array.isArray(t)) {
                    var i = t;
                    n = i.geometry && i.geometry.animations || i.animations
                }
                for (var r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(t, e, n) {
                for (var r = {},
                a = /^([\\w-]*?)([\\d]+)$/,
                o = 0,
                s = t.length; o < s; o++) {
                    var u = t[o],
                    c = u.name.match(a);
                    if (c && c.length > 1) {
                        var h = c[1],
                        l = r[h];
                        l || (r[h] = l = []),
                        l.push(u)
                    }
                }
                var f = [];
                for (var h in r) f.push(i.CreateFromMorphTargetSequence(h, r[h], e, n));
                return f
            },
            parseAnimation: function(t, e) {
                if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
                for (var n = function(t, e, n, i, r) {
                    if (0 !== n.length) {
                        var a = [],
                        o = [];
                        s.a.flattenJSON(n, a, o, i),
                        0 !== a.length && r.push(new t(e, a, o))
                    }
                },
                u = [], c = t.name || "default", h = t.length || -1, l = t.fps || 30, f = t.hierarchy || [], p = 0; p < f.length; p++) {
                    var d = f[p].keys;
                    if (d && 0 !== d.length) if (d[0].morphTargets) {
                        for (var m = {},
                        v = 0; v < d.length; v++) if (d[v].morphTargets) for (var g = 0; g < d[v].morphTargets.length; g++) m[d[v].morphTargets[g]] = -1;
                        for (var y in m) {
                            for (var _ = [], x = [], g = 0; g !== d[v].morphTargets.length; ++g) {
                                var b = d[v];
                                _.push(b.time),
                                x.push(b.morphTarget === y ? 1 : 0)
                            }
                            u.push(new o.a(".morphTargetInfluence[" + y + "]", _, x))
                        }
                        h = m.length * (l || 1)
                    } else {
                        var w = ".bones[" + e[p].name + "]";
                        n(r.a, w + ".position", d, "pos", u),
                        n(a.a, w + ".quaternion", d, "rot", u),
                        n(r.a, w + ".scale", d, "scl", u)
                    }
                }
                return 0 === u.length ? null: new i(c, h, u)
            }
        }),
        Object.assign(i.prototype, {
            resetDuration: function() {
                for (var t = this.tracks,
                e = 0,
                n = 0,
                i = t.length; n !== i; ++n) {
                    var r = this.tracks[n];
                    e = Math.max(e, r.times[r.times.length - 1])
                }
                this.duration = e
            },
            trim: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                return this
            },
            optimize: function() {
                for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                return this
            }
        })
    },
    K61l: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return a
        });
        var i = n("3JDn"),
        r = n("P0pb"),
        a = function() {
            function t() {
                this.name = i.b.Stacking,
                this.enable = true,
                this.stacking = new r.a
            }
            return t.prototype.onInitialize = function(t) {
                this.setViewer(t)
            },
            t.prototype.setViewer = function(t) {
                var e = t.getEngine();
                this.stacking.setWebGLRenderer(e.renderer)
            },
            t
        } ()
    },
    "PopModelItem1": function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return a
        });
        // var i = n("PopModelHeader"),
        r = n("PopGroups"),
        a = function() {
            function t() {}
            return t.prototype.readFromStream = function(t) {
                this.header = new PopModelHeader(),
                this.header.readFromStream(t),
                this.groups = [];
                for (var e = 0; e < this.header.attributes.groupCount; e++) {
                    var n = new PopGroups();
                    n.readFromStream(t),
                    this.groups.push(n)
                }
                this.computeAdditionalFileAttributes()
            },
            t.prototype.computeAdditionalFileAttributes = function() {
                var t = this.header.attributes;
                t.faceCount = 0,
                t.vertexCount = 0,
                t.blockFaceCounts = new Array(t.blockNames.length).fill(0),
                this.groups.forEach(function(e) {
                    return e.chunks.forEach(function(e) {
                        var n = e.header,
                        i = e.content,
                        r = i.indices.length / 3,
                        a = i.vertices.length / 3;
                        t.faceCount += r,
                        t.blockFaceCounts[n.objIndex] += r,
                        t.vertexCount += a
                    })
                })
            },
            t
        } ()
    },
    KFR5: function(t, e, n) {
        "use strict";

        function i(t) {
            this.manager = undefined !== t ? t: s.a,
            this._parser = null
        }
        var r = n("RBSo"),
        a = n("w2Sq"),
        o = n("iQTO"),
        s = n("OJZr");
        Object.assign(i.prototype, {
            load: function(t, e, n, i) {
                var s = this,
                u = [],
                c = new o.a;
                c.image = u;
                var h = new a.a(this.manager);
                if (h.setPath(this.path), h.setResponseType("arraybuffer"), Array.isArray(t)) for (var l = 0,
                f = 0,
                p = t.length; f < p; ++f) !
                function(a) {
                    h.load(t[a],
                    function(t) {
                        var n = s._parser(t, true);
                        u[a] = {
                            width: n.width,
                            height: n.height,
                            format: n.format,
                            mipmaps: n.mipmaps
                        },
                        6 === (l += 1) && (1 === n.mipmapCount && (c.minFilter = r.Q), c.format = n.format, c.needsUpdate = true, e && e(c))
                    },
                    n, i)
                } (f);
                else h.load(t,
                function(t) {
                    var n = s._parser(t, true);
                    if (n.isCubemap) for (var i = n.mipmaps.length / n.mipmapCount,
                    a = 0; a < i; a++) {
                        u[a] = {
                            mipmaps: []
                        };
                        for (var o = 0; o < n.mipmapCount; o++) u[a].mipmaps.push(n.mipmaps[a * n.mipmapCount + o]),
                        u[a].format = n.format,
                        u[a].width = n.width,
                        u[a].height = n.height
                    } else c.image.width = n.width,
                    c.image.height = n.height,
                    c.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (c.minFilter = r.Q),
                    c.format = n.format,
                    c.needsUpdate = true,
                    e && e(c)
                },
                n, i);
                return c
            },
            setPath: function(t) {
                return this.path = t,
                this
            }
        })
    },
    MeshStandardMaterial: function(t, e, n) {
        "use strict";

        function i(t) {
            r.a.call(this),
            this.defines = {
                STANDARD: ""
            },
            this.type = "MeshStandardMaterial",
            this.color = new o.a(16777215),
            this.roughness = .5,
            this.metalness = .5,
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new o.a(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.bumpMap = null,
            this.bumpScale = 1,
            this.normalMap = null,
            this.normalScale = new a.a(1, 1),
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.roughnessMap = null,
            this.metalnessMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.envMapIntensity = 1,
            this.refractionRatio = .98,
            this.wireframe = false,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = false,
            this.morphTargets = false,
            this.morphNormals = false,
            this.setValues(t)
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("Material"),
        a = n("Vector2"),
        o = n("Color");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.isMeshStandardMaterial = true,
        i.prototype.copy = function(t) {
            return r.a.prototype.copy.call(this, t),
            this.defines = {
                STANDARD: ""
            },
            this.color.copy(t.color),
            this.roughness = t.roughness,
            this.metalness = t.metalness,
            this.map = t.map,
            this.lightMap = t.lightMap,
            this.lightMapIntensity = t.lightMapIntensity,
            this.aoMap = t.aoMap,
            this.aoMapIntensity = t.aoMapIntensity,
            this.emissive.copy(t.emissive),
            this.emissiveMap = t.emissiveMap,
            this.emissiveIntensity = t.emissiveIntensity,
            this.bumpMap = t.bumpMap,
            this.bumpScale = t.bumpScale,
            this.normalMap = t.normalMap,
            this.normalScale.copy(t.normalScale),
            this.displacementMap = t.displacementMap,
            this.displacementScale = t.displacementScale,
            this.displacementBias = t.displacementBias,
            this.roughnessMap = t.roughnessMap,
            this.metalnessMap = t.metalnessMap,
            this.alphaMap = t.alphaMap,
            this.envMap = t.envMap,
            this.envMapIntensity = t.envMapIntensity,
            this.refractionRatio = t.refractionRatio,
            this.wireframe = t.wireframe,
            this.wireframeLinewidth = t.wireframeLinewidth,
            this.wireframeLinecap = t.wireframeLinecap,
            this.wireframeLinejoin = t.wireframeLinejoin,
            this.skinning = t.skinning,
            this.morphTargets = t.morphTargets,
            this.morphNormals = t.morphNormals,
            this
        }
    },
    KYnm: function(t, e, n) {
        "use strict";

        function i(t, e, n, i) {
            r.a.call(this),
            this.v0 = t,
            this.v1 = e,
            this.v2 = n,
            this.v3 = i
        }
        var r = n("Lk8y"),
        a = n("JJh5"),
        o = n("Vector3");
        i.prototype = Object.create(r.a.prototype),
        i.prototype.constructor = i,
        i.prototype.getPoint = function(t) {
            var e = this.v0,
            n = this.v1,
            i = this.v2,
            r = this.v3;
            return new o.a(Object(a.b)(t, e.x, n.x, i.x, r.x), Object(a.b)(t, e.y, n.y, i.y, r.y), Object(a.b)(t, e.z, n.z, i.z, r.z))
        }
    },
    L5nJ: function(t, e, n) {
        "use strict";
        e.a = "#ifdef USE_MAP\\n\\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n"
    },
    LKd5: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return r
        }),
        n.d(e, "b",
        function() {
            return a
        });
        var i = n("coYL"),
        r = new i.a,
        a = new i.a
    },
    LL6t: function(t, e, n) {
        "use strict";
        n.d(e, "a",
        function() {
            return a
        });
        var i = n("QwP0"),
        r = n("/Ev4"),
        a = {
            uniforms: {
                tDiffuse: {
                    value: null
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: r.a,
            fragmentShader: i.a
        }
    },
    LLkA: function(t, e, n) {
        "use strict";

        function i(t, e) {
            switch (e) {
            case c.a.FRONT:
            case c.a.BACK:
                return new Vector3(t.x, t.z, t.y);
            case c.a.TOP:
            case c.a.BOTTOM:
                return new Vector3(t.x, t.y, t.z);
            default:
                throw new Error("type not defined: " + e)
            }
        }

        function r(t, e) {
            switch (e) {
            case c.a.TOP:
                return new Vector3(0, 0, t.z / 2);
            case c.a.BOTTOM:
                return new Vector3(0, 0, -t.z / 2);
            case c.a.FRONT:
                return new Vector3(0, -t.y / 2, 0);
            case c.a.BACK:
                return new Vector3(0, t.y / 2, 0);
            default:
                throw new Error("type not defined: " + e)
            }
        }

        function a(t, e) {
            var n = e,
            a = i(n, t),
            o = r(n, t),
            c = new s.w(32, 32, 32, 32),
            h = a.x / 2,
            l = a.y / 2;
            c.position.copy(o),
            c.left = -h,
            c.right = h,
            c.top = l,
            c.bottom = -l,
            c.near = 0,
            c.far = a.z,
            c.lookAt(new s.J(0, 0, 0)),
            c.updateProjectionMatrix();
            var f = new s.p;
            return f.multiplyMatrices(c.projectionMatrix, f.getInverse(c.matrixWorld)),
            new u.a([0], 1, 1, f, new s.I(a.x, a.y))
        }
        e.b = a;
        var o = n("v504"),
        s = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
        u = n("hLA2"),
        c = n("4Ww7"),
        h = n("dw8z"),
        l = function() {
            function t() {
                this.scale = new s.J,
                this.rotation = new s.l,
                this.position = new s.J
            }
            return t.prototype.save = function(t) {
                return this.scale.copy(t.scale),
                this.rotation.copy(t.rotation),
                this.position.copy(t.position),
                this.parent = t.parent,
                this
            },
            t.prototype.restore = function(t) {
                return t.scale.copy(this.scale),
                t.rotation.copy(this.rotation),
                t.position.copy(this.position),
                this
            },
            t
        } (),
        f = {},
        p = function() {
            function t(t) {
                this.renderer = t,
                this.scene = new s.C,
                this.camera = new s.w(32, 32, 32, 32),
                this.camera.up = new s.J(0, 1, 0),
                this.renderTargetOptions = {
                    minFilter: s.u,
                    magFilter: s.u,
                    format: s.z
                },
                this.depthPacking = s.b,
                this.depthMaterial = new s.s({
                    side: s.i,
                    depthPacking: this.depthPacking
                }),
                this.scene.overrideMaterial = this.depthMaterial
            }
            return t.prototype.add = function(t) {
                var e = new l;
                e.save(t),
                f[t.uuid] = e,
                t.scale.set(1, 1, 1),
                t.rotation.set(0, 0, 0),
                t.position.set(0, 0, 0),
                this.scene.add(t)
            },
            t.prototype.remove = function(t) {
                var e = f[t.uuid];
                e.restore(t),
                e.parent && e.parent.add(t),
                delete f[t.uuid],
                this.scene.remove(t)
            },
            t.prototype.setupCamera = function(t, e) {
                var n = t.x / 2,
                i = t.y / 2;
                this.camera.position.copy(e),
                this.camera.left = -n,
                this.camera.right = n,
                this.camera.top = i,
                this.camera.bottom = -i,
                this.camera.near = 0,
                this.camera.far = t.z,
                this.camera.lookAt(new s.J(0, 0, 0)),
                this.camera.updateProjectionMatrix()
            },
            t.prototype.readPixels = function(t, e) {
                var n = new o.a(t, e, this.renderTargetOptions),
                i = new Uint8Array(4 * t * e),
                r = this.renderer.getClearColor().clone();
                this.renderer.setClearColor(16777215, 1),
                this.renderer.render(this.scene, this.camera, n, true),
                this.renderer.setClearColor(r);
                var a = this.renderer.getContext(),
                s = this.renderer.properties.get(n).__webglFramebuffer;
                return a.bindFramebuffer(a.FRAMEBUFFER, s),
                a.readPixels(0, 0, t, e, a.RGBA, a.UNSIGNED_BYTE, i),
                a.bindFramebuffer(a.FRAMEBUFFER, null),
                n.dispose(),
                i
            },
            t.prototype.generate = function(t, e, n) {
                this.add(t);
                var a = n,
                o = i(a, e),
                c = r(a, e);
                this.setupCamera(o, c);
                var l = 64 / Math.max(o.x, o.y),
                f = Math.ceil(o.x * l),
                p = Math.ceil(o.y * l),
                d = this.readPixels(f, p),
                m = Object(h.a)(d, f, p, this.depthPacking === s.y),
                v = new s.p;
                return v.multiplyMatrices(this.camera.projectionMatrix, v.getInverse(this.camera.matrixWorld)),
                this.remove(t),
                new u.a(m, f, p, v, new s.I(o.x, o.y))
            },
            t
        } ();
        e.a = p
    },
    LWBF: function(t, e, n) {
        "use strict";

        function i() {
            this.onLoadStart = function() {},
            this.onLoadProgress = function() {},
            this.onLoadComplete = function() {}
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("RBSo"),
        a = n("_Math"),
        o = n("6Q3k"),
        s = n("N570"),
        u = n("Color");
        i.Handlers = {
            handlers: [],
            add: function(t, e) {
                this.handlers.push(t, e)
            },
            get: function(t) {
                for (var e = this.handlers,
                n = 0,
                i = e.length; n < i; n += 2) {
                    var r = e[n],
                    a = e[n + 1];
                    if (r.test(t)) return a
                }
                return null
            }
        },
        Object.assign(i.prototype, {
            crossOrigin: undefined,
            extractUrlBase: function(t) {
                var e = t.split("/");
                return 1 === e.length ? "./": (e.pop(), e.join("/") + "/")
            },
            initMaterials: function(t, e, n) {
                for (var i = [], r = 0; r < t.length; ++r) i[r] = this.createMaterial(t[r], e, n);
                return i
            },
            createMaterial: function() {
                var t = {
                    NoBlending: r._9,
                    NormalBlending: r._12,
                    AdditiveBlending: r.c,
                    SubtractiveBlending: r._47,
                    MultiplyBlending: r._3,
                    CustomBlending: r.r
                },
                e = new u.a,
                n = new s.a,
                c = new o.a;
                return function(o, s, u) {
                    function h(t, e, o, c, h) {
                        var f, p = s + t,
                        d = i.Handlers.get(p);
                        null !== d ? f = d.load(p) : (n.setCrossOrigin(u), f = n.load(p)),
                        undefined !== e && (f.repeat.fromArray(e), 1 !== e[0] && (f.wrapS = r._38), 1 !== e[1] && (f.wrapT = r._38)),
                        undefined !== o && f.offset.fromArray(o),
                        undefined !== c && ("repeat" === c[0] && (f.wrapS = r._38), "mirror" === c[0] && (f.wrapS = r._1), "repeat" === c[1] && (f.wrapT = r._38), "mirror" === c[1] && (f.wrapT = r._1)),
                        undefined !== h && (f.anisotropy = h);
                        var m = a.a.generateUUID();
                        return l[m] = f,
                        m
                    }
                    var l = {},
                    f = {
                        uuid: a.a.generateUUID(),
                        type: "MeshLambertMaterial"
                    };
                    for (var p in o) {
                        var d = o[p];
                        switch (p) {
                        case "DbgColor":
                        case "DbgIndex":
                        case "opticalDensity":
                        case "illumination":
                            break;
                        case "DbgName":
                            f.name = d;
                            break;
                        case "blending":
                            f.blending = t[d];
                            break;
                        case "colorAmbient":
                        case "mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", p, "is no longer supported.");
                            break;
                        case "colorDiffuse":
                            f.color = e.fromArray(d).getHex();
                            break;
                        case "colorSpecular":
                            f.specular = e.fromArray(d).getHex();
                            break;
                        case "colorEmissive":
                            f.emissive = e.fromArray(d).getHex();
                            break;
                        case "specularCoef":
                            f.shininess = d;
                            break;
                        case "shading":
                            "basic" === d.toLowerCase() && (f.type = "MeshBasicMaterial"),
                            "phong" === d.toLowerCase() && (f.type = "MeshPhongMaterial"),
                            "standard" === d.toLowerCase() && (f.type = "MeshStandardMaterial");
                            break;
                        case "mapDiffuse":
                            f.map = h(d, o.mapDiffuseRepeat, o.mapDiffuseOffset, o.mapDiffuseWrap, o.mapDiffuseAnisotropy);
                            break;
                        case "mapDiffuseRepeat":
                        case "mapDiffuseOffset":
                        case "mapDiffuseWrap":
                        case "mapDiffuseAnisotropy":
                            break;
                        case "mapEmissive":
                            f.emissiveMap = h(d, o.mapEmissiveRepeat, o.mapEmissiveOffset, o.mapEmissiveWrap, o.mapEmissiveAnisotropy);
                            break;
                        case "mapEmissiveRepeat":
                        case "mapEmissiveOffset":
                        case "mapEmissiveWrap":
                        case "mapEmissiveAnisotropy":
                            break;
                        case "mapLight":
                            f.lightMap = h(d, o.mapLightRepeat, o.mapLightOffset, o.mapLightWrap, o.mapLightAnisotropy);
                            break;
                        case "mapLightRepeat":
                        case "mapLightOffset":
                        case "mapLightWrap":
                        case "mapLightAnisotropy":
                            break;
                        case "mapAO":
                            f.aoMap = h(d, o.mapAORepeat, o.mapAOOffset, o.mapAOWrap, o.mapAOAnisotropy);
                            break;
                        case "mapAORepeat":
                        case "mapAOOffset":
                        case "mapAOWrap":
                        case "mapAOAnisotropy":
                            break;
                        case "mapBump":
                            f.bumpMap = h(d, o.mapBumpRepeat, o.mapBumpOffset, o.mapBumpWrap, o.mapBumpAnisotropy);
                            break;
                        case "mapBumpScale":
                            f.bumpScale = d;
                            break;
                        case "mapBumpRepeat":
                        case "mapBumpOffset":
                        case "mapBumpWrap":
                        case "mapBumpAnisotropy":
                            break;
                        case "mapNormal":
                            f.normalMap = h(d, o.mapNormalRepeat, o.mapNormalOffset, o.mapNormalWrap, o.mapNormalAnisotropy);
                            break;
                        case "mapNormalFactor":
                            f.normalScale = [d, d];
                            break;
                        case "mapNormalRepeat":
                        case "mapNormalOffset":
                        case "mapNormalWrap":
                        case "mapNormalAnisotropy":
                            break;
                        case "mapSpecular":
                            f.specularMap = h(d, o.mapSpecularRepeat, o.mapSpecularOffset, o.mapSpecularWrap, o.mapSpecularAnisotropy);
                            break;
                        case "mapSpecularRepeat":
                        case "mapSpecularOffset":
                        case "mapSpecularWrap":
                        case "mapSpecularAnisotropy":
                            break;
                        case "mapMetalness":
                            f.metalnessMap = h(d, o.mapMetalnessRepeat, o.mapMetalnessOffset, o.mapMetalnessWrap, o.mapMetalnessAnisotropy);
                            break;
                        case "mapMetalnessRepeat":
                        case "mapMetalnessOffset":
                        case "mapMetalnessWrap":
                        case "mapMetalnessAnisotropy":
                            break;
                        case "mapRoughness":
                            f.roughnessMap = h(d, o.mapRoughnessRepeat, o.mapRoughnessOffset, o.mapRoughnessWrap, o.mapRoughnessAnisotropy);
                            break;
                        case "mapRoughnessRepeat":
                        case "mapRoughnessOffset":
                        case "mapRoughnessWrap":
                        case "mapRoughnessAnisotropy":
                            break;
                        case "mapAlpha":
                            f.alphaMap = h(d, o.mapAlphaRepeat, o.mapAlphaOffset, o.mapAlphaWrap, o.mapAlphaAnisotropy);
                            break;
                        case "mapAlphaRepeat":
                        case "mapAlphaOffset":
                        case "mapAlphaWrap":
                        case "mapAlphaAnisotropy":
                            break;
                        case "flipSided":
                            f.side = r.f;
                            break;
                        case "doubleSided":
                            f.side = r.u;
                            break;
                        case "transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                            f.opacity = d;
                            break;
                        case "depthTest":
                        case "depthWrite":
                        case "colorWrite":
                        case "opacity":
                        case "reflectivity":
                        case "transparent":
                        case "visible":
                        case "wireframe":
                            f[p] = d;
                            break;
                        case "vertexColors":
                            true === d && (f.vertexColors = r._60),
                            "face" === d && (f.vertexColors = r.A);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", p, d)
                        }
                    }
                    return "MeshBasicMaterial" === f.type && delete f.emissive,
                    "MeshPhongMaterial" !== f.type && delete f.specular,
                    f.opacity < 1 && (f.transparent = true),
                    c.setTextures(l),
                    c.parse(f)
                }
            } ()
        })
    },
    "Lh+4": function(t, e, n) {
        "use strict";
        e.a = "varying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvWorldPosition = transformDirection( position, modelMatrix );\\n\\t#include <begin_vertex>\\n\\t#include <project_vertex>\\n}\\n"
    },
    Lk8y: function(t, e, n) {
        "use strict";

        function i() {
            this.arcLengthDivisions = 200
        }
        n.d(e, "a",
        function() {
            return i
        });
        var r = n("_Math"),
        a = n("Vector3"),
        o = n("Matrix4");
        Object.assign(i.prototype, {
            getPoint: function() {
                return console.warn("THREE.Curve: .getPoint() not implemented."),
                null
            },
            getPointAt: function(t) {
                var e = this.getUtoTmapping(t);
                return this.getPoint(e)
            },
            getPoints: function(t) {
                undefined === t && (t = 5);
                for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                return e
            },
            getSpacedPoints: function(t) {
                undefined === t && (t = 5);
                for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                return e
            },
            getLength: function() {
                var t = this.getLengths();
                return t[t.length - 1]
            },
            getLengths: function(t) {
                if (undefined === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = false;
                var e, n, i = [],
                r = this.getPoint(0),
                a = 0;
                for (i.push(0), n = 1; n <= t; n++) e = this.getPoint(n / t),
                a += e.distanceTo(r),
                i.push(a),
                r = e;
                return this.cacheArcLengths = i,
                i
            },
            updateArcLengths: function() {
                this.needsUpdate = true,
                this.getLengths()
            },
            getUtoTmapping: function(t, e) {
                var n, i = this.getLengths(),
                r = 0,
                a = i.length;
                n = e || t * i[a - 1];
                for (var o, s = 0,
                u = a - 1; s <= u;) if (r = Math.floor(s + (u - s) / 2), (o = i[r] - n) < 0) s = r + 1;
                else {
                    if (! (o > 0)) {
                        u = r;
                        break
                    }
                    u = r - 1
                }
                if (r = u, i[r] === n) return r / (a - 1);
                var c = i[r];
                return (r + (n - c) / (i[r + 1] - c)) / (a - 1)
            },
            getTangent: function(t) {
                var e = t - 1e-4,
                n = t + 1e-4;
                e < 0 && (e = 0),
                n > 1 && (n = 1);
                var i = this.getPoint(e);
                return this.getPoint(n).clone().sub(i).normalize()
            },
            getTangentAt: function(t) {
                var e = this.getUtoTmapping(t);
                return this.getTangent(e)
            },
            computeFrenetFrames: function(t, e) {
                var n, i, s, u = new a.a,
                c = [],
                h = [],
                l = [],
                f = new a.a,
                p = new o.a;
                for (n = 0; n <= t; n++) i = n / t,
                c[n] = this.getTangentAt(i),
                c[n].normalize();
                h[0] = new a.a,
                l[0] = new a.a;
                var d = Number.MAX_VALUE,
                m = Math.abs(c[0].x),
                v = Math.abs(c[0].y),
                g = Math.abs(c[0].z);
                for (m <= d && (d = m, u.set(1, 0, 0)), v <= d && (d = v, u.set(0, 1, 0)), g <= d && u.set(0, 0, 1), f.crossVectors(c[0], u).normalize(), h[0].crossVectors(c[0], f), l[0].crossVectors(c[0], h[0]), n = 1; n <= t; n++) h[n] = h[n - 1].clone(),
                l[n] = l[n - 1].clone(),
                f.crossVectors(c[n - 1], c[n]),
                f.length() > Number.EPSILON && (f.normalize(), s = Math.acos(r.a.clamp(c[n - 1].dot(c[n]), -1, 1)), h[n].applyMatrix4(p.makeRotationAxis(f, s))),
                l[n].crossVectors(c[n], h[n]);
                if (true === e) for (s = Math.acos(r.a.clamp(h[0].dot(h[t]), -1, 1)), s /= t, c[0].dot(f.crossVectors(h[0], h[t])) > 0 && (s = -s), n = 1; n <= t; n++) h[n].applyMatrix4(p.makeRotationAxis(c[n], s * n)),
                l[n].crossVectors(c[n], h[n]);
                return {
                    tangents: c,
                    normals: h,
                    binormals: l
                }
            }
        })
    },
    M4fF: function(t, e, n) { (function(t, i) {
            var r; (function() {
                function a(t, e, n) {
                    switch (n.length) {
                    case 0:
                        return t.call(e);
                    case 1:
                        return t.call(e, n[0]);
                    case 2:
                        return t.call(e, n[0], n[1]);
                    case 3:
                        return t.call(e, n[0], n[1], n[2])
                    }
                    return t.apply(e, n)
                }

                function o(t, e, n, i) {
                    for (var r = -1,
                    a = null == t ? 0 : t.length; ++r < a;) {
                        var o = t[r];
                        e(i, o, n(o), t)
                    }
                    return i
                }

                function s(t, e) {
                    for (var n = -1,
                    i = null == t ? 0 : t.length; ++n < i && false !== e(t[n], n, t););
                    return t
                }

                function u(t, e) {
                    for (var n = null == t ? 0 : t.length; n--&&false !== e(t[n], n, t););
                    return t
                }

                function c(t, e) {
                    for (var n = -1,
                    i = null == t ? 0 : t.length; ++n < i;) if (!e(t[n], n, t)) return ! 1;
                    return ! 0
                }

                function h(t, e) {
                    for (var n = -1,
                    i = null == t ? 0 : t.length, r = 0, a = []; ++n < i;) {
                        var o = t[n];
                        e(o, n, t) && (a[r++] = o)
                    }
                    return a
                }

                function l(t, e) {
                    return !! (null == t ? 0 : t.length) && w(t, e, 0) > -1
                }

                function f(t, e, n) {
                    for (var i = -1,
                    r = null == t ? 0 : t.length; ++i < r;) if (n(e, t[i])) return ! 0;
                    return ! 1
                }

                function p(t, e) {
                    for (var n = -1,
                    i = null == t ? 0 : t.length, r = Array(i); ++n < i;) r[n] = e(t[n], n, t);
                    return r
                }

                function d(t, e) {
                    for (var n = -1,
                    i = e.length,
                    r = t.length; ++n < i;) t[r + n] = e[n];
                    return t
                }

                function m(t, e, n, i) {
                    var r = -1,
                    a = null == t ? 0 : t.length;
                    for (i && a && (n = t[++r]); ++r < a;) n = e(n, t[r], r, t);
                    return n
                }

                function v(t, e, n, i) {
                    var r = null == t ? 0 : t.length;
                    for (i && r && (n = t[--r]); r--;) n = e(n, t[r], r, t);
                    return n
                }

                function g(t, e) {
                    for (var n = -1,
                    i = null == t ? 0 : t.length; ++n < i;) if (e(t[n], n, t)) return ! 0;
                    return ! 1
                }

                function y(t) {
                    return t.split("")
                }

                function _(t) {
                    return t.match(ze) || []
                }

                function x(t, e, n) {
                    var i;
                    return n(t,
                    function(t, n, r) {
                        if (e(t, n, r)) return i = n,
                        false
                    }),
                    i
                }

                function b(t, e, n, i) {
                    for (var r = t.length,
                    a = n + (i ? 1 : -1); i ? a--:++a < r;) if (e(t[a], a, t)) return a;
                    return - 1
                }

                function w(t, e, n) {
                    return e === e ? J(t, e, n) : b(t, S, n)
                }

                function M(t, e, n, i) {
                    for (var r = n - 1,
                    a = t.length; ++r < a;) if (i(t[r], e)) return r;
                    return - 1
                }

                function S(t) {
                    return t !== t
                }

                function E(t, e) {
                    var n = null == t ? 0 : t.length;
                    return n ? L(t, e) / n: Nt
                }

                function T(t) {
                    return function(e) {
                        return null == e ? it: e[t]
                    }
                }

                function A(t) {
                    return function(e) {
                        return null == t ? it: t[e]
                    }
                }

                function C(t, e, n, i, r) {
                    return r(t,
                    function(t, r, a) {
                        n = i ? (i = false, t) : e(n, t, r, a)
                    }),
                    n
                }

                function P(t, e) {
                    var n = t.length;
                    for (t.sort(e); n--;) t[n] = t[n].value;
                    return t
                }

                function L(t, e) {
                    for (var n, i = -1,
                    r = t.length; ++i < r;) {
                        var a = e(t[i]);
                        a !== it && (n = n === it ? a: n + a)
                    }
                    return n
                }

                function R(t, e) {
                    for (var n = -1,
                    i = Array(t); ++n < t;) i[n] = e(n);
                    return i
                }

                function I(t, e) {
                    return p(e,
                    function(e) {
                        return [e, t[e]]
                    })
                }

                function O(t) {
                    return function(e) {
                        return t(e)
                    }
                }

                function N(t, e) {
                    return p(e,
                    function(e) {
                        return t[e]
                    })
                }

                function D(t, e) {
                    return t.has(e)
                }

                function U(t, e) {
                    for (var n = -1,
                    i = t.length; ++n < i && w(e, t[n], 0) > -1;);
                    return n
                }

                function B(t, e) {
                    for (var n = t.length; n--&&w(e, t[n], 0) > -1;);
                    return n
                }

                function z(t, e) {
                    for (var n = t.length,
                    i = 0; n--;) t[n] === e && ++i;
                    return i
                }

                function F(t) {
                    return "\\\\" + Tn[t]
                }

                function j(t, e) {
                    return null == t ? it: t[e]
                }

                function k(t) {
                    return gn.test(t)
                }

                function V(t) {
                    return yn.test(t)
                }

                function G(t) {
                    for (var e, n = []; ! (e = t.next()).done;) n.push(e.value);
                    return n
                }

                function H(t) {
                    var e = -1,
                    n = Array(t.size);
                    return t.forEach(function(t, i) {
                        n[++e] = [i, t]
                    }),
                    n
                }

                function W(t, e) {
                    return function(n) {
                        return t(e(n))
                    }
                }

                function X(t, e) {
                    for (var n = -1,
                    i = t.length,
                    r = 0,
                    a = []; ++n < i;) {
                        var o = t[n];
                        o !== e && o !== ct || (t[n] = ct, a[r++] = n)
                    }
                    return a
                }

                function q(t, e) {
                    return "__proto__" == e ? it: t[e]
                }

                function Y(t) {
                    var e = -1,
                    n = Array(t.size);
                    return t.forEach(function(t) {
                        n[++e] = t
                    }),
                    n
                }

                function Z(t) {
                    var e = -1,
                    n = Array(t.size);
                    return t.forEach(function(t) {
                        n[++e] = [t, t]
                    }),
                    n
                }

                function J(t, e, n) {
                    for (var i = n - 1,
                    r = t.length; ++i < r;) if (t[i] === e) return i;
                    return - 1
                }

                function Q(t, e, n) {
                    for (var i = n + 1; i--;) if (t[i] === e) return i;
                    return i
                }

                function K(t) {
                    return k(t) ? tt(t) : Gn(t)
                }

                function $(t) {
                    return k(t) ? et(t) : y(t)
                }

                function tt(t) {
                    for (var e = mn.lastIndex = 0; mn.test(t);)++e;
                    return e
                }

                function et(t) {
                    return t.match(mn) || []
                }

                function nt(t) {
                    return t.match(vn) || []
                }
                var it,rt=200,at="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",ot="Expected a function",st="__lodash_hash_undefined__",ut=500,ct="__lodash_placeholder__",ht=1,lt=2,ft=4,pt=1,dt=2,mt=1,vt=2,gt=4,yt=8,_t=16,xt=32,bt=64,wt=128,Mt=256,St=512,Et=30,Tt="...",At=800,Ct=16,Pt=1,Lt=2,Rt=1/0,It=9007199254740991,Ot=1.7976931348623157e308,Nt=NaN,Dt=4294967295,Ut=Dt-1,Bt=Dt>>>1,zt=[["ary",wt],["bind",mt],["bindKey",vt],["curry",yt],["curryRight",_t],["flip",St],["partial",xt],["partialRight",bt],["rearg",Mt]],Ft="[object Arguments]",jt="[object Array]",kt="[object AsyncFunction]",Vt="[object Boolean]",Gt="[object Date]",Ht="[object DOMException]",Wt="[object Error]",Xt="[object Function]",qt="[object GeneratorFunction]",Yt="[object Map]",Zt="[object Number]",Jt="[object Null]",Qt="[object Object]",Kt="[object Proxy]",$t="[object RegExp]",te="[object Set]",ee="[object String]",ne="[object Symbol]",ie="[object Undefined]",re="[object WeakMap]",ae="[object WeakSet]",oe="[object ArrayBuffer]",se="[object DataView]",ue="[object Float32Array]",ce="[object Float64Array]",he="[object Int8Array]",le="[object Int16Array]",fe="[object Int32Array]",pe="[object Uint8Array]",de="[object Uint8ClampedArray]",me="[object Uint16Array]",ve="[object Uint32Array]",ge=/\b__p \+= '';/g,ye=/\b(__p \+=) '' \+/g,_e=/(__e\(.*?\)|\b__t\)) \+\n'';/g,xe=/&(?:amp|lt|gt|quot|#39);/g,be=/[&<>"\']/g,we=RegExp(xe.source),Me=RegExp(be.source),Se=/<%-([\s\S]+?)%>/g,Ee=/<%([\s\S]+?)%>/g,Te=/<%=([\s\S]+?)%>/g,Ae=/\.|\[(?:[^[\]]*|(["\'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,Ce=/^\w*$/,Pe=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["\'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Le=/[\\^$.*+?()[\]{}|]/g,Re=RegExp(Le.source),Ie=/^\s+|\s+$/g,Oe=/^\s+/,Ne=/\s+$/,De=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Ue=/\{\n\/\* \[wrapped with (.+)\] \*/,Be=/,? & /,ze=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Fe=/\\(\\)?/g,je=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,ke=/\w*$/,Ve=/^[-+]0x[0-9a-f]+$/i,Ge=/^0b[01]+$/i,He=/^\[object .+?Constructor\]$/,We=/^0o[0-7]+$/i,Xe=/^(?:0|[1-9]\d*)$/,qe=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ye=/($^)/,Ze=/[\'\n\r\u2028\u2029\\]/g,Je="\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff",Qe="\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",Ke="["+Qe+"]",$e="["+Je+"]",tn="[a-z\\xdf-\\xf6\\xf8-\\xff]",en="[^\\ud800-\\udfff"+Qe+"\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde]",nn="\\ud83c[\\udffb-\\udfff]",rn="(?:\\ud83c[\\udde6-\\uddff]){2}",an="[\\ud800-\\udbff][\\udc00-\\udfff]",on="[A-Z\\xc0-\\xd6\\xd8-\\xde]",sn="(?:"+tn+"|"+en+")",un="(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?",cn="(?:\\u200d(?:"+["[^\\ud800-\\udfff]",rn,an].join("|")+")[\\ufe0e\\ufe0f]?"+un+")*",hn="[\\ufe0e\\ufe0f]?"+un+cn,ln="(?:"+["[\\u2700-\\u27bf]",rn,an].join("|")+")"+hn,fn="(?:"+["[^\\ud800-\\udfff]"+$e+"?",$e,rn,an,"[\\ud800-\\udfff]"].join("|")+")",pn=RegExp("[\']","g"),dn=RegExp($e,"g"),mn=RegExp(nn+"(?="+nn+")|"+fn+hn,"g"),vn=RegExp([on+"?"+tn+"+(?:[\'](?:d|ll|m|re|s|t|ve))?(?="+[Ke,on,"$"].join("|")+")","(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:[\'](?:D|LL|M|RE|S|T|VE))?(?="+[Ke,on+sn,"$"].join("|")+")",on+"?"+sn+"+(?:[\'](?:d|ll|m|re|s|t|ve))?",on+"+(?:[\'](?:D|LL|M|RE|S|T|VE))?","\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])","\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])","\\d+",ln].join("|"),"g"),gn=RegExp("[\\u200d\\ud800-\\udfff"+Je+"\\ufe0e\\ufe0f]"),yn=/[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,_n=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],xn=-1,bn={};bn[ue]=bn[ce]=bn[he]=bn[le]=bn[fe]=bn[pe]=bn[de]=bn[me]=bn[ve]=true,bn[Ft]=bn[jt]=bn[oe]=bn[Vt]=bn[se]=bn[Gt]=bn[Wt]=bn[Xt]=bn[Yt]=bn[Zt]=bn[Qt]=bn[$t]=bn[te]=bn[ee]=bn[re]=false;var wn={};wn[Ft]=wn[jt]=wn[oe]=wn[se]=wn[Vt]=wn[Gt]=wn[ue]=wn[ce]=wn[he]=wn[le]=wn[fe]=wn[Yt]=wn[Zt]=wn[Qt]=wn[$t]=wn[te]=wn[ee]=wn[ne]=wn[pe]=wn[de]=wn[me]=wn[ve]=true,wn[Wt]=wn[Xt]=wn[re]=false;var Mn={"":"A","":"A","":"A","":"A","":"A","":"A","":"a","":"a","":"a","":"a","":"a","":"a","":"C","":"c","":"D","":"d","":"E","":"E","":"E","":"E","":"e","":"e","":"e","":"e","":"I","":"I","":"I","":"I","":"i","":"i","":"i","":"i","":"N","":"n","":"O","":"O","":"O","":"O","":"O","":"O","":"o","":"o","":"o","":"o","":"o","":"o","":"U","":"U","":"U","":"U","":"u","":"u","":"u","":"u","":"Y","":"y","":"y","":"Ae","":"ae","":"Th","":"th","":"ss","":"A","":"A","":"A","":"a","":"a","":"a","":"C","":"C","":"C","":"C","":"c","":"c","":"c","":"c","":"D","":"D","":"d","":"d","":"E","":"E","":"E","":"E","":"E","":"e","":"e","":"e","":"e","":"e","":"G","":"G","":"G","":"G","":"g","":"g","":"g","":"g","":"H","":"H","":"h","":"h","":"I","":"I","":"I","":"I","":"I","":"i","":"i","":"i","":"i","":"i","":"J","":"j","":"K","":"k","":"k","":"L","":"L","":"L","":"L","":"L","":"l","":"l","":"l","":"l","":"l","":"N","":"N","":"N","":"N","":"n","":"n","":"n","":"n","":"O","":"O","":"O","":"o","":"o","":"o","":"R","":"R","":"R","":"r","":"r","":"r","":"S","":"S","":"S","":"S","":"s","":"s","":"s","":"s","":"T","":"T","":"T","":"t","":"t","":"t","":"U","":"U","":"U","":"U","":"U","":"U","":"u","":"u","":"u","":"u","":"u","":"u","":"W","":"w","":"Y","":"y","":"Y","":"Z","":"Z","":"Z","":"z","":"z","":"z","":"IJ","":"ij","":"Oe","":"oe","":"\'n","":"s"},Sn={"&":"&amp;","<":"&lt;",">":"&gt;",\'"\':"&quot;","\'":"&#39;"},En={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":\'"\',"&#39;":"\'"},Tn={"\\":"\\","\'":"\'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},An=parseFloat,Cn=parseInt,Pn="object"==typeof t&&t&&t.Object===Object&&t,Ln="object"==typeof self&&self&&self.Object===Object&&self,Rn=Pn||Ln||Function("return this")(),In="object"==typeof e&&e&&!e.nodeType&&e,On=In&&"object"==typeof i&&i&&!i.nodeType&&i,Nn=On&&On.exports===In,Dn=Nn&&Pn.process,Un=function(){try{var t=On&&On.require&&On.require("util").types;return t||Dn&&Dn.binding&&Dn.binding("util")}catch(t){}}(),Bn=Un&&Un.isArrayBuffer,zn=Un&&Un.isDate,Fn=Un&&Un.isMap,jn=Un&&Un.isRegExp,kn=Un&&Un.isSet,Vn=Un&&Un.isTypedArray,Gn=T("length"),Hn=A(Mn),Wn=A(Sn),Xn=A(En),

            Xn = A(En),
            qn = function t(e) {
                function n(t) {
                    if (eu(t) && !pf(t) && !(t instanceof y)) {
                        if (t instanceof r) return t;
                        if (fh.call(t, "__wrapped__")) return Qa(t)
                    }
                    return new r(t)
                }

                function i() {}

                function r(t, e) {
                    this.__wrapped__ = t,
                    this.__actions__ = [],
                    this.__chain__ = !!e,
                    this.__index__ = 0,
                    this.__values__ = it
                }

                function y(t) {
                    this.__wrapped__ = t,
                    this.__actions__ = [],
                    this.__dir__ = 1,
                    this.__filtered__ = false,
                    this.__iteratees__ = [],
                    this.__takeCount__ = Dt,
                    this.__views__ = []
                }

                function A() {
                    var t = new y(this.__wrapped__);
                    return t.__actions__ = Or(this.__actions__),
                    t.__dir__ = this.__dir__,
                    t.__filtered__ = this.__filtered__,
                    t.__iteratees__ = Or(this.__iteratees__),
                    t.__takeCount__ = this.__takeCount__,
                    t.__views__ = Or(this.__views__),
                    t
                }

                function J() {
                    if (this.__filtered__) {
                        var t = new y(this);
                        t.__dir__ = -1,
                        t.__filtered__ = true
                    } else t = this.clone(),
                    t.__dir__ *= -1;
                    return t
                }

                function tt() {
                    var t = this.__wrapped__.value(),
                    e = this.__dir__,
                    n = pf(t),
                    i = e < 0,
                    r = n ? t.length: 0,
                    a = wa(0, r, this.__views__),
                    o = a.start,
                    s = a.end,
                    u = s - o,
                    c = i ? s: o - 1,
                    h = this.__iteratees__,
                    l = h.length,
                    f = 0,
                    p = Vh(u, this.__takeCount__);
                    if (!n || !i && r == u && p == u) return vr(t, this.__actions__);
                    var d = [];
                    t: for (; u--&&f < p;) {
                        c += e;
                        for (var m = -1,
                        v = t[c]; ++m < l;) {
                            var g = h[m],
                            y = g.iteratee,
                            _ = g.type,
                            x = y(v);
                            if (_ == Lt) v = x;
                            else if (!x) {
                                if (_ == Pt) continue t;
                                break t
                            }
                        }
                        d[f++] = v
                    }
                    return d
                }

                function et(t) {
                    var e = -1,
                    n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n;) {
                        var i = t[e];
                        this.set(i[0], i[1])
                    }
                }

                function ze() {
                    this.__data__ = Kh ? Kh(null) : {},
                    this.size = 0
                }

                function Je(t) {
                    var e = this.has(t) && delete this.__data__[t];
                    return this.size -= e ? 1 : 0,
                    e
                }

                function Qe(t) {
                    var e = this.__data__;
                    if (Kh) {
                        var n = e[t];
                        return n === st ? it: n
                    }
                    return fh.call(e, t) ? e[t] : it
                }

                function Ke(t) {
                    var e = this.__data__;
                    return Kh ? e[t] !== it: fh.call(e, t)
                }

                function $e(t, e) {
                    var n = this.__data__;
                    return this.size += this.has(t) ? 0 : 1,
                    n[t] = Kh && e === it ? st: e,
                    this
                }

                function tn(t) {
                    var e = -1,
                    n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n;) {
                        var i = t[e];
                        this.set(i[0], i[1])
                    }
                }

                function en() {
                    this.__data__ = [],
                    this.size = 0
                }

                function nn(t) {
                    var e = this.__data__,
                    n = Yn(e, t);
                    return ! (n < 0) && (n == e.length - 1 ? e.pop() : Th.call(e, n, 1), --this.size, true)
                }

                function rn(t) {
                    var e = this.__data__,
                    n = Yn(e, t);
                    return n < 0 ? it: e[n][1]
                }

                function an(t) {
                    return Yn(this.__data__, t) > -1
                }

                function on(t, e) {
                    var n = this.__data__,
                    i = Yn(n, t);
                    return i < 0 ? (++this.size, n.push([t, e])) : n[i][1] = e,
                    this
                }

                function sn(t) {
                    var e = -1,
                    n = null == t ? 0 : t.length;
                    for (this.clear(); ++e < n;) {
                        var i = t[e];
                        this.set(i[0], i[1])
                    }
                }

                function un() {
                    this.size = 0,
                    this.__data__ = {
                        hash: new et,
                        map: new(Yh || tn),
                        string: new et
                    }
                }

                function cn(t) {
                    var e = ya(this, t).delete(t);
                    return this.size -= e ? 1 : 0,
                    e
                }

                function hn(t) {
                    return ya(this, t).get(t)
                }

                function ln(t) {
                    return ya(this, t).has(t)
                }

                function fn(t, e) {
                    var n = ya(this, t),
                    i = n.size;
                    return n.set(t, e),
                    this.size += n.size == i ? 0 : 1,
                    this
                }

                function mn(t) {
                    var e = -1,
                    n = null == t ? 0 : t.length;
                    for (this.__data__ = new sn; ++e < n;) this.add(t[e])
                }

                function vn(t) {
                    return this.__data__.set(t, st),
                    this
                }

                function gn(t) {
                    return this.__data__.has(t)
                }

                function yn(t) {
                    var e = this.__data__ = new tn(t);
                    this.size = e.size
                }

                function Mn() {
                    this.__data__ = new tn,
                    this.size = 0
                }

                function Sn(t) {
                    var e = this.__data__,
                    n = e.delete(t);
                    return this.size = e.size,
                    n
                }

                function En(t) {
                    return this.__data__.get(t)
                }

                function Tn(t) {
                    return this.__data__.has(t)
                }

                function Pn(t, e) {
                    var n = this.__data__;
                    if (n instanceof tn) {
                        var i = n.__data__;
                        if (!Yh || i.length < rt - 1) return i.push([t, e]),
                        this.size = ++n.size,
                        this;
                        n = this.__data__ = new sn(i)
                    }
                    return n.set(t, e),
                    this.size = n.size,
                    this
                }

                function Ln(t, e) {
                    var n = pf(t),
                    i = !n && ff(t),
                    r = !n && !i && mf(t),
                    a = !n && !i && !r && xf(t),
                    o = n || i || r || a,
                    s = o ? R(t.length, ah) : [],
                    u = s.length;
                    for (var c in t) ! e && !fh.call(t, c) || o && ("length" == c || r && ("offset" == c || "parent" == c) || a && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || La(c, u)) || s.push(c);
                    return s
                }

                function In(t) {
                    var e = t.length;
                    return e ? t[Qi(0, e - 1)] : it
                }

                function On(t, e) {
                    return qa(Or(t), ti(e, 0, t.length))
                }

                function Dn(t) {
                    return qa(Or(t))
                }

                function Un(t, e, n) { (n === it || ks(t[e], n)) && (n !== it || e in t) || Kn(t, e, n)
                }

                function Gn(t, e, n) {
                    var i = t[e];
                    fh.call(t, e) && ks(i, n) && (n !== it || e in t) || Kn(t, e, n)
                }

                function Yn(t, e) {
                    for (var n = t.length; n--;) if (ks(t[n][0], e)) return n;
                    return - 1
                }

                function Zn(t, e, n, i) {
                    return hl(t,
                    function(t, r, a) {
                        e(i, t, n(t), a)
                    }),
                    i
                }

                function Jn(t, e) {
                    return t && Nr(e, Uu(e), t)
                }

                function Qn(t, e) {
                    return t && Nr(e, Bu(e), t)
                }

                function Kn(t, e, n) {
                    "__proto__" == e && Lh ? Lh(t, e, {
                        configurable: true,
                        enumerable: true,
                        value: n,
                        writable: true
                    }) : t[e] = n
                }

                function $n(t, e) {
                    for (var n = -1,
                    i = e.length,
                    r = Kc(i), a = null == t; ++n < i;) r[n] = a ? it: Ou(t, e[n]);
                    return r
                }

                function ti(t, e, n) {
                    return t === t && (n !== it && (t = t <= n ? t: n), e !== it && (t = t >= e ? t: e)),
                    t
                }

                function ei(t, e, n, i, r, a) {
                    var o, u = e & ht,
                    c = e & lt,
                    h = e & ft;
                    if (n && (o = r ? n(t, i, r, a) : n(t)), o !== it) return o;
                    if (!tu(t)) return t;
                    var l = pf(t);
                    if (l) {
                        if (o = Ea(t), !u) return Or(t, o)
                    } else {
                        var f = wl(t),
                        p = f == Xt || f == qt;
                        if (mf(t)) return Mr(t, u);
                        if (f == Qt || f == Ft || p && !r) {
                            if (o = c || p ? {}: Ta(t), !u) return c ? Ur(t, Qn(o, t)) : Dr(t, Jn(o, t))
                        } else {
                            if (!wn[f]) return r ? t: {};
                            o = Aa(t, f, u)
                        }
                    }
                    a || (a = new yn);
                    var d = a.get(t);
                    if (d) return d;
                    if (a.set(t, o), _f(t)) return t.forEach(function(i) {
                        o.add(ei(i, e, n, i, t, a))
                    }),
                    o;
                    if (gf(t)) return t.forEach(function(i, r) {
                        o.set(r, ei(i, e, n, r, t, a))
                    }),
                    o;
                    var m = h ? c ? da: pa: c ? Bu: Uu,
                    v = l ? it: m(t);
                    return s(v || t,
                    function(i, r) {
                        v && (r = i, i = t[r]),
                        Gn(o, r, ei(i, e, n, r, t, a))
                    }),
                    o
                }

                function ni(t) {
                    var e = Uu(t);
                    return function(n) {
                        return ii(n, t, e)
                    }
                }

                function ii(t, e, n) {
                    var i = n.length;
                    if (null == t) return ! i;
                    for (t = ih(t); i--;) {
                        var r = n[i],
                        a = e[r],
                        o = t[r];
                        if (o === it && !(r in t) || !a(o)) return ! 1
                    }
                    return ! 0
                }

                function ri(t, e, n) {
                    if ("function" != typeof t) throw new oh(ot);
                    return El(function() {
                        t.apply(it, n)
                    },
                    e)
                }

                function ai(t, e, n, i) {
                    var r = -1,
                    a = l,
                    o = true,
                    s = t.length,
                    u = [],
                    c = e.length;
                    if (!s) return u;
                    n && (e = p(e, O(n))),
                    i ? (a = f, o = false) : e.length >= rt && (a = D, o = false, e = new mn(e));
                    t: for (; ++r < s;) {
                        var h = t[r],
                        d = null == n ? h: n(h);
                        if (h = i || 0 !== h ? h: 0, o && d === d) {
                            for (var m = c; m--;) if (e[m] === d) continue t;
                            u.push(h)
                        } else a(e, d, i) || u.push(h)
                    }
                    return u
                }

                function oi(t, e) {
                    var n = true;
                    return hl(t,
                    function(t, i, r) {
                        return n = !!e(t, i, r)
                    }),
                    n
                }

                function si(t, e, n) {
                    for (var i = -1,
                    r = t.length; ++i < r;) {
                        var a = t[i],
                        o = e(a);
                        if (null != o && (s === it ? o === o && !fu(o) : n(o, s))) var s = o,
                        u = a
                    }
                    return u
                }

                function ui(t, e, n, i) {
                    var r = t.length;
                    for (n = yu(n), n < 0 && (n = -n > r ? 0 : r + n), i = i === it || i > r ? r: yu(i), i < 0 && (i += r), i = n > i ? 0 : _u(i); n < i;) t[n++] = e;
                    return t
                }

                function ci(t, e) {
                    var n = [];
                    return hl(t,
                    function(t, i, r) {
                        e(t, i, r) && n.push(t)
                    }),
                    n
                }

                function hi(t, e, n, i, r) {
                    var a = -1,
                    o = t.length;
                    for (n || (n = Pa), r || (r = []); ++a < o;) {
                        var s = t[a];
                        e > 0 && n(s) ? e > 1 ? hi(s, e - 1, n, i, r) : d(r, s) : i || (r[r.length] = s)
                    }
                    return r
                }

                function li(t, e) {
                    return t && fl(t, e, Uu)
                }

                function fi(t, e) {
                    return t && pl(t, e, Uu)
                }

                function pi(t, e) {
                    return h(e,
                    function(e) {
                        return Qs(t[e])
                    })
                }

                function di(t, e) {
                    e = br(e, t);
                    for (var n = 0,
                    i = e.length; null != t && n < i;) t = t[Ya(e[n++])];
                    return n && n == i ? t: it
                }

                function mi(t, e, n) {
                    var i = e(t);
                    return pf(t) ? i: d(i, n(t))
                }

                function vi(t) {
                    return null == t ? t === it ? ie: Jt: Ph && Ph in ih(t) ? ba(t) : ka(t)
                }

                function gi(t, e) {
                    return t > e
                }

                function yi(t, e) {
                    return null != t && fh.call(t, e)
                }

                function _i(t, e) {
                    return null != t && e in ih(t)
                }

                function xi(t, e, n) {
                    return t >= Vh(e, n) && t < kh(e, n)
                }

                function bi(t, e, n) {
                    for (var i = n ? f: l, r = t[0].length, a = t.length, o = a, s = Kc(a), u = 1 / 0, c = []; o--;) {
                        var h = t[o];
                        o && e && (h = p(h, O(e))),
                        u = Vh(h.length, u),
                        s[o] = !n && (e || r >= 120 && h.length >= 120) ? new mn(o && h) : it
                    }
                    h = t[0];
                    var d = -1,
                    m = s[0];
                    t: for (; ++d < r && c.length < u;) {
                        var v = h[d],
                        g = e ? e(v) : v;
                        if (v = n || 0 !== v ? v: 0, !(m ? D(m, g) : i(c, g, n))) {
                            for (o = a; --o;) {
                                var y = s[o];
                                if (! (y ? D(y, g) : i(t[o], g, n))) continue t
                            }
                            m && m.push(g),
                            c.push(v)
                        }
                    }
                    return c
                }

                function wi(t, e, n, i) {
                    return li(t,
                    function(t, r, a) {
                        e(i, n(t), r, a)
                    }),
                    i
                }

                function Mi(t, e, n) {
                    e = br(e, t),
                    t = Ga(t, e);
                    var i = null == t ? t: t[Ya(go(e))];
                    return null == i ? it: a(i, t, n)
                }

                function Si(t) {
                    return eu(t) && vi(t) == Ft
                }

                function Ei(t) {
                    return eu(t) && vi(t) == oe
                }

                function Ti(t) {
                    return eu(t) && vi(t) == Gt
                }

                function Ai(t, e, n, i, r) {
                    return t === e || (null == t || null == e || !eu(t) && !eu(e) ? t !== t && e !== e: Ci(t, e, n, i, Ai, r))
                }

                function Ci(t, e, n, i, r, a) {
                    var o = pf(t),
                    s = pf(e),
                    u = o ? jt: wl(t),
                    c = s ? jt: wl(e);
                    u = u == Ft ? Qt: u,
                    c = c == Ft ? Qt: c;
                    var h = u == Qt,
                    l = c == Qt,
                    f = u == c;
                    if (f && mf(t)) {
                        if (!mf(e)) return ! 1;
                        o = true,
                        h = false
                    }
                    if (f && !h) return a || (a = new yn),
                    o || xf(t) ? ca(t, e, n, i, r, a) : ha(t, e, u, n, i, r, a);
                    if (! (n & pt)) {
                        var p = h && fh.call(t, "__wrapped__"),
                        d = l && fh.call(e, "__wrapped__");
                        if (p || d) {
                            var m = p ? t.value() : t,
                            v = d ? e.value() : e;
                            return a || (a = new yn),
                            r(m, v, n, i, a)
                        }
                    }
                    return !! f && (a || (a = new yn), la(t, e, n, i, r, a))
                }

                function Pi(t) {
                    return eu(t) && wl(t) == Yt
                }

                function Li(t, e, n, i) {
                    var r = n.length,
                    a = r,
                    o = !i;
                    if (null == t) return ! a;
                    for (t = ih(t); r--;) {
                        var s = n[r];
                        if (o && s[2] ? s[1] !== t[s[0]] : !(s[0] in t)) return ! 1
                    }
                    for (; ++r < a;) {
                        s = n[r];
                        var u = s[0],
                        c = t[u],
                        h = s[1];
                        if (o && s[2]) {
                            if (c === it && !(u in t)) return ! 1
                        } else {
                            var l = new yn;
                            if (i) var f = i(c, h, u, t, e, l);
                            if (! (f === it ? Ai(h, c, pt | dt, i, l) : f)) return ! 1
                        }
                    }
                    return ! 0
                }

                function Ri(t) {
                    return ! (!tu(t) || Da(t)) && (Qs(t) ? yh: He).test(Za(t))
                }

                function Ii(t) {
                    return eu(t) && vi(t) == $t
                }

                function Oi(t) {
                    return eu(t) && wl(t) == te
                }

                function Ni(t) {
                    return eu(t) && $s(t.length) && !!bn[vi(t)]
                }

                function Di(t) {
                    return "function" == typeof t ? t: null == t ? Tc: "object" == typeof t ? pf(t) ? ki(t[0], t[1]) : ji(t) : Nc(t)
                }

                function Ui(t) {
                    if (!Ua(t)) return jh(t);
                    var e = [];
                    for (var n in ih(t)) fh.call(t, n) && "constructor" != n && e.push(n);
                    return e
                }

                function Bi(t) {
                    if (!tu(t)) return ja(t);
                    var e = Ua(t),
                    n = [];
                    for (var i in t)("constructor" != i || !e && fh.call(t, i)) && n.push(i);
                    return n
                }

                function zi(t, e) {
                    return t < e
                }

                function Fi(t, e) {
                    var n = -1,
                    i = Vs(t) ? Kc(t.length) : [];
                    return hl(t,
                    function(t, r, a) {
                        i[++n] = e(t, r, a)
                    }),
                    i
                }

                function ji(t) {
                    var e = _a(t);
                    return 1 == e.length && e[0][2] ? za(e[0][0], e[0][1]) : function(n) {
                        return n === t || Li(n, t, e)
                    }
                }

                function ki(t, e) {
                    return Ia(t) && Ba(e) ? za(Ya(t), e) : function(n) {
                        var i = Ou(n, t);
                        return i === it && i === e ? Du(n, t) : Ai(e, i, pt | dt)
                    }
                }

                function Vi(t, e, n, i, r) {
                    t !== e && fl(e,
                    function(a, o) {
                        if (tu(a)) r || (r = new yn),
                        Gi(t, e, o, n, Vi, i, r);
                        else {
                            var s = i ? i(q(t, o), a, o + "", t, e, r) : it;
                            s === it && (s = a),
                            Un(t, o, s)
                        }
                    },
                    Bu)
                }

                function Gi(t, e, n, i, r, a, o) {
                    var s = q(t, n),
                    u = q(e, n),
                    c = o.get(u);
                    if (c) return void Un(t, n, c);
                    var h = a ? a(s, u, n + "", t, e, o) : it,
                    l = h === it;
                    if (l) {
                        var f = pf(u),
                        p = !f && mf(u),
                        d = !f && !p && xf(u);
                        h = u,
                        f || p || d ? pf(s) ? h = s: Gs(s) ? h = Or(s) : p ? (l = false, h = Mr(u, true)) : d ? (l = false, h = Cr(u, true)) : h = [] : cu(u) || ff(u) ? (h = s, ff(s) ? h = bu(s) : (!tu(s) || i && Qs(s)) && (h = Ta(u))) : l = false
                    }
                    l && (o.set(u, h), r(h, u, i, a, o), o.delete(u)),
                    Un(t, n, h)
                }

                function Hi(t, e) {
                    var n = t.length;
                    if (n) return e += e < 0 ? n: 0,
                    La(e, n) ? t[e] : it
                }

                function Wi(t, e, n) {
                    var i = -1;
                    return e = p(e.length ? e: [Tc], O(ga())),
                    P(Fi(t,
                    function(t, n, r) {
                        return {
                            criteria: p(e,
                            function(e) {
                                return e(t)
                            }),
                            index: ++i,
                            value: t
                        }
                    }),
                    function(t, e) {
                        return Lr(t, e, n)
                    })
                }

                function Xi(t, e) {
                    return qi(t, e,
                    function(e, n) {
                        return Du(t, n)
                    })
                }

                function qi(t, e, n) {
                    for (var i = -1,
                    r = e.length,
                    a = {}; ++i < r;) {
                        var o = e[i],
                        s = di(t, o);
                        n(s, o) && ir(a, br(o, t), s)
                    }
                    return a
                }

                function Yi(t) {
                    return function(e) {
                        return di(e, t)
                    }
                }

                function Zi(t, e, n, i) {
                    var r = i ? M: w,
                    a = -1,
                    o = e.length,
                    s = t;
                    for (t === e && (e = Or(e)), n && (s = p(t, O(n))); ++a < o;) for (var u = 0,
                    c = e[a], h = n ? n(c) : c; (u = r(s, h, u, i)) > -1;) s !== t && Th.call(s, u, 1),
                    Th.call(t, u, 1);
                    return t
                }

                function Ji(t, e) {
                    for (var n = t ? e.length: 0, i = n - 1; n--;) {
                        var r = e[n];
                        if (n == i || r !== a) {
                            var a = r;
                            La(r) ? Th.call(t, r, 1) : pr(t, r)
                        }
                    }
                    return t
                }

                function Qi(t, e) {
                    return t + Dh(Wh() * (e - t + 1))
                }

                function Ki(t, e, n, i) {
                    for (var r = -1,
                    a = kh(Nh((e - t) / (n || 1)), 0), o = Kc(a); a--;) o[i ? a: ++r] = t,
                    t += n;
                    return o
                }

                function $i(t, e) {
                    var n = "";
                    if (!t || e < 1 || e > It) return n;
                    do {
                        e % 2 && (n += t), (e = Dh(e / 2)) && (t += t)
                    } while ( e );
                    return n
                }

                function tr(t, e) {
                    return Tl(Va(t, e, Tc), t + "")
                }

                function er(t) {
                    return In(Zu(t))
                }

                function nr(t, e) {
                    var n = Zu(t);
                    return qa(n, ti(e, 0, n.length))
                }

                function ir(t, e, n, i) {
                    if (!tu(t)) return t;
                    e = br(e, t);
                    for (var r = -1,
                    a = e.length,
                    o = a - 1,
                    s = t; null != s && ++r < a;) {
                        var u = Ya(e[r]),
                        c = n;
                        if (r != o) {
                            var h = s[u];
                            c = i ? i(h, u, s) : it,
                            c === it && (c = tu(h) ? h: La(e[r + 1]) ? [] : {})
                        }
                        Gn(s, u, c),
                        s = s[u]
                    }
                    return t
                }

                function rr(t) {
                    return qa(Zu(t))
                }

                function ar(t, e, n) {
                    var i = -1,
                    r = t.length;
                    e < 0 && (e = -e > r ? 0 : r + e),
                    n = n > r ? r: n,
                    n < 0 && (n += r),
                    r = e > n ? 0 : n - e >>> 0,
                    e >>>= 0;
                    for (var a = Kc(r); ++i < r;) a[i] = t[i + e];
                    return a
                }

                function or(t, e) {
                    var n;
                    return hl(t,
                    function(t, i, r) {
                        return ! (n = e(t, i, r))
                    }),
                    !!n
                }

                function sr(t, e, n) {
                    var i = 0,
                    r = null == t ? i: t.length;
                    if ("number" == typeof e && e === e && r <= Bt) {
                        for (; i < r;) {
                            var a = i + r >>> 1,
                            o = t[a];
                            null !== o && !fu(o) && (n ? o <= e: o < e) ? i = a + 1 : r = a
                        }
                        return r
                    }
                    return ur(t, e, Tc, n)
                }

                function ur(t, e, n, i) {
                    e = n(e);
                    for (var r = 0,
                    a = null == t ? 0 : t.length, o = e !== e, s = null === e, u = fu(e), c = e === it; r < a;) {
                        var h = Dh((r + a) / 2),
                        l = n(t[h]),
                        f = l !== it,
                        p = null === l,
                        d = l === l,
                        m = fu(l);
                        if (o) var v = i || d;
                        else v = c ? d && (i || f) : s ? d && f && (i || !p) : u ? d && f && !p && (i || !m) : !p && !m && (i ? l <= e: l < e);
                        v ? r = h + 1 : a = h
                    }
                    return Vh(a, Ut)
                }

                function cr(t, e) {
                    for (var n = -1,
                    i = t.length,
                    r = 0,
                    a = []; ++n < i;) {
                        var o = t[n],
                        s = e ? e(o) : o;
                        if (!n || !ks(s, u)) {
                            var u = s;
                            a[r++] = 0 === o ? 0 : o
                        }
                    }
                    return a
                }

                function hr(t) {
                    return "number" == typeof t ? t: fu(t) ? Nt: +t
                }

                function lr(t) {
                    if ("string" == typeof t) return t;
                    if (pf(t)) return p(t, lr) + "";
                    if (fu(t)) return ul ? ul.call(t) : "";
                    var e = t + "";
                    return "0" == e && 1 / t == -Rt ? "-0": e
                }

                function fr(t, e, n) {
                    var i = -1,
                    r = l,
                    a = t.length,
                    o = true,
                    s = [],
                    u = s;
                    if (n) o = false,
                    r = f;
                    else if (a >= rt) {
                        var c = e ? null: yl(t);
                        if (c) return Y(c);
                        o = false,
                        r = D,
                        u = new mn
                    } else u = e ? [] : s;
                    t: for (; ++i < a;) {
                        var h = t[i],
                        p = e ? e(h) : h;
                        if (h = n || 0 !== h ? h: 0, o && p === p) {
                            for (var d = u.length; d--;) if (u[d] === p) continue t;
                            e && u.push(p),
                            s.push(h)
                        } else r(u, p, n) || (u !== s && u.push(p), s.push(h))
                    }
                    return s
                }

                function pr(t, e) {
                    return e = br(e, t),
                    null == (t = Ga(t, e)) || delete t[Ya(go(e))]
                }

                function dr(t, e, n, i) {
                    return ir(t, e, n(di(t, e)), i)
                }

                function mr(t, e, n, i) {
                    for (var r = t.length,
                    a = i ? r: -1; (i ? a--:++a < r) && e(t[a], a, t););
                    return n ? ar(t, i ? 0 : a, i ? a + 1 : r) : ar(t, i ? a + 1 : 0, i ? r: a)
                }

                function vr(t, e) {
                    var n = t;
                    return n instanceof y && (n = n.value()),
                    m(e,
                    function(t, e) {
                        return e.func.apply(e.thisArg, d([t], e.args))
                    },
                    n)
                }

                function gr(t, e, n) {
                    var i = t.length;
                    if (i < 2) return i ? fr(t[0]) : [];
                    for (var r = -1,
                    a = Kc(i); ++r < i;) for (var o = t[r], s = -1; ++s < i;) s != r && (a[r] = ai(a[r] || o, t[s], e, n));
                    return fr(hi(a, 1), e, n)
                }

                function yr(t, e, n) {
                    for (var i = -1,
                    r = t.length,
                    a = e.length,
                    o = {}; ++i < r;) {
                        var s = i < a ? e[i] : it;
                        n(o, t[i], s)
                    }
                    return o
                }

                function _r(t) {
                    return Gs(t) ? t: []
                }

                function xr(t) {
                    return "function" == typeof t ? t: Tc
                }

                function br(t, e) {
                    return pf(t) ? t: Ia(t, e) ? [t] : Al(Mu(t))
                }

                function wr(t, e, n) {
                    var i = t.length;
                    return n = n === it ? i: n,
                    !e && n >= i ? t: ar(t, e, n)
                }

                function Mr(t, e) {
                    if (e) return t.slice();
                    var n = t.length,
                    i = wh ? wh(n) : new t.constructor(n);
                    return t.copy(i),
                    i
                }

                function Sr(t) {
                    var e = new t.constructor(t.byteLength);
                    return new bh(e).set(new bh(t)),
                    e
                }

                function Er(t, e) {
                    var n = e ? Sr(t.buffer) : t.buffer;
                    return new t.constructor(n, t.byteOffset, t.byteLength)
                }

                function Tr(t) {
                    var e = new t.constructor(t.source, ke.exec(t));
                    return e.lastIndex = t.lastIndex,
                    e
                }

                function Ar(t) {
                    return sl ? ih(sl.call(t)) : {}
                }

                function Cr(t, e) {
                    var n = e ? Sr(t.buffer) : t.buffer;
                    return new t.constructor(n, t.byteOffset, t.length)
                }

                function Pr(t, e) {
                    if (t !== e) {
                        var n = t !== it,
                        i = null === t,
                        r = t === t,
                        a = fu(t),
                        o = e !== it,
                        s = null === e,
                        u = e === e,
                        c = fu(e);
                        if (!s && !c && !a && t > e || a && o && u && !s && !c || i && o && u || !n && u || !r) return 1;
                        if (!i && !a && !c && t < e || c && n && r && !i && !a || s && n && r || !o && r || !u) return - 1
                    }
                    return 0
                }

                function Lr(t, e, n) {
                    for (var i = -1,
                    r = t.criteria,
                    a = e.criteria,
                    o = r.length,
                    s = n.length; ++i < o;) {
                        var u = Pr(r[i], a[i]);
                        if (u) {
                            if (i >= s) return u;
                            return u * ("desc" == n[i] ? -1 : 1)
                        }
                    }
                    return t.index - e.index
                }

                function Rr(t, e, n, i) {
                    for (var r = -1,
                    a = t.length,
                    o = n.length,
                    s = -1,
                    u = e.length,
                    c = kh(a - o, 0), h = Kc(u + c), l = !i; ++s < u;) h[s] = e[s];
                    for (; ++r < o;)(l || r < a) && (h[n[r]] = t[r]);
                    for (; c--;) h[s++] = t[r++];
                    return h
                }

                function Ir(t, e, n, i) {
                    for (var r = -1,
                    a = t.length,
                    o = -1,
                    s = n.length,
                    u = -1,
                    c = e.length,
                    h = kh(a - s, 0), l = Kc(h + c), f = !i; ++r < h;) l[r] = t[r];
                    for (var p = r; ++u < c;) l[p + u] = e[u];
                    for (; ++o < s;)(f || r < a) && (l[p + n[o]] = t[r++]);
                    return l
                }

                function Or(t, e) {
                    var n = -1,
                    i = t.length;
                    for (e || (e = Kc(i)); ++n < i;) e[n] = t[n];
                    return e
                }

                function Nr(t, e, n, i) {
                    var r = !n;
                    n || (n = {});
                    for (var a = -1,
                    o = e.length; ++a < o;) {
                        var s = e[a],
                        u = i ? i(n[s], t[s], s, n, t) : it;
                        u === it && (u = t[s]),
                        r ? Kn(n, s, u) : Gn(n, s, u)
                    }
                    return n
                }

                function Dr(t, e) {
                    return Nr(t, xl(t), e)
                }

                function Ur(t, e) {
                    return Nr(t, bl(t), e)
                }

                function Br(t, e) {
                    return function(n, i) {
                        var r = pf(n) ? o: Zn,
                        a = e ? e() : {};
                        return r(n, t, ga(i, 2), a)
                    }
                }

                function zr(t) {
                    return tr(function(e, n) {
                        var i = -1,
                        r = n.length,
                        a = r > 1 ? n[r - 1] : it,
                        o = r > 2 ? n[2] : it;
                        for (a = t.length > 3 && "function" == typeof a ? (r--, a) : it, o && Ra(n[0], n[1], o) && (a = r < 3 ? it: a, r = 1), e = ih(e); ++i < r;) {
                            var s = n[i];
                            s && t(e, s, i, a)
                        }
                        return e
                    })
                }

                function Fr(t, e) {
                    return function(n, i) {
                        if (null == n) return n;
                        if (!Vs(n)) return t(n, i);
                        for (var r = n.length,
                        a = e ? r: -1, o = ih(n); (e ? a--:++a < r) && false !== i(o[a], a, o););
                        return n
                    }
                }

                function jr(t) {
                    return function(e, n, i) {
                        for (var r = -1,
                        a = ih(e), o = i(e), s = o.length; s--;) {
                            var u = o[t ? s: ++r];
                            if (false === n(a[u], u, a)) break
                        }
                        return e
                    }
                }

                function kr(t, e, n) {
                    function i() {
                        return (this && this !== Rn && this instanceof i ? a: t).apply(r ? n: this, arguments)
                    }
                    var r = e & mt,
                    a = Hr(t);
                    return i
                }

                function Vr(t) {
                    return function(e) {
                        e = Mu(e);
                        var n = k(e) ? $(e) : it,
                        i = n ? n[0] : e.charAt(0),
                        r = n ? wr(n, 1).join("") : e.slice(1);
                        return i[t]() + r
                    }
                }

                function Gr(t) {
                    return function(e) {
                        return m(bc(ec(e).replace(pn, "")), t, "")
                    }
                }

                function Hr(t) {
                    return function() {
                        var e = arguments;
                        switch (e.length) {
                        case 0:
                            return new t;
                        case 1:
                            return new t(e[0]);
                        case 2:
                            return new t(e[0], e[1]);
                        case 3:
                            return new t(e[0], e[1], e[2]);
                        case 4:
                            return new t(e[0], e[1], e[2], e[3]);
                        case 5:
                            return new t(e[0], e[1], e[2], e[3], e[4]);
                        case 6:
                            return new t(e[0], e[1], e[2], e[3], e[4], e[5]);
                        case 7:
                            return new t(e[0], e[1], e[2], e[3], e[4], e[5], e[6])
                        }
                        var n = cl(t.prototype),
                        i = t.apply(n, e);
                        return tu(i) ? i: n
                    }
                }

                function Wr(t, e, n) {
                    function i() {
                        for (var o = arguments.length,
                        s = Kc(o), u = o, c = va(i); u--;) s[u] = arguments[u];
                        var h = o < 3 && s[0] !== c && s[o - 1] !== c ? [] : X(s, c);
                        return (o -= h.length) < n ? na(t, e, Yr, i.placeholder, it, s, h, it, it, n - o) : a(this && this !== Rn && this instanceof i ? r: t, this, s)
                    }
                    var r = Hr(t);
                    return i
                }

                function Xr(t) {
                    return function(e, n, i) {
                        var r = ih(e);
                        if (!Vs(e)) {
                            var a = ga(n, 3);
                            e = Uu(e),
                            n = function(t) {
                                return a(r[t], t, r)
                            }
                        }
                        var o = t(e, n, i);
                        return o > -1 ? r[a ? e[o] : o] : it
                    }
                }

                function qr(t) {
                    return fa(function(e) {
                        var n = e.length,
                        i = n,
                        a = r.prototype.thru;
                        for (t && e.reverse(); i--;) {
                            var o = e[i];
                            if ("function" != typeof o) throw new oh(ot);
                            if (a && !s && "wrapper" == ma(o)) var s = new r([], true)
                        }
                        for (i = s ? i: n; ++i < n;) {
                            o = e[i];
                            var u = ma(o),
                            c = "wrapper" == u ? _l(o) : it;
                            s = c && Na(c[0]) && c[1] == (wt | yt | xt | Mt) && !c[4].length && 1 == c[9] ? s[ma(c[0])].apply(s, c[3]) : 1 == o.length && Na(o) ? s[u]() : s.thru(o)
                        }
                        return function() {
                            var t = arguments,
                            i = t[0];
                            if (s && 1 == t.length && pf(i)) return s.plant(i).value();
                            for (var r = 0,
                            a = n ? e[r].apply(this, t) : i; ++r < n;) a = e[r].call(this, a);
                            return a
                        }
                    })
                }

                function Yr(t, e, n, i, r, a, o, s, u, c) {
                    function h() {
                        for (var g = arguments.length,
                        y = Kc(g), _ = g; _--;) y[_] = arguments[_];
                        if (d) var x = va(h),
                        b = z(y, x);
                        if (i && (y = Rr(y, i, r, d)), a && (y = Ir(y, a, o, d)), g -= b, d && g < c) {
                            var w = X(y, x);
                            return na(t, e, Yr, h.placeholder, n, y, w, s, u, c - g)
                        }
                        var M = f ? n: this,
                        S = p ? M[t] : t;
                        return g = y.length,
                        s ? y = Ha(y, s) : m && g > 1 && y.reverse(),
                        l && u < g && (y.length = u),
                        this && this !== Rn && this instanceof h && (S = v || Hr(S)),
                        S.apply(M, y)
                    }
                    var l = e & wt,
                    f = e & mt,
                    p = e & vt,
                    d = e & (yt | _t),
                    m = e & St,
                    v = p ? it: Hr(t);
                    return h
                }

                function Zr(t, e) {
                    return function(n, i) {
                        return wi(n, t, e(i), {})
                    }
                }

                function Jr(t, e) {
                    return function(n, i) {
                        var r;
                        if (n === it && i === it) return e;
                        if (n !== it && (r = n), i !== it) {
                            if (r === it) return i;
                            "string" == typeof n || "string" == typeof i ? (n = lr(n), i = lr(i)) : (n = hr(n), i = hr(i)),
                            r = t(n, i)
                        }
                        return r
                    }
                }

                function Qr(t) {
                    return fa(function(e) {
                        return e = p(e, O(ga())),
                        tr(function(n) {
                            var i = this;
                            return t(e,
                            function(t) {
                                return a(t, i, n)
                            })
                        })
                    })
                }

                function Kr(t, e) {
                    e = e === it ? " ": lr(e);
                    var n = e.length;
                    if (n < 2) return n ? $i(e, t) : e;
                    var i = $i(e, Nh(t / K(e)));
                    return k(e) ? wr($(i), 0, t).join("") : i.slice(0, t)
                }

                function $r(t, e, n, i) {
                    function r() {
                        for (var e = -1,
                        u = arguments.length,
                        c = -1,
                        h = i.length,
                        l = Kc(h + u), f = this && this !== Rn && this instanceof r ? s: t; ++c < h;) l[c] = i[c];
                        for (; u--;) l[c++] = arguments[++e];
                        return a(f, o ? n: this, l)
                    }
                    var o = e & mt,
                    s = Hr(t);
                    return r
                }

                function ta(t) {
                    return function(e, n, i) {
                        return i && "number" != typeof i && Ra(e, n, i) && (n = i = it),
                        e = gu(e),
                        n === it ? (n = e, e = 0) : n = gu(n),
                        i = i === it ? e < n ? 1 : -1 : gu(i),
                        Ki(e, n, i, t)
                    }
                }

                function ea(t) {
                    return function(e, n) {
                        return "string" == typeof e && "string" == typeof n || (e = xu(e), n = xu(n)),
                        t(e, n)
                    }
                }

                function na(t, e, n, i, r, a, o, s, u, c) {
                    var h = e & yt,
                    l = h ? o: it,
                    f = h ? it: o,
                    p = h ? a: it,
                    d = h ? it: a;
                    e |= h ? xt: bt,
                    (e &= ~ (h ? bt: xt)) & gt || (e &= ~ (mt | vt));
                    var m = [t, e, r, p, l, d, f, s, u, c],
                    v = n.apply(it, m);
                    return Na(t) && Sl(v, m),
                    v.placeholder = i,
                    Wa(v, t, e)
                }

                function ia(t) {
                    var e = nh[t];
                    return function(t, n) {
                        if (t = xu(t), n = null == n ? 0 : Vh(yu(n), 292)) {
                            var i = (Mu(t) + "e").split("e");
                            return i = (Mu(e(i[0] + "e" + ( + i[1] + n))) + "e").split("e"),
                            +(i[0] + "e" + ( + i[1] - n))
                        }
                        return e(t)
                    }
                }

                function ra(t) {
                    return function(e) {
                        var n = wl(e);
                        return n == Yt ? H(e) : n == te ? Z(e) : I(e, t(e))
                    }
                }

                function aa(t, e, n, i, r, a, o, s) {
                    var u = e & vt;
                    if (!u && "function" != typeof t) throw new oh(ot);
                    var c = i ? i.length: 0;
                    if (c || (e &= ~ (xt | bt), i = r = it), o = o === it ? o: kh(yu(o), 0), s = s === it ? s: yu(s), c -= r ? r.length: 0, e & bt) {
                        var h = i,
                        l = r;
                        i = r = it
                    }
                    var f = u ? it: _l(t),
                    p = [t, e, n, i, r, h, l, a, o, s];
                    if (f && Fa(p, f), t = p[0], e = p[1], n = p[2], i = p[3], r = p[4], s = p[9] = p[9] === it ? u ? 0 : t.length: kh(p[9] - c, 0), !s && e & (yt | _t) && (e &= ~ (yt | _t)), e && e != mt) d = e == yt || e == _t ? Wr(t, e, s) : e != xt && e != (mt | xt) || r.length ? Yr.apply(it, p) : $r(t, e, n, i);
                    else var d = kr(t, e, n);
                    return Wa((f ? dl: Sl)(d, p), t, e)
                }

                function oa(t, e, n, i) {
                    return t === it || ks(t, ch[n]) && !fh.call(i, n) ? e: t
                }

                function sa(t, e, n, i, r, a) {
                    return tu(t) && tu(e) && (a.set(e, t), Vi(t, e, it, sa, a), a.delete(e)),
                    t
                }

                function ua(t) {
                    return cu(t) ? it: t
                }

                function ca(t, e, n, i, r, a) {
                    var o = n & pt,
                    s = t.length,
                    u = e.length;
                    if (s != u && !(o && u > s)) return ! 1;
                    var c = a.get(t);
                    if (c && a.get(e)) return c == e;
                    var h = -1,
                    l = true,
                    f = n & dt ? new mn: it;
                    for (a.set(t, e), a.set(e, t); ++h < s;) {
                        var p = t[h],
                        d = e[h];
                        if (i) var m = o ? i(d, p, h, e, t, a) : i(p, d, h, t, e, a);
                        if (m !== it) {
                            if (m) continue;
                            l = false;
                            break
                        }
                        if (f) {
                            if (!g(e,
                            function(t, e) {
                                if (!D(f, e) && (p === t || r(p, t, n, i, a))) return f.push(e)
                            })) {
                                l = false;
                                break
                            }
                        } else if (p !== d && !r(p, d, n, i, a)) {
                            l = false;
                            break
                        }
                    }
                    return a.delete(t),
                    a.delete(e),
                    l
                }

                function ha(t, e, n, i, r, a, o) {
                    switch (n) {
                    case se:
                        if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) return ! 1;
                        t = t.buffer,
                        e = e.buffer;
                    case oe:
                        return ! (t.byteLength != e.byteLength || !a(new bh(t), new bh(e)));
                    case Vt:
                    case Gt:
                    case Zt:
                        return ks( + t, +e);
                    case Wt:
                        return t.name == e.name && t.message == e.message;
                    case $t:
                    case ee:
                        return t == e + "";
                    case Yt:
                        var s = H;
                    case te:
                        var u = i & pt;
                        if (s || (s = Y), t.size != e.size && !u) return ! 1;
                        var c = o.get(t);
                        if (c) return c == e;
                        i |= dt,
                        o.set(t, e);
                        var h = ca(s(t), s(e), i, r, a, o);
                        return o.delete(t),
                        h;
                    case ne:
                        if (sl) return sl.call(t) == sl.call(e)
                    }
                    return ! 1
                }

                function la(t, e, n, i, r, a) {
                    var o = n & pt,
                    s = pa(t),
                    u = s.length;
                    if (u != pa(e).length && !o) return ! 1;
                    for (var c = u; c--;) {
                        var h = s[c];
                        if (! (o ? h in e: fh.call(e, h))) return ! 1
                    }
                    var l = a.get(t);
                    if (l && a.get(e)) return l == e;
                    var f = true;
                    a.set(t, e),
                    a.set(e, t);
                    for (var p = o; ++c < u;) {
                        h = s[c];
                        var d = t[h],
                        m = e[h];
                        if (i) var v = o ? i(m, d, h, e, t, a) : i(d, m, h, t, e, a);
                        if (! (v === it ? d === m || r(d, m, n, i, a) : v)) {
                            f = false;
                            break
                        }
                        p || (p = "constructor" == h)
                    }
                    if (f && !p) {
                        var g = t.constructor,
                        y = e.constructor;
                        g != y && "constructor" in t && "constructor" in e && !("function" == typeof g && g instanceof g && "function" == typeof y && y instanceof y) && (f = false)
                    }
                    return a.delete(t),
                    a.delete(e),
                    f
                }

                function fa(t) {
                    return Tl(Va(t, it, uo), t + "")
                }

                function pa(t) {
                    return mi(t, Uu, xl)
                }

                function da(t) {
                    return mi(t, Bu, bl)
                }

                function ma(t) {
                    for (var e = t.name + "",
                    n = tl[e], i = fh.call(tl, e) ? n.length: 0; i--;) {
                        var r = n[i],
                        a = r.func;
                        if (null == a || a == t) return r.name
                    }
                    return e
                }

                function va(t) {
                    return (fh.call(n, "placeholder") ? n: t).placeholder
                }

                function ga() {
                    var t = n.iteratee || Ac;
                    return t = t === Ac ? Di: t,
                    arguments.length ? t(arguments[0], arguments[1]) : t
                }

                function ya(t, e) {
                    var n = t.__data__;
                    return Oa(e) ? n["string" == typeof e ? "string": "hash"] : n.map
                }

                function _a(t) {
                    for (var e = Uu(t), n = e.length; n--;) {
                        var i = e[n],
                        r = t[i];
                        e[n] = [i, r, Ba(r)]
                    }
                    return e
                }

                function xa(t, e) {
                    var n = j(t, e);
                    return Ri(n) ? n: it
                }

                function ba(t) {
                    var e = fh.call(t, Ph),
                    n = t[Ph];
                    try {
                        t[Ph] = it;
                        var i = true
                    } catch(t) {}
                    var r = mh.call(t);
                    return i && (e ? t[Ph] = n: delete t[Ph]),
                    r
                }

                function wa(t, e, n) {
                    for (var i = -1,
                    r = n.length; ++i < r;) {
                        var a = n[i],
                        o = a.size;
                        switch (a.type) {
                        case "drop":
                            t += o;
                            break;
                        case "dropRight":
                            e -= o;
                            break;
                        case "take":
                            e = Vh(e, t + o);
                            break;
                        case "takeRight":
                            t = kh(t, e - o)
                        }
                    }
                    return {
                        start: t,
                        end: e
                    }
                }

                function Ma(t) {
                    var e = t.match(Ue);
                    return e ? e[1].split(Be) : []
                }

                function Sa(t, e, n) {
                    e = br(e, t);
                    for (var i = -1,
                    r = e.length,
                    a = false; ++i < r;) {
                        var o = Ya(e[i]);
                        if (! (a = null != t && n(t, o))) break;
                        t = t[o]
                    }
                    return a || ++i != r ? a: !!(r = null == t ? 0 : t.length) && $s(r) && La(o, r) && (pf(t) || ff(t))
                }

                function Ea(t) {
                    var e = t.length,
                    n = new t.constructor(e);
                    return e && "string" == typeof t[0] && fh.call(t, "index") && (n.index = t.index, n.input = t.input),
                    n
                }

                function Ta(t) {
                    return "function" != typeof t.constructor || Ua(t) ? {}: cl(Mh(t))
                }

                function Aa(t, e, n) {
                    var i = t.constructor;
                    switch (e) {
                    case oe:
                        return Sr(t);
                    case Vt:
                    case Gt:
                        return new i( + t);
                    case se:
                        return Er(t, n);
                    case ue:
                    case ce:
                    case he:
                    case le:
                    case fe:
                    case pe:
                    case de:
                    case me:
                    case ve:
                        return Cr(t, n);
                    case Yt:
                        return new i;
                    case Zt:
                    case ee:
                        return new i(t);
                    case $t:
                        return Tr(t);
                    case te:
                        return new i;
                    case ne:
                        return Ar(t)
                    }
                }

                function Ca(t, e) {
                    var n = e.length;
                    if (!n) return t;
                    var i = n - 1;
                    return e[i] = (n > 1 ? "& ": "") + e[i],
                    e = e.join(n > 2 ? ", ": " "),
                    t.replace(De, "{\\n/* [wrapped with " + e + "] */\\n")
                }

                function Pa(t) {
                    return pf(t) || ff(t) || !!(Ah && t && t[Ah])
                }

                function La(t, e) {
                    var n = typeof t;
                    return !! (e = null == e ? It: e) && ("number" == n || "symbol" != n && Xe.test(t)) && t > -1 && t % 1 == 0 && t < e
                }

                function Ra(t, e, n) {
                    if (!tu(n)) return ! 1;
                    var i = typeof e;
                    return !! ("number" == i ? Vs(n) && La(e, n.length) : "string" == i && e in n) && ks(n[e], t)
                }

                function Ia(t, e) {
                    if (pf(t)) return ! 1;
                    var n = typeof t;
                    return ! ("number" != n && "symbol" != n && "boolean" != n && null != t && !fu(t)) || (Ce.test(t) || !Ae.test(t) || null != e && t in ih(e))
                }

                function Oa(t) {
                    var e = typeof t;
                    return "string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t: null === t
                }

                function Na(t) {
                    var e = ma(t),
                    i = n[e];
                    if ("function" != typeof i || !(e in y.prototype)) return ! 1;
                    if (t === i) return ! 0;
                    var r = _l(i);
                    return !! r && t === r[0]
                }

                function Da(t) {
                    return !! dh && dh in t
                }

                function Ua(t) {
                    var e = t && t.constructor;
                    return t === ("function" == typeof e && e.prototype || ch)
                }

                function Ba(t) {
                    return t === t && !tu(t)
                }

                function za(t, e) {
                    return function(n) {
                        return null != n && (n[t] === e && (e !== it || t in ih(n)))
                    }
                }

                function Fa(t, e) {
                    var n = t[1],
                    i = e[1],
                    r = n | i,
                    a = r < (mt | vt | wt),
                    o = i == wt && n == yt || i == wt && n == Mt && t[7].length <= e[8] || i == (wt | Mt) && e[7].length <= e[8] && n == yt;
                    if (!a && !o) return t;
                    i & mt && (t[2] = e[2], r |= n & mt ? 0 : gt);
                    var s = e[3];
                    if (s) {
                        var u = t[3];
                        t[3] = u ? Rr(u, s, e[4]) : s,
                        t[4] = u ? X(t[3], ct) : e[4]
                    }
                    return s = e[5],
                    s && (u = t[5], t[5] = u ? Ir(u, s, e[6]) : s, t[6] = u ? X(t[5], ct) : e[6]),
                    s = e[7],
                    s && (t[7] = s),
                    i & wt && (t[8] = null == t[8] ? e[8] : Vh(t[8], e[8])),
                    null == t[9] && (t[9] = e[9]),
                    t[0] = e[0],
                    t[1] = r,
                    t
                }

                function ja(t) {
                    var e = [];
                    if (null != t) for (var n in ih(t)) e.push(n);
                    return e
                }

                function ka(t) {
                    return mh.call(t)
                }

                function Va(t, e, n) {
                    return e = kh(e === it ? t.length - 1 : e, 0),
                    function() {
                        for (var i = arguments,
                        r = -1,
                        o = kh(i.length - e, 0), s = Kc(o); ++r < o;) s[r] = i[e + r];
                        r = -1;
                        for (var u = Kc(e + 1); ++r < e;) u[r] = i[r];
                        return u[e] = n(s),
                        a(t, this, u)
                    }
                }

                function Ga(t, e) {
                    return e.length < 2 ? t: di(t, ar(e, 0, -1))
                }

                function Ha(t, e) {
                    for (var n = t.length,
                    i = Vh(e.length, n), r = Or(t); i--;) {
                        var a = e[i];
                        t[i] = La(a, n) ? r[a] : it
                    }
                    return t
                }

                function Wa(t, e, n) {
                    var i = e + "";
                    return Tl(t, Ca(i, Ja(Ma(i), n)))
                }

                function Xa(t) {
                    var e = 0,
                    n = 0;
                    return function() {
                        var i = Gh(),
                        r = Ct - (i - n);
                        if (n = i, r > 0) {
                            if (++e >= At) return arguments[0]
                        } else e = 0;
                        return t.apply(it, arguments)
                    }
                }

                function qa(t, e) {
                    var n = -1,
                    i = t.length,
                    r = i - 1;
                    for (e = e === it ? i: e; ++n < e;) {
                        var a = Qi(n, r),
                        o = t[a];
                        t[a] = t[n],
                        t[n] = o
                    }
                    return t.length = e,
                    t
                }

                function Ya(t) {
                    if ("string" == typeof t || fu(t)) return t;
                    var e = t + "";
                    return "0" == e && 1 / t == -Rt ? "-0": e
                }

                function Za(t) {
                    if (null != t) {
                        try {
                            return lh.call(t)
                        } catch(t) {}
                        try {
                            return t + ""
                        } catch(t) {}
                    }
                    return ""
                }

                function Ja(t, e) {
                    return s(zt,
                    function(n) {
                        var i = "_." + n[0];
                        e & n[1] && !l(t, i) && t.push(i)
                    }),
                    t.sort()
                }

                function Qa(t) {
                    if (t instanceof y) return t.clone();
                    var e = new r(t.__wrapped__, t.__chain__);
                    return e.__actions__ = Or(t.__actions__),
                    e.__index__ = t.__index__,
                    e.__values__ = t.__values__,
                    e
                }

                function Ka(t, e, n) {
                    e = (n ? Ra(t, e, n) : e === it) ? 1 : kh(yu(e), 0);
                    var i = null == t ? 0 : t.length;
                    if (!i || e < 1) return [];
                    for (var r = 0,
                    a = 0,
                    o = Kc(Nh(i / e)); r < i;) o[a++] = ar(t, r, r += e);
                    return o
                }

                function $a(t) {
                    for (var e = -1,
                    n = null == t ? 0 : t.length, i = 0, r = []; ++e < n;) {
                        var a = t[e];
                        a && (r[i++] = a)
                    }
                    return r
                }

                function to() {
                    var t = arguments.length;
                    if (!t) return [];
                    for (var e = Kc(t - 1), n = arguments[0], i = t; i--;) e[i - 1] = arguments[i];
                    return d(pf(n) ? Or(n) : [n], hi(e, 1))
                }

                function eo(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    return i ? (e = n || e === it ? 1 : yu(e), ar(t, e < 0 ? 0 : e, i)) : []
                }

                function no(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    return i ? (e = n || e === it ? 1 : yu(e), e = i - e, ar(t, 0, e < 0 ? 0 : e)) : []
                }

                function io(t, e) {
                    return t && t.length ? mr(t, ga(e, 3), true, true) : []
                }

                function ro(t, e) {
                    return t && t.length ? mr(t, ga(e, 3), true) : []
                }

                function ao(t, e, n, i) {
                    var r = null == t ? 0 : t.length;
                    return r ? (n && "number" != typeof n && Ra(t, e, n) && (n = 0, i = r), ui(t, e, n, i)) : []
                }

                function oo(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    if (!i) return - 1;
                    var r = null == n ? 0 : yu(n);
                    return r < 0 && (r = kh(i + r, 0)),
                    b(t, ga(e, 3), r)
                }

                function so(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    if (!i) return - 1;
                    var r = i - 1;
                    return n !== it && (r = yu(n), r = n < 0 ? kh(i + r, 0) : Vh(r, i - 1)),
                    b(t, ga(e, 3), r, true)
                }

                function uo(t) {
                    return (null == t ? 0 : t.length) ? hi(t, 1) : []
                }

                function co(t) {
                    return (null == t ? 0 : t.length) ? hi(t, Rt) : []
                }

                function ho(t, e) {
                    return (null == t ? 0 : t.length) ? (e = e === it ? 1 : yu(e), hi(t, e)) : []
                }

                function lo(t) {
                    for (var e = -1,
                    n = null == t ? 0 : t.length, i = {}; ++e < n;) {
                        var r = t[e];
                        i[r[0]] = r[1]
                    }
                    return i
                }

                function fo(t) {
                    return t && t.length ? t[0] : it
                }

                function po(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    if (!i) return - 1;
                    var r = null == n ? 0 : yu(n);
                    return r < 0 && (r = kh(i + r, 0)),
                    w(t, e, r)
                }

                function mo(t) {
                    return (null == t ? 0 : t.length) ? ar(t, 0, -1) : []
                }

                function vo(t, e) {
                    return null == t ? "": Fh.call(t, e)
                }

                function go(t) {
                    var e = null == t ? 0 : t.length;
                    return e ? t[e - 1] : it
                }

                function yo(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    if (!i) return - 1;
                    var r = i;
                    return n !== it && (r = yu(n), r = r < 0 ? kh(i + r, 0) : Vh(r, i - 1)),
                    e === e ? Q(t, e, r) : b(t, S, r, true)
                }

                function _o(t, e) {
                    return t && t.length ? Hi(t, yu(e)) : it
                }

                function xo(t, e) {
                    return t && t.length && e && e.length ? Zi(t, e) : t
                }

                function bo(t, e, n) {
                    return t && t.length && e && e.length ? Zi(t, e, ga(n, 2)) : t
                }

                function wo(t, e, n) {
                    return t && t.length && e && e.length ? Zi(t, e, it, n) : t
                }

                function Mo(t, e) {
                    var n = [];
                    if (!t || !t.length) return n;
                    var i = -1,
                    r = [],
                    a = t.length;
                    for (e = ga(e, 3); ++i < a;) {
                        var o = t[i];
                        e(o, i, t) && (n.push(o), r.push(i))
                    }
                    return Ji(t, r),
                    n
                }

                function So(t) {
                    return null == t ? t: Xh.call(t)
                }

                function Eo(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    return i ? (n && "number" != typeof n && Ra(t, e, n) ? (e = 0, n = i) : (e = null == e ? 0 : yu(e), n = n === it ? i: yu(n)), ar(t, e, n)) : []
                }

                function To(t, e) {
                    return sr(t, e)
                }

                function Ao(t, e, n) {
                    return ur(t, e, ga(n, 2))
                }

                function Co(t, e) {
                    var n = null == t ? 0 : t.length;
                    if (n) {
                        var i = sr(t, e);
                        if (i < n && ks(t[i], e)) return i
                    }
                    return - 1
                }

                function Po(t, e) {
                    return sr(t, e, true)
                }

                function Lo(t, e, n) {
                    return ur(t, e, ga(n, 2), true)
                }

                function Ro(t, e) {
                    if (null == t ? 0 : t.length) {
                        var n = sr(t, e, true) - 1;
                        if (ks(t[n], e)) return n
                    }
                    return - 1
                }

                function Io(t) {
                    return t && t.length ? cr(t) : []
                }

                function Oo(t, e) {
                    return t && t.length ? cr(t, ga(e, 2)) : []
                }

                function No(t) {
                    var e = null == t ? 0 : t.length;
                    return e ? ar(t, 1, e) : []
                }

                function Do(t, e, n) {
                    return t && t.length ? (e = n || e === it ? 1 : yu(e), ar(t, 0, e < 0 ? 0 : e)) : []
                }

                function Uo(t, e, n) {
                    var i = null == t ? 0 : t.length;
                    return i ? (e = n || e === it ? 1 : yu(e), e = i - e, ar(t, e < 0 ? 0 : e, i)) : []
                }

                function Bo(t, e) {
                    return t && t.length ? mr(t, ga(e, 3), false, true) : []
                }

                function zo(t, e) {
                    return t && t.length ? mr(t, ga(e, 3)) : []
                }

                function Fo(t) {
                    return t && t.length ? fr(t) : []
                }

                function jo(t, e) {
                    return t && t.length ? fr(t, ga(e, 2)) : []
                }

                function ko(t, e) {
                    return e = "function" == typeof e ? e: it,
                    t && t.length ? fr(t, it, e) : []
                }

                function Vo(t) {
                    if (!t || !t.length) return [];
                    var e = 0;
                    return t = h(t,
                    function(t) {
                        if (Gs(t)) return e = kh(t.length, e),
                        true
                    }),
                    R(e,
                    function(e) {
                        return p(t, T(e))
                    })
                }

                function Go(t, e) {
                    if (!t || !t.length) return [];
                    var n = Vo(t);
                    return null == e ? n: p(n,
                    function(t) {
                        return a(e, it, t)
                    })
                }

                function Ho(t, e) {
                    return yr(t || [], e || [], Gn)
                }

                function Wo(t, e) {
                    return yr(t || [], e || [], ir)
                }

                function Xo(t) {
                    var e = n(t);
                    return e.__chain__ = true,
                    e
                }

                function qo(t, e) {
                    return e(t),
                    t
                }

                function Yo(t, e) {
                    return e(t)
                }

                function Zo() {
                    return Xo(this)
                }

                function Jo() {
                    return new r(this.value(), this.__chain__)
                }

                function Qo() {
                    this.__values__ === it && (this.__values__ = vu(this.value()));
                    var t = this.__index__ >= this.__values__.length;
                    return {
                        done: t,
                        value: t ? it: this.__values__[this.__index__++]
                    }
                }

                function Ko() {
                    return this
                }

                function $o(t) {
                    for (var e, n = this; n instanceof i;) {
                        var r = Qa(n);
                        r.__index__ = 0,
                        r.__values__ = it,
                        e ? a.__wrapped__ = r: e = r;
                        var a = r;
                        n = n.__wrapped__
                    }
                    return a.__wrapped__ = t,
                    e
                }

                function ts() {
                    var t = this.__wrapped__;
                    if (t instanceof y) {
                        var e = t;
                        return this.__actions__.length && (e = new y(this)),
                        e = e.reverse(),
                        e.__actions__.push({
                            func: Yo,
                            args: [So],
                            thisArg: it
                        }),
                        new r(e, this.__chain__)
                    }
                    return this.thru(So)
                }

                function es() {
                    return vr(this.__wrapped__, this.__actions__)
                }

                function ns(t, e, n) {
                    var i = pf(t) ? c: oi;
                    return n && Ra(t, e, n) && (e = it),
                    i(t, ga(e, 3))
                }

                function is(t, e) {
                    return (pf(t) ? h: ci)(t, ga(e, 3))
                }

                function rs(t, e) {
                    return hi(hs(t, e), 1)
                }

                function as(t, e) {
                    return hi(hs(t, e), Rt)
                }

                function os(t, e, n) {
                    return n = n === it ? 1 : yu(n),
                    hi(hs(t, e), n)
                }

                function ss(t, e) {
                    return (pf(t) ? s: hl)(t, ga(e, 3))
                }

                function us(t, e) {
                    return (pf(t) ? u: ll)(t, ga(e, 3))
                }

                function cs(t, e, n, i) {
                    t = Vs(t) ? t: Zu(t),
                    n = n && !i ? yu(n) : 0;
                    var r = t.length;
                    return n < 0 && (n = kh(r + n, 0)),
                    lu(t) ? n <= r && t.indexOf(e, n) > -1 : !!r && w(t, e, n) > -1
                }

                function hs(t, e) {
                    return (pf(t) ? p: Fi)(t, ga(e, 3))
                }

                function ls(t, e, n, i) {
                    return null == t ? [] : (pf(e) || (e = null == e ? [] : [e]), n = i ? it: n, pf(n) || (n = null == n ? [] : [n]), Wi(t, e, n))
                }

                function fs(t, e, n) {
                    var i = pf(t) ? m: C,
                    r = arguments.length < 3;
                    return i(t, ga(e, 4), n, r, hl)
                }

                function ps(t, e, n) {
                    var i = pf(t) ? v: C,
                    r = arguments.length < 3;
                    return i(t, ga(e, 4), n, r, ll)
                }

                function ds(t, e) {
                    return (pf(t) ? h: ci)(t, Cs(ga(e, 3)))
                }

                function ms(t) {
                    return (pf(t) ? In: er)(t)
                }

                function vs(t, e, n) {
                    return e = (n ? Ra(t, e, n) : e === it) ? 1 : yu(e),
                    (pf(t) ? On: nr)(t, e)
                }

                function gs(t) {
                    return (pf(t) ? Dn: rr)(t)
                }

                function ys(t) {
                    if (null == t) return 0;
                    if (Vs(t)) return lu(t) ? K(t) : t.length;
                    var e = wl(t);
                    return e == Yt || e == te ? t.size: Ui(t).length
                }

                function _s(t, e, n) {
                    var i = pf(t) ? g: or;
                    return n && Ra(t, e, n) && (e = it),
                    i(t, ga(e, 3))
                }

                function xs(t, e) {
                    if ("function" != typeof e) throw new oh(ot);
                    return t = yu(t),
                    function() {
                        if (--t < 1) return e.apply(this, arguments)
                    }
                }

                function bs(t, e, n) {
                    return e = n ? it: e,
                    e = t && null == e ? t.length: e,
                    aa(t, wt, it, it, it, it, e)
                }

                function ws(t, e) {
                    var n;
                    if ("function" != typeof e) throw new oh(ot);
                    return t = yu(t),
                    function() {
                        return--t > 0 && (n = e.apply(this, arguments)),
                        t <= 1 && (e = it),
                        n
                    }
                }

                function Ms(t, e, n) {
                    e = n ? it: e;
                    var i = aa(t, yt, it, it, it, it, it, e);
                    return i.placeholder = Ms.placeholder,
                    i
                }

                function Ss(t, e, n) {
                    e = n ? it: e;
                    var i = aa(t, _t, it, it, it, it, it, e);
                    return i.placeholder = Ss.placeholder,
                    i
                }

                function Es(t, e, n) {
                    function i(e) {
                        var n = f,
                        i = p;
                        return f = p = it,
                        y = e,
                        m = t.apply(i, n)
                    }

                    function r(t) {
                        return y = t,
                        v = El(s, e),
                        _ ? i(t) : m
                    }

                    function a(t) {
                        var n = t - g,
                        i = t - y,
                        r = e - n;
                        return x ? Vh(r, d - i) : r
                    }

                    function o(t) {
                        var n = t - g,
                        i = t - y;
                        return g === it || n >= e || n < 0 || x && i >= d
                    }

                    function s() {
                        var t = tf();
                        if (o(t)) return u(t);
                        v = El(s, a(t))
                    }

                    function u(t) {
                        return v = it,
                        b && f ? i(t) : (f = p = it, m)
                    }

                    function c() {
                        v !== it && gl(v),
                        y = 0,
                        f = g = p = v = it
                    }

                    function h() {
                        return v === it ? m: u(tf())
                    }

                    function l() {
                        var t = tf(),
                        n = o(t);
                        if (f = arguments, p = this, g = t, n) {
                            if (v === it) return r(g);
                            if (x) return v = El(s, e),
                            i(g)
                        }
                        return v === it && (v = El(s, e)),
                        m
                    }
                    var f, p, d, m, v, g, y = 0,
                    _ = false,
                    x = false,
                    b = true;
                    if ("function" != typeof t) throw new oh(ot);
                    return e = xu(e) || 0,
                    tu(n) && (_ = !!n.leading, x = "maxWait" in n, d = x ? kh(xu(n.maxWait) || 0, e) : d, b = "trailing" in n ? !!n.trailing: b),
                    l.cancel = c,
                    l.flush = h,
                    l
                }

                function Ts(t) {
                    return aa(t, St)
                }

                function As(t, e) {
                    if ("function" != typeof t || null != e && "function" != typeof e) throw new oh(ot);
                    var n = function() {
                        var i = arguments,
                        r = e ? e.apply(this, i) : i[0],
                        a = n.cache;
                        if (a.has(r)) return a.get(r);
                        var o = t.apply(this, i);
                        return n.cache = a.set(r, o) || a,
                        o
                    };
                    return n.cache = new(As.Cache || sn),
                    n
                }

                function Cs(t) {
                    if ("function" != typeof t) throw new oh(ot);
                    return function() {
                        var e = arguments;
                        switch (e.length) {
                        case 0:
                            return ! t.call(this);
                        case 1:
                            return ! t.call(this, e[0]);
                        case 2:
                            return ! t.call(this, e[0], e[1]);
                        case 3:
                            return ! t.call(this, e[0], e[1], e[2])
                        }
                        return ! t.apply(this, e)
                    }
                }

                function Ps(t) {
                    return ws(2, t)
                }

                function Ls(t, e) {
                    if ("function" != typeof t) throw new oh(ot);
                    return e = e === it ? e: yu(e),
                    tr(t, e)
                }

                function Rs(t, e) {
                    if ("function" != typeof t) throw new oh(ot);
                    return e = null == e ? 0 : kh(yu(e), 0),
                    tr(function(n) {
                        var i = n[e],
                        r = wr(n, 0, e);
                        return i && d(r, i),
                        a(t, this, r)
                    })
                }

                function Is(t, e, n) {
                    var i = true,
                    r = true;
                    if ("function" != typeof t) throw new oh(ot);
                    return tu(n) && (i = "leading" in n ? !!n.leading: i, r = "trailing" in n ? !!n.trailing: r),
                    Es(t, e, {
                        leading: i,
                        maxWait: e,
                        trailing: r
                    })
                }

                function Os(t) {
                    return bs(t, 1)
                }

                function Ns(t, e) {
                    return sf(xr(e), t)
                }

                function Ds() {
                    if (!arguments.length) return [];
                    var t = arguments[0];
                    return pf(t) ? t: [t]
                }

                function Us(t) {
                    return ei(t, ft)
                }

                function Bs(t, e) {
                    return e = "function" == typeof e ? e: it,
                    ei(t, ft, e)
                }

                function zs(t) {
                    return ei(t, ht | ft)
                }

                function Fs(t, e) {
                    return e = "function" == typeof e ? e: it,
                    ei(t, ht | ft, e)
                }

                function js(t, e) {
                    return null == e || ii(t, e, Uu(e))
                }

                function ks(t, e) {
                    return t === e || t !== t && e !== e
                }

                function Vs(t) {
                    return null != t && $s(t.length) && !Qs(t)
                }

                function Gs(t) {
                    return eu(t) && Vs(t)
                }

                function Hs(t) {
                    return ! 0 === t || false === t || eu(t) && vi(t) == Vt
                }

                function Ws(t) {
                    return eu(t) && 1 === t.nodeType && !cu(t)
                }

                function Xs(t) {
                    if (null == t) return ! 0;
                    if (Vs(t) && (pf(t) || "string" == typeof t || "function" == typeof t.splice || mf(t) || xf(t) || ff(t))) return ! t.length;
                    var e = wl(t);
                    if (e == Yt || e == te) return ! t.size;
                    if (Ua(t)) return ! Ui(t).length;
                    for (var n in t) if (fh.call(t, n)) return ! 1;
                    return ! 0
                }

                function qs(t, e) {
                    return Ai(t, e)
                }

                function Ys(t, e, n) {
                    n = "function" == typeof n ? n: it;
                    var i = n ? n(t, e) : it;
                    return i === it ? Ai(t, e, it, n) : !!i
                }

                function Zs(t) {
                    if (!eu(t)) return ! 1;
                    var e = vi(t);
                    return e == Wt || e == Ht || "string" == typeof t.message && "string" == typeof t.name && !cu(t)
                }

                function Js(t) {
                    return "number" == typeof t && zh(t)
                }

                function Qs(t) {
                    if (!tu(t)) return ! 1;
                    var e = vi(t);
                    return e == Xt || e == qt || e == kt || e == Kt
                }

                function Ks(t) {
                    return "number" == typeof t && t == yu(t)
                }

                function $s(t) {
                    return "number" == typeof t && t > -1 && t % 1 == 0 && t <= It
                }

                function tu(t) {
                    var e = typeof t;
                    return null != t && ("object" == e || "function" == e)
                }

                function eu(t) {
                    return null != t && "object" == typeof t
                }

                function nu(t, e) {
                    return t === e || Li(t, e, _a(e))
                }

                function iu(t, e, n) {
                    return n = "function" == typeof n ? n: it,
                    Li(t, e, _a(e), n)
                }

                function ru(t) {
                    return uu(t) && t != +t
                }

                function au(t) {
                    if (Ml(t)) throw new th(at);
                    return Ri(t)
                }

                function ou(t) {
                    return null === t
                }

                function su(t) {
                    return null == t
                }

                function uu(t) {
                    return "number" == typeof t || eu(t) && vi(t) == Zt
                }

                function cu(t) {
                    if (!eu(t) || vi(t) != Qt) return ! 1;
                    var e = Mh(t);
                    if (null === e) return ! 0;
                    var n = fh.call(e, "constructor") && e.constructor;
                    return "function" == typeof n && n instanceof n && lh.call(n) == vh
                }

                function hu(t) {
                    return Ks(t) && t >= -It && t <= It
                }

                function lu(t) {
                    return "string" == typeof t || !pf(t) && eu(t) && vi(t) == ee
                }

                function fu(t) {
                    return "symbol" == typeof t || eu(t) && vi(t) == ne
                }

                function pu(t) {
                    return t === it
                }

                function du(t) {
                    return eu(t) && wl(t) == re
                }

                function mu(t) {
                    return eu(t) && vi(t) == ae
                }

                function vu(t) {
                    if (!t) return [];
                    if (Vs(t)) return lu(t) ? $(t) : Or(t);
                    if (Ch && t[Ch]) return G(t[Ch]());
                    var e = wl(t);
                    return (e == Yt ? H: e == te ? Y: Zu)(t)
                }

                function gu(t) {
                    if (!t) return 0 === t ? t: 0;
                    if ((t = xu(t)) === Rt || t === -Rt) {
                        return (t < 0 ? -1 : 1) * Ot
                    }
                    return t === t ? t: 0
                }

                function yu(t) {
                    var e = gu(t),
                    n = e % 1;
                    return e === e ? n ? e - n: e: 0
                }

                function _u(t) {
                    return t ? ti(yu(t), 0, Dt) : 0
                }

                function xu(t) {
                    if ("number" == typeof t) return t;
                    if (fu(t)) return Nt;
                    if (tu(t)) {
                        var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                        t = tu(e) ? e + "": e
                    }
                    if ("string" != typeof t) return 0 === t ? t: +t;
                    t = t.replace(Ie, "");
                    var n = Ge.test(t);
                    return n || We.test(t) ? Cn(t.slice(2), n ? 2 : 8) : Ve.test(t) ? Nt: +t
                }

                function bu(t) {
                    return Nr(t, Bu(t))
                }

                function wu(t) {
                    return t ? ti(yu(t), -It, It) : 0 === t ? t: 0
                }

                function Mu(t) {
                    return null == t ? "": lr(t)
                }

                function Su(t, e) {
                    var n = cl(t);
                    return null == e ? n: Jn(n, e)
                }

                function Eu(t, e) {
                    return x(t, ga(e, 3), li)
                }

                function Tu(t, e) {
                    return x(t, ga(e, 3), fi)
                }

                function Au(t, e) {
                    return null == t ? t: fl(t, ga(e, 3), Bu)
                }

                function Cu(t, e) {
                    return null == t ? t: pl(t, ga(e, 3), Bu)
                }

                function Pu(t, e) {
                    return t && li(t, ga(e, 3))
                }

                function Lu(t, e) {
                    return t && fi(t, ga(e, 3))
                }

                function Ru(t) {
                    return null == t ? [] : pi(t, Uu(t))
                }

                function Iu(t) {
                    return null == t ? [] : pi(t, Bu(t))
                }

                function Ou(t, e, n) {
                    var i = null == t ? it: di(t, e);
                    return i === it ? n: i
                }

                function Nu(t, e) {
                    return null != t && Sa(t, e, yi)
                }

                function Du(t, e) {
                    return null != t && Sa(t, e, _i)
                }

                function Uu(t) {
                    return Vs(t) ? Ln(t) : Ui(t)
                }

                function Bu(t) {
                    return Vs(t) ? Ln(t, true) : Bi(t)
                }

                function zu(t, e) {
                    var n = {};
                    return e = ga(e, 3),
                    li(t,
                    function(t, i, r) {
                        Kn(n, e(t, i, r), t)
                    }),
                    n
                }

                function Fu(t, e) {
                    var n = {};
                    return e = ga(e, 3),
                    li(t,
                    function(t, i, r) {
                        Kn(n, i, e(t, i, r))
                    }),
                    n
                }

                function ju(t, e) {
                    return ku(t, Cs(ga(e)))
                }

                function ku(t, e) {
                    if (null == t) return {};
                    var n = p(da(t),
                    function(t) {
                        return [t]
                    });
                    return e = ga(e),
                    qi(t, n,
                    function(t, n) {
                        return e(t, n[0])
                    })
                }

                function Vu(t, e, n) {
                    e = br(e, t);
                    var i = -1,
                    r = e.length;
                    for (r || (r = 1, t = it); ++i < r;) {
                        var a = null == t ? it: t[Ya(e[i])];
                        a === it && (i = r, a = n),
                        t = Qs(a) ? a.call(t) : a
                    }
                    return t
                }

                function Gu(t, e, n) {
                    return null == t ? t: ir(t, e, n)
                }

                function Hu(t, e, n, i) {
                    return i = "function" == typeof i ? i: it,
                    null == t ? t: ir(t, e, n, i)
                }

                function Wu(t, e, n) {
                    var i = pf(t),
                    r = i || mf(t) || xf(t);
                    if (e = ga(e, 4), null == n) {
                        var a = t && t.constructor;
                        n = r ? i ? new a: [] : tu(t) && Qs(a) ? cl(Mh(t)) : {}
                    }
                    return (r ? s: li)(t,
                    function(t, i, r) {
                        return e(n, t, i, r)
                    }),
                    n
                }

                function Xu(t, e) {
                    return null == t || pr(t, e)
                }

                function qu(t, e, n) {
                    return null == t ? t: dr(t, e, xr(n))
                }

                function Yu(t, e, n, i) {
                    return i = "function" == typeof i ? i: it,
                    null == t ? t: dr(t, e, xr(n), i)
                }

                function Zu(t) {
                    return null == t ? [] : N(t, Uu(t))
                }

                function Ju(t) {
                    return null == t ? [] : N(t, Bu(t))
                }

                function Qu(t, e, n) {
                    return n === it && (n = e, e = it),
                    n !== it && (n = xu(n), n = n === n ? n: 0),
                    e !== it && (e = xu(e), e = e === e ? e: 0),
                    ti(xu(t), e, n)
                }

                function Ku(t, e, n) {
                    return e = gu(e),
                    n === it ? (n = e, e = 0) : n = gu(n),
                    t = xu(t),
                    xi(t, e, n)
                }

                function $u(t, e, n) {
                    if (n && "boolean" != typeof n && Ra(t, e, n) && (e = n = it), n === it && ("boolean" == typeof e ? (n = e, e = it) : "boolean" == typeof t && (n = t, t = it)), t === it && e === it ? (t = 0, e = 1) : (t = gu(t), e === it ? (e = t, t = 0) : e = gu(e)), t > e) {
                        var i = t;
                        t = e,
                        e = i
                    }
                    if (n || t % 1 || e % 1) {
                        var r = Wh();
                        return Vh(t + r * (e - t + An("1e-" + ((r + "").length - 1))), e)
                    }
                    return Qi(t, e)
                }

                function tc(t) {
                    return Xf(Mu(t).toLowerCase())
                }

                function ec(t) {
                    return (t = Mu(t)) && t.replace(qe, Hn).replace(dn, "")
                }

                function nc(t, e, n) {
                    t = Mu(t),
                    e = lr(e);
                    var i = t.length;
                    n = n === it ? i: ti(yu(n), 0, i);
                    var r = n;
                    return (n -= e.length) >= 0 && t.slice(n, r) == e
                }

                function ic(t) {
                    return t = Mu(t),
                    t && Me.test(t) ? t.replace(be, Wn) : t
                }

                function rc(t) {
                    return t = Mu(t),
                    t && Re.test(t) ? t.replace(Le, "\\\\$&") : t
                }

                function ac(t, e, n) {
                    t = Mu(t),
                    e = yu(e);
                    var i = e ? K(t) : 0;
                    if (!e || i >= e) return t;
                    var r = (e - i) / 2;
                    return Kr(Dh(r), n) + t + Kr(Nh(r), n)
                }

                function oc(t, e, n) {
                    t = Mu(t),
                    e = yu(e);
                    var i = e ? K(t) : 0;
                    return e && i < e ? t + Kr(e - i, n) : t
                }

                function sc(t, e, n) {
                    t = Mu(t),
                    e = yu(e);
                    var i = e ? K(t) : 0;
                    return e && i < e ? Kr(e - i, n) + t: t
                }

                function uc(t, e, n) {
                    return n || null == e ? e = 0 : e && (e = +e),
                    Hh(Mu(t).replace(Oe, ""), e || 0)
                }

                function cc(t, e, n) {
                    return e = (n ? Ra(t, e, n) : e === it) ? 1 : yu(e),
                    $i(Mu(t), e)
                }

                function hc() {
                    var t = arguments,
                    e = Mu(t[0]);
                    return t.length < 3 ? e: e.replace(t[1], t[2])
                }

                function lc(t, e, n) {
                    return n && "number" != typeof n && Ra(t, e, n) && (e = n = it),
                    (n = n === it ? Dt: n >>> 0) ? (t = Mu(t), t && ("string" == typeof e || null != e && !yf(e)) && !(e = lr(e)) && k(t) ? wr($(t), 0, n) : t.split(e, n)) : []
                }

                function fc(t, e, n) {
                    return t = Mu(t),
                    n = null == n ? 0 : ti(yu(n), 0, t.length),
                    e = lr(e),
                    t.slice(n, n + e.length) == e
                }

                function pc(t, e, i) {
                    var r = n.templateSettings;
                    i && Ra(t, e, i) && (e = it),
                    t = Mu(t),
                    e = Ef({},
                    e, r, oa);
                    var a, o, s = Ef({},
                    e.imports, r.imports, oa),
                    u = Uu(s),
                    c = N(s, u),
                    h = 0,
                    l = e.interpolate || Ye,
                    f = "__p += '",
                    p = rh((e.escape || Ye).source + "|" + l.source + "|" + (l === Te ? je: Ye).source + "|" + (e.evaluate || Ye).source + "|$", "g"),
                    d = "//# sourceURL=" + ("sourceURL" in e ? e.sourceURL: "lodash.templateSources[" + ++xn + "]") + "\\n";
                    t.replace(p,
                    function(e, n, i, r, s, u) {
                        return i || (i = r),
                        f += t.slice(h, u).replace(Ze, F),
                        n && (a = true, f += "' +\\n__e(" + n + ") +\\n'"),
                        s && (o = true, f += "';\\n" + s + ";\\n__p += '"),
                        i && (f += "' +\\n((__t = (" + i + ")) == null ? '' : __t) +\\n'"),
                        h = u + e.length,
                        e
                    }),
                    f += "';\\n";
                    var m = e.variable;
                    m || (f = "with (obj) {\\n" + f + "\\n}\\n"),
                    f = (o ? f.replace(ge, "") : f).replace(ye, "$1").replace(_e, "$1;"),
                    f = "function(" + (m || "obj") + ") {\\n" + (m ? "": "obj || (obj = {});\\n") + "var __t, __p = ''" + (a ? ", __e = _.escape": "") + (o ? ", __j = Array.prototype.join;\\nfunction print() { __p += __j.call(arguments, '') }\\n": ";\\n") + f + "return __p\\n}";
                    var v = qf(function() {
                        return eh(u, d + "return " + f).apply(it, c)
                    });
                    if (v.source = f, Zs(v)) throw v;
                    return v
                }

                function dc(t) {
                    return Mu(t).toLowerCase()
                }

                function mc(t) {
                    return Mu(t).toUpperCase()
                }

                function vc(t, e, n) {
                    if ((t = Mu(t)) && (n || e === it)) return t.replace(Ie, "");
                    if (!t || !(e = lr(e))) return t;
                    var i = $(t),
                    r = $(e);
                    return wr(i, U(i, r), B(i, r) + 1).join("")
                }

                function gc(t, e, n) {
                    if ((t = Mu(t)) && (n || e === it)) return t.replace(Ne, "");
                    if (!t || !(e = lr(e))) return t;
                    var i = $(t);
                    return wr(i, 0, B(i, $(e)) + 1).join("")
                }

                function yc(t, e, n) {
                    if ((t = Mu(t)) && (n || e === it)) return t.replace(Oe, "");
                    if (!t || !(e = lr(e))) return t;
                    var i = $(t);
                    return wr(i, U(i, $(e))).join("")
                }

                function _c(t, e) {
                    var n = Et,
                    i = Tt;
                    if (tu(e)) {
                        var r = "separator" in e ? e.separator: r;
                        n = "length" in e ? yu(e.length) : n,
                        i = "omission" in e ? lr(e.omission) : i
                    }
                    t = Mu(t);
                    var a = t.length;
                    if (k(t)) {
                        var o = $(t);
                        a = o.length
                    }
                    if (n >= a) return t;
                    var s = n - K(i);
                    if (s < 1) return i;
                    var u = o ? wr(o, 0, s).join("") : t.slice(0, s);
                    if (r === it) return u + i;
                    if (o && (s += u.length - s), yf(r)) {
                        if (t.slice(s).search(r)) {
                            var c, h = u;
                            for (r.global || (r = rh(r.source, Mu(ke.exec(r)) + "g")), r.lastIndex = 0; c = r.exec(h);) var l = c.index;
                            u = u.slice(0, l === it ? s: l)
                        }
                    } else if (t.indexOf(lr(r), s) != s) {
                        var f = u.lastIndexOf(r);
                        f > -1 && (u = u.slice(0, f))
                    }
                    return u + i
                }

                function xc(t) {
                    return t = Mu(t),
                    t && we.test(t) ? t.replace(xe, Xn) : t
                }

                function bc(t, e, n) {
                    return t = Mu(t),
                    e = n ? it: e,
                    e === it ? V(t) ? nt(t) : _(t) : t.match(e) || []
                }

                function wc(t) {
                    var e = null == t ? 0 : t.length,
                    n = ga();
                    return t = e ? p(t,
                    function(t) {
                        if ("function" != typeof t[1]) throw new oh(ot);
                        return [n(t[0]), t[1]]
                    }) : [],
                    tr(function(n) {
                        for (var i = -1; ++i < e;) {
                            var r = t[i];
                            if (a(r[0], this, n)) return a(r[1], this, n)
                        }
                    })
                }

                function Mc(t) {
                    return ni(ei(t, ht))
                }

                function Sc(t) {
                    return function() {
                        return t
                    }
                }

                function Ec(t, e) {
                    return null == t || t !== t ? e: t
                }

                function Tc(t) {
                    return t
                }

                function Ac(t) {
                    return Di("function" == typeof t ? t: ei(t, ht))
                }

                function Cc(t) {
                    return ji(ei(t, ht))
                }

                function Pc(t, e) {
                    return ki(t, ei(e, ht))
                }

                function Lc(t, e, n) {
                    var i = Uu(e),
                    r = pi(e, i);
                    null != n || tu(e) && (r.length || !i.length) || (n = e, e = t, t = this, r = pi(e, Uu(e)));
                    var a = !(tu(n) && "chain" in n && !n.chain),
                    o = Qs(t);
                    return s(r,
                    function(n) {
                        var i = e[n];
                        t[n] = i,
                        o && (t.prototype[n] = function() {
                            var e = this.__chain__;
                            if (a || e) {
                                var n = t(this.__wrapped__);
                                return (n.__actions__ = Or(this.__actions__)).push({
                                    func: i,
                                    args: arguments,
                                    thisArg: t
                                }),
                                n.__chain__ = e,
                                n
                            }
                            return i.apply(t, d([this.value()], arguments))
                        })
                    }),
                    t
                }

                function Rc() {
                    return Rn._ === this && (Rn._ = gh),
                    this
                }

                function Ic() {}

                function Oc(t) {
                    return t = yu(t),
                    tr(function(e) {
                        return Hi(e, t)
                    })
                }

                function Nc(t) {
                    return Ia(t) ? T(Ya(t)) : Yi(t)
                }

                function Dc(t) {
                    return function(e) {
                        return null == t ? it: di(t, e)
                    }
                }

                function Uc() {
                    return []
                }

                function Bc() {
                    return ! 1
                }

                function zc() {
                    return {}
                }

                function Fc() {
                    return ""
                }

                function jc() {
                    return ! 0
                }

                function kc(t, e) {
                    if ((t = yu(t)) < 1 || t > It) return [];
                    var n = Dt,
                    i = Vh(t, Dt);
                    e = ga(e),
                    t -= Dt;
                    for (var r = R(i, e); ++n < t;) e(n);
                    return r
                }

                function Vc(t) {
                    return pf(t) ? p(t, Ya) : fu(t) ? [t] : Or(Al(Mu(t)))
                }

                function Gc(t) {
                    var e = ++ph;
                    return Mu(t) + e
                }

                function Hc(t) {
                    return t && t.length ? si(t, Tc, gi) : it
                }

                function Wc(t, e) {
                    return t && t.length ? si(t, ga(e, 2), gi) : it
                }

                function Xc(t) {
                    return E(t, Tc)
                }

                function qc(t, e) {
                    return E(t, ga(e, 2))
                }

                function Yc(t) {
                    return t && t.length ? si(t, Tc, zi) : it
                }

                function Zc(t, e) {
                    return t && t.length ? si(t, ga(e, 2), zi) : it
                }

                function Jc(t) {
                    return t && t.length ? L(t, Tc) : 0
                }

                function Qc(t, e) {
                    return t && t.length ? L(t, ga(e, 2)) : 0
                }
                e = null == e ? Rn: qn.defaults(Rn.Object(), e, qn.pick(Rn, _n));
                var Kc = e.Array,
                $c = e.Date,
                th = e.Error,
                eh = e.Function,
                nh = e.Math,
                ih = e.Object,
                rh = e.RegExp,
                ah = e.String,
                oh = e.TypeError,
                sh = Kc.prototype,
                uh = eh.prototype,
                ch = ih.prototype,
                hh = e["__core-js_shared__"],
                lh = uh.toString,
                fh = ch.hasOwnProperty,
                ph = 0,
                dh = function() {
                    var t = /[^.]+$/.exec(hh && hh.keys && hh.keys.IE_PROTO || "");
                    return t ? "Symbol(src)_1." + t: ""
                } (),
                mh = ch.toString,
                vh = lh.call(ih),
                gh = Rn._,
                yh = rh("^" + lh.call(fh).replace(Le, "\\\\$&").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, "$1.*?") + "$"),
                _h = Nn ? e.Buffer: it,
                xh = e.Symbol,
                bh = e.Uint8Array,
                wh = _h ? _h.allocUnsafe: it,
                Mh = W(ih.getPrototypeOf, ih),
                Sh = ih.create,
                Eh = ch.propertyIsEnumerable,
                Th = sh.splice,
                Ah = xh ? xh.isConcatSpreadable: it,
                Ch = xh ? xh.iterator: it,
                Ph = xh ? xh.toStringTag: it,
                Lh = function() {
                    try {
                        var t = xa(ih, "defineProperty");
                        return t({},
                        "", {}),
                        t
                    } catch(t) {}
                } (),
                Rh = e.clearTimeout !== Rn.clearTimeout && e.clearTimeout,
                Ih = $c && $c.now !== Rn.Date.now && $c.now,
                Oh = e.setTimeout !== Rn.setTimeout && e.setTimeout,
                Nh = nh.ceil,
                Dh = nh.floor,
                Uh = ih.getOwnPropertySymbols,
                Bh = _h ? _h.isBuffer: it,
                zh = e.isFinite,
                Fh = sh.join,
                jh = W(ih.keys, ih),
                kh = nh.max,
                Vh = nh.min,
                Gh = $c.now,
                Hh = e.parseInt,
                Wh = nh.random,
                Xh = sh.reverse,
                qh = xa(e, "DataView"),
                Yh = xa(e, "Map"),
                Zh = xa(e, "Promise"),
                Jh = xa(e, "Set"),
                Qh = xa(e, "WeakMap"),
                Kh = xa(ih, "create"),
                $h = Qh && new Qh,
                tl = {},
                el = Za(qh),
                nl = Za(Yh),
                il = Za(Zh),
                rl = Za(Jh),
                al = Za(Qh),
                ol = xh ? xh.prototype: it,
                sl = ol ? ol.valueOf: it,
                ul = ol ? ol.toString: it,
                cl = function() {
                    function t() {}
                    return function(e) {
                        if (!tu(e)) return {};
                        if (Sh) return Sh(e);
                        t.prototype = e;
                        var n = new t;
                        return t.prototype = it,
                        n
                    }
                } ();
                n.templateSettings = {
                    escape: Se,
                    evaluate: Ee,
                    interpolate: Te,
                    variable: "",
                    imports: {
                        _: n
                    }
                },
                n.prototype = i.prototype,
                n.prototype.constructor = n,
                r.prototype = cl(i.prototype),
                r.prototype.constructor = r,
                y.prototype = cl(i.prototype),
                y.prototype.constructor = y,
                et.prototype.clear = ze,
                et.prototype.delete = Je,
                et.prototype.get = Qe,
                et.prototype.has = Ke,
                et.prototype.set = $e,
                tn.prototype.clear = en,
                tn.prototype.delete = nn,
                tn.prototype.get = rn,
                tn.prototype.has = an,
                tn.prototype.set = on,
                sn.prototype.clear = un,
                sn.prototype.delete = cn,
                sn.prototype.get = hn,
                sn.prototype.has = ln,
                sn.prototype.set = fn,
                mn.prototype.add = mn.prototype.push = vn,
                mn.prototype.has = gn,
                yn.prototype.clear = Mn,
                yn.prototype.delete = Sn,
                yn.prototype.get = En,
                yn.prototype.has = Tn,
                yn.prototype.set = Pn;
                var hl = Fr(li),
                ll = Fr(fi, true),
                fl = jr(),
                pl = jr(true),
                dl = $h ?
                function(t, e) {
                    return $h.set(t, e),
                    t
                }: Tc,
                ml = Lh ?
                function(t, e) {
                    return Lh(t, "toString", {
                        configurable: true,
                        enumerable: false,
                        value: Sc(e),
                        writable: true
                    })
                }: Tc,
                vl = tr,
                gl = Rh ||
                function(t) {
                    return Rn.clearTimeout(t)
                },
                yl = Jh && 1 / Y(new Jh([, -0]))[1] == Rt ?
                function(t) {
                    return new Jh(t)
                }: Ic,
                _l = $h ?
                function(t) {
                    return $h.get(t)
                }: Ic,
                xl = Uh ?
                function(t) {
                    return null == t ? [] : (t = ih(t), h(Uh(t),
                    function(e) {
                        return Eh.call(t, e)
                    }))
                }: Uc,
                bl = Uh ?
                function(t) {
                    for (var e = []; t;) d(e, xl(t)),
                    t = Mh(t);
                    return e
                }: Uc,
                wl = vi; (qh && wl(new qh(new ArrayBuffer(1))) != se || Yh && wl(new Yh) != Yt || Zh && "[object Promise]" != wl(Zh.resolve()) || Jh && wl(new Jh) != te || Qh && wl(new Qh) != re) && (wl = function(t) {
                    var e = vi(t),
                    n = e == Qt ? t.constructor: it,
                    i = n ? Za(n) : "";
                    if (i) switch (i) {
                    case el:
                        return se;
                    case nl:
                        return Yt;
                    case il:
                        return "[object Promise]";
                    case rl:
                        return te;
                    case al:
                        return re
                    }
                    return e
                });
                var Ml = hh ? Qs: Bc,
                Sl = Xa(dl),
                El = Oh ||
                function(t, e) {
                    return Rn.setTimeout(t, e)
                },
                Tl = Xa(ml),
                Al = function(t) {
                    var e = As(t,
                    function(t) {
                        return n.size === ut && n.clear(),
                        t
                    }),
                    n = e.cache;
                    return e
                } (function(t) {
                    var e = [];
                    return 46 === t.charCodeAt(0) && e.push(""),
                    t.replace(Pe,
                    function(t, n, i, r) {
                        e.push(i ? r.replace(Fe, "$1") : n || t)
                    }),
                    e
                }),
                Cl = tr(function(t, e) {
                    return Gs(t) ? ai(t, hi(e, 1, Gs, true)) : []
                }),
                Pl = tr(function(t, e) {
                    var n = go(e);
                    return Gs(n) && (n = it),
                    Gs(t) ? ai(t, hi(e, 1, Gs, true), ga(n, 2)) : []
                }),
                Ll = tr(function(t, e) {
                    var n = go(e);
                    return Gs(n) && (n = it),
                    Gs(t) ? ai(t, hi(e, 1, Gs, true), it, n) : []
                }),
                Rl = tr(function(t) {
                    var e = p(t, _r);
                    return e.length && e[0] === t[0] ? bi(e) : []
                }),
                Il = tr(function(t) {
                    var e = go(t),
                    n = p(t, _r);
                    return e === go(n) ? e = it: n.pop(),
                    n.length && n[0] === t[0] ? bi(n, ga(e, 2)) : []
                }),
                Ol = tr(function(t) {
                    var e = go(t),
                    n = p(t, _r);
                    return e = "function" == typeof e ? e: it,
                    e && n.pop(),
                    n.length && n[0] === t[0] ? bi(n, it, e) : []
                }),
                Nl = tr(xo),
                Dl = fa(function(t, e) {
                    var n = null == t ? 0 : t.length,
                    i = $n(t, e);
                    return Ji(t, p(e,
                    function(t) {
                        return La(t, n) ? +t: t
                    }).sort(Pr)),
                    i
                }),
                Ul = tr(function(t) {
                    return fr(hi(t, 1, Gs, true))
                }),
                Bl = tr(function(t) {
                    var e = go(t);
                    return Gs(e) && (e = it),
                    fr(hi(t, 1, Gs, true), ga(e, 2))
                }),
                zl = tr(function(t) {
                    var e = go(t);
                    return e = "function" == typeof e ? e: it,
                    fr(hi(t, 1, Gs, true), it, e)
                }),
                Fl = tr(function(t, e) {
                    return Gs(t) ? ai(t, e) : []
                }),
                jl = tr(function(t) {
                    return gr(h(t, Gs))
                }),
                kl = tr(function(t) {
                    var e = go(t);
                    return Gs(e) && (e = it),
                    gr(h(t, Gs), ga(e, 2))
                }),
                Vl = tr(function(t) {
                    var e = go(t);
                    return e = "function" == typeof e ? e: it,
                    gr(h(t, Gs), it, e)
                }),
                Gl = tr(Vo),
                Hl = tr(function(t) {
                    var e = t.length,
                    n = e > 1 ? t[e - 1] : it;
                    return n = "function" == typeof n ? (t.pop(), n) : it,
                    Go(t, n)
                }),
                Wl = fa(function(t) {
                    var e = t.length,
                    n = e ? t[0] : 0,
                    i = this.__wrapped__,
                    a = function(e) {
                        return $n(e, t)
                    };
                    return ! (e > 1 || this.__actions__.length) && i instanceof y && La(n) ? (i = i.slice(n, +n + (e ? 1 : 0)), i.__actions__.push({
                        func: Yo,
                        args: [a],
                        thisArg: it
                    }), new r(i, this.__chain__).thru(function(t) {
                        return e && !t.length && t.push(it),
                        t
                    })) : this.thru(a)
                }),
                Xl = Br(function(t, e, n) {
                    fh.call(t, n) ? ++t[n] : Kn(t, n, 1)
                }),
                ql = Xr(oo),
                Yl = Xr(so),
                Zl = Br(function(t, e, n) {
                    fh.call(t, n) ? t[n].push(e) : Kn(t, n, [e])
                }),
                Jl = tr(function(t, e, n) {
                    var i = -1,
                    r = "function" == typeof e,
                    o = Vs(t) ? Kc(t.length) : [];
                    return hl(t,
                    function(t) {
                        o[++i] = r ? a(e, t, n) : Mi(t, e, n)
                    }),
                    o
                }),
                Ql = Br(function(t, e, n) {
                    Kn(t, n, e)
                }),
                Kl = Br(function(t, e, n) {
                    t[n ? 0 : 1].push(e)
                },
                function() {
                    return [[], []]
                }),
                $l = tr(function(t, e) {
                    if (null == t) return [];
                    var n = e.length;
                    return n > 1 && Ra(t, e[0], e[1]) ? e = [] : n > 2 && Ra(e[0], e[1], e[2]) && (e = [e[0]]),
                    Wi(t, hi(e, 1), [])
                }),
                tf = Ih ||
                function() {
                    return Rn.Date.now()
                },
                ef = tr(function(t, e, n) {
                    var i = mt;
                    if (n.length) {
                        var r = X(n, va(ef));
                        i |= xt
                    }
                    return aa(t, i, e, n, r)
                }),
                nf = tr(function(t, e, n) {
                    var i = mt | vt;
                    if (n.length) {
                        var r = X(n, va(nf));
                        i |= xt
                    }
                    return aa(e, i, t, n, r)
                }),
                rf = tr(function(t, e) {
                    return ri(t, 1, e)
                }),
                af = tr(function(t, e, n) {
                    return ri(t, xu(e) || 0, n)
                });
                As.Cache = sn;
                var of = vl(function(t, e) {
                    e = 1 == e.length && pf(e[0]) ? p(e[0], O(ga())) : p(hi(e, 1), O(ga()));
                    var n = e.length;
                    return tr(function(i) {
                        for (var r = -1,
                        o = Vh(i.length, n); ++r < o;) i[r] = e[r].call(this, i[r]);
                        return a(t, this, i)
                    })
                }),
                sf = tr(function(t, e) {
                    var n = X(e, va(sf));
                    return aa(t, xt, it, e, n)
                }),
                uf = tr(function(t, e) {
                    var n = X(e, va(uf));
                    return aa(t, bt, it, e, n)
                }),
                cf = fa(function(t, e) {
                    return aa(t, Mt, it, it, it, e)
                }),
                hf = ea(gi),
                lf = ea(function(t, e) {
                    return t >= e
                }),
                ff = Si(function() {
                    return arguments
                } ()) ? Si: function(t) {
                    return eu(t) && fh.call(t, "callee") && !Eh.call(t, "callee")
                },
                pf = Kc.isArray,
                df = Bn ? O(Bn) : Ei,
                mf = Bh || Bc,
                vf = zn ? O(zn) : Ti,
                gf = Fn ? O(Fn) : Pi,
                yf = jn ? O(jn) : Ii,
                _f = kn ? O(kn) : Oi,
                xf = Vn ? O(Vn) : Ni,
                bf = ea(zi),
                wf = ea(function(t, e) {
                    return t <= e
                }),
                Mf = zr(function(t, e) {
                    if (Ua(e) || Vs(e)) return void Nr(e, Uu(e), t);
                    for (var n in e) fh.call(e, n) && Gn(t, n, e[n])
                }),
                Sf = zr(function(t, e) {
                    Nr(e, Bu(e), t)
                }),
                Ef = zr(function(t, e, n, i) {
                    Nr(e, Bu(e), t, i)
                }),
                Tf = zr(function(t, e, n, i) {
                    Nr(e, Uu(e), t, i)
                }),
                Af = fa($n),
                Cf = tr(function(t, e) {
                    t = ih(t);
                    var n = -1,
                    i = e.length,
                    r = i > 2 ? e[2] : it;
                    for (r && Ra(e[0], e[1], r) && (i = 1); ++n < i;) for (var a = e[n], o = Bu(a), s = -1, u = o.length; ++s < u;) {
                        var c = o[s],
                        h = t[c]; (h === it || ks(h, ch[c]) && !fh.call(t, c)) && (t[c] = a[c])
                    }
                    return t
                }),
                Pf = tr(function(t) {
                    return t.push(it, sa),
                    a(Nf, it, t)
                }),
                Lf = Zr(function(t, e, n) {
                    null != e && "function" != typeof e.toString && (e = mh.call(e)),
                    t[e] = n
                },
                Sc(Tc)),
                Rf = Zr(function(t, e, n) {
                    null != e && "function" != typeof e.toString && (e = mh.call(e)),
                    fh.call(t, e) ? t[e].push(n) : t[e] = [n]
                },
                ga),
                If = tr(Mi),
                Of = zr(function(t, e, n) {
                    Vi(t, e, n)
                }),
                Nf = zr(function(t, e, n, i) {
                    Vi(t, e, n, i)
                }),
                Df = fa(function(t, e) {
                    var n = {};
                    if (null == t) return n;
                    var i = false;
                    e = p(e,
                    function(e) {
                        return e = br(e, t),
                        i || (i = e.length > 1),
                        e
                    }),
                    Nr(t, da(t), n),
                    i && (n = ei(n, ht | lt | ft, ua));
                    for (var r = e.length; r--;) pr(n, e[r]);
                    return n
                }),
                Uf = fa(function(t, e) {
                    return null == t ? {}: Xi(t, e)
                }),
                Bf = ra(Uu),
                zf = ra(Bu),
                Ff = Gr(function(t, e, n) {
                    return e = e.toLowerCase(),
                    t + (n ? tc(e) : e)
                }),
                jf = Gr(function(t, e, n) {
                    return t + (n ? "-": "") + e.toLowerCase()
                }),
                kf = Gr(function(t, e, n) {
                    return t + (n ? " ": "") + e.toLowerCase()
                }),
                Vf = Vr("toLowerCase"),
                Gf = Gr(function(t, e, n) {
                    return t + (n ? "_": "") + e.toLowerCase()
                }),
                Hf = Gr(function(t, e, n) {
                    return t + (n ? " ": "") + Xf(e)
                }),
                Wf = Gr(function(t, e, n) {
                    return t + (n ? " ": "") + e.toUpperCase()
                }),
                Xf = Vr("toUpperCase"),
                qf = tr(function(t, e) {
                    try {
                        return a(t, it, e)
                    } catch(t) {
                        return Zs(t) ? t: new th(t)
                    }
                }),
                Yf = fa(function(t, e) {
                    return s(e,
                    function(e) {
                        e = Ya(e),
                        Kn(t, e, ef(t[e], t))
                    }),
                    t
                }),
                Zf = qr(),
                Jf = qr(true),
                Qf = tr(function(t, e) {
                    return function(n) {
                        return Mi(n, t, e)
                    }
                }),
                Kf = tr(function(t, e) {
                    return function(n) {
                        return Mi(t, n, e)
                    }
                }),
                $f = Qr(p),
                tp = Qr(c),
                ep = Qr(g),
                np = ta(),
                ip = ta(true),
                rp = Jr(function(t, e) {
                    return t + e
                },
                0),
                ap = ia("ceil"),
                op = Jr(function(t, e) {
                    return t / e
                },
                1),
                sp = ia("floor"),
                up = Jr(function(t, e) {
                    return t * e
                },
                1),
                cp = ia("round"),
                hp = Jr(function(t, e) {
                    return t - e
                },
                0);
                return n.after = xs,
                n.ary = bs,
                n.assign = Mf,
                n.assignIn = Sf,
                n.assignInWith = Ef,
                n.assignWith = Tf,
                n.at = Af,
                n.before = ws,
                n.bind = ef,
                n.bindAll = Yf,
                n.bindKey = nf,
                n.castArray = Ds,
                n.chain = Xo,
                n.chunk = Ka,
                n.compact = $a,
                n.concat = to,
                n.cond = wc,
                n.conforms = Mc,
                n.constant = Sc,
                n.countBy = Xl,
                n.create = Su,
                n.curry = Ms,
                n.curryRight = Ss,
                n.debounce = Es,
                n.defaults = Cf,
                n.defaultsDeep = Pf,
                n.defer = rf,
                n.delay = af,
                n.difference = Cl,
                n.differenceBy = Pl,
                n.differenceWith = Ll,
                n.drop = eo,
                n.dropRight = no,
                n.dropRightWhile = io,
                n.dropWhile = ro,
                n.fill = ao,
                n.filter = is,
                n.flatMap = rs,
                n.flatMapDeep = as,
                n.flatMapDepth = os,
                n.flatten = uo,
                n.flattenDeep = co,
                n.flattenDepth = ho,
                n.flip = Ts,
                n.flow = Zf,
                n.flowRight = Jf,
                n.fromPairs = lo,
                n.functions = Ru,
                n.functionsIn = Iu,
                n.groupBy = Zl,
                n.initial = mo,
                n.intersection = Rl,
                n.intersectionBy = Il,
                n.intersectionWith = Ol,
                n.invert = Lf,
                n.invertBy = Rf,
                n.invokeMap = Jl,
                n.iteratee = Ac,
                n.keyBy = Ql,
                n.keys = Uu,
                n.keysIn = Bu,
                n.map = hs,
                n.mapKeys = zu,
                n.mapValues = Fu,
                n.matches = Cc,
                n.matchesProperty = Pc,
                n.memoize = As,
                n.merge = Of,
                n.mergeWith = Nf,
                n.method = Qf,
                n.methodOf = Kf,
                n.mixin = Lc,
                n.negate = Cs,
                n.nthArg = Oc,
                n.omit = Df,
                n.omitBy = ju,
                n.once = Ps,
                n.orderBy = ls,
                n.over = $f,
                n.overArgs = of,
                n.overEvery = tp,
                n.overSome = ep,
                n.partial = sf,
                n.partialRight = uf,
                n.partition = Kl,
                n.pick = Uf,
                n.pickBy = ku,
                n.property = Nc,
                n.propertyOf = Dc,
                n.pull = Nl,
                n.pullAll = xo,
                n.pullAllBy = bo,
                n.pullAllWith = wo,
                n.pullAt = Dl,
                n.range = np,
                n.rangeRight = ip,
                n.rearg = cf,
                n.reject = ds,
                n.remove = Mo,
                n.rest = Ls,
                n.reverse = So,
                n.sampleSize = vs,
                n.set = Gu,
                n.setWith = Hu,
                n.shuffle = gs,
                n.slice = Eo,
                n.sortBy = $l,
                n.sortedUniq = Io,
                n.sortedUniqBy = Oo,
                n.split = lc,
                n.spread = Rs,
                n.tail = No,
                n.take = Do,
                n.takeRight = Uo,
                n.takeRightWhile = Bo,
                n.takeWhile = zo,
                n.tap = qo,
                n.throttle = Is,
                n.thru = Yo,
                n.toArray = vu,
                n.toPairs = Bf,
                n.toPairsIn = zf,
                n.toPath = Vc,
                n.toPlainObject = bu,
                n.transform = Wu,
                n.unary = Os,
                n.union = Ul,
                n.unionBy = Bl,
                n.unionWith = zl,
                n.uniq = Fo,
                n.uniqBy = jo,
                n.uniqWith = ko,
                n.unset = Xu,
                n.unzip = Vo,
                n.unzipWith = Go,
                n.update = qu,
                n.updateWith = Yu,
                n.values = Zu,
                n.valuesIn = Ju,
                n.without = Fl,
                n.words = bc,
                n.wrap = Ns,
                n.xor = jl,
                n.xorBy = kl,
                n.xorWith = Vl,
                n.zip = Gl,
                n.zipObject = Ho,
                n.zipObjectDeep = Wo,
                n.zipWith = Hl,
                n.entries = Bf,
                n.entriesIn = zf,
                n.extend = Sf,
                n.extendWith = Ef,
                Lc(n, n),
                n.add = rp,
                n.attempt = qf,
                n.camelCase = Ff,
                n.capitalize = tc,
                n.ceil = ap,
                n.clamp = Qu,
                n.clone = Us,
                n.cloneDeep = zs,
                n.cloneDeepWith = Fs,
                n.cloneWith = Bs,
                n.conformsTo = js,
                n.deburr = ec,
                n.defaultTo = Ec,
                n.divide = op,
                n.endsWith = nc,
                n.eq = ks,
                n.escape = ic,
                n.escapeRegExp = rc,
                n.every = ns,
                n.find = ql,
                n.findIndex = oo,
                n.findKey = Eu,
                n.findLast = Yl,
                n.findLastIndex = so,
                n.findLastKey = Tu,
                n.floor = sp,
                n.forEach = ss,
                n.forEachRight = us,
                n.forIn = Au,
                n.forInRight = Cu,
                n.forOwn = Pu,
                n.forOwnRight = Lu,
                n.get = Ou,
                n.gt = hf,
                n.gte = lf,
                n.has = Nu,
                n.hasIn = Du,
                n.head = fo,
                n.identity = Tc,
                n.includes = cs,
                n.indexOf = po,
                n.inRange = Ku,
                n.invoke = If,
                n.isArguments = ff,
                n.isArray = pf,
                n.isArrayBuffer = df,
                n.isArrayLike = Vs,
                n.isArrayLikeObject = Gs,
                n.isBoolean = Hs,
                n.isBuffer = mf,
                n.isDate = vf,
                n.isElement = Ws,
                n.isEmpty = Xs,
                n.isEqual = qs,
                n.isEqualWith = Ys,
                n.isError = Zs,
                n.isFinite = Js,
                n.isFunction = Qs,
                n.isInteger = Ks,
                n.isLength = $s,
                n.isMap = gf,
                n.isMatch = nu,
                n.isMatchWith = iu,
                n.isNaN = ru,
                n.isNative = au,
                n.isNil = su,
                n.isNull = ou,
                n.isNumber = uu,
                n.isObject = tu,
                n.isObjectLike = eu,
                n.isPlainObject = cu,
                n.isRegExp = yf,
                n.isSafeInteger = hu,
                n.isSet = _f,
                n.isString = lu,
                n.isSymbol = fu,
                n.isTypedArray = xf,
                n.isUndefined = pu,
                n.isWeakMap = du,
                n.isWeakSet = mu,
                n.join = vo,
                n.kebabCase = jf,
                n.last = go,
                n.lastIndexOf = yo,
                n.lowerCase = kf,
                n.lowerFirst = Vf,
                n.lt = bf,
                n.lte = wf,
                n.max = Hc,
                n.maxBy = Wc,
                n.mean = Xc,
                n.meanBy = qc,
                n.min = Yc,
                n.minBy = Zc,
                n.stubArray = Uc,
                n.stubFalse = Bc,
                n.stubObject = zc,
                n.stubString = Fc,
                n.stubTrue = jc,
                n.multiply = up,
                n.nth = _o,
                n.noConflict = Rc,
                n.noop = Ic,
                n.now = tf,
                n.pad = ac,
                n.padEnd = oc,
                n.padStart = sc,
                n.parseInt = uc,
                n.random = $u,
                n.reduce = fs,
                n.reduceRight = ps,
                n.repeat = cc,
                n.replace = hc,
                n.result = Vu,
                n.round = cp,
                n.runInContext = t,
                n.sample = ms,
                n.size = ys,
                n.snakeCase = Gf,
                n.some = _s,
                n.sortedIndex = To,
                n.sortedIndexBy = Ao,
                n.sortedIndexOf = Co,
                n.sortedLastIndex = Po,
                n.sortedLastIndexBy = Lo,
                n.sortedLastIndexOf = Ro,
                n.startCase = Hf,
                n.startsWith = fc,
                n.subtract = hp,
                n.sum = Jc,
                n.sumBy = Qc,
                n.template = pc,
                n.times = kc,
                n.toFinite = gu,
                n.toInteger = yu,
                n.toLength = _u,
                n.toLower = dc,
                n.toNumber = xu,
                n.toSafeInteger = wu,
                n.toString = Mu,
                n.toUpper = mc,
                n.trim = vc,
                n.trimEnd = gc,
                n.trimStart = yc,
                n.truncate = _c,
                n.unescape = xc,
                n.uniqueId = Gc,
                n.upperCase = Wf,
                n.upperFirst = Xf,
                n.each = ss,
                n.eachRight = us,
                n.first = fo,
                Lc(n,
                function() {
                    var t = {};
                    return li(n,
                    function(e, i) {
                        fh.call(n.prototype, i) || (t[i] = e)
                    }),
                    t
                } (), {
                    chain: false
                }),
                n.VERSION = "4.17.10",
                s(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"],
                function(t) {
                    n[t].placeholder = n
                }),
                s(["drop", "take"],
                function(t, e) {
                    y.prototype[t] = function(n) {
                        n = n === it ? 1 : kh(yu(n), 0);
                        var i = this.__filtered__ && !e ? new y(this) : this.clone();
                        return i.__filtered__ ? i.__takeCount__ = Vh(n, i.__takeCount__) : i.__views__.push({
                            size: Vh(n, Dt),
                            type: t + (i.__dir__ < 0 ? "Right": "")
                        }),
                        i
                    },
                    y.prototype[t + "Right"] = function(e) {
                        return this.reverse()[t](e).reverse()
                    }
                }),
                s(["filter", "map", "takeWhile"],
                function(t, e) {
                    var n = e + 1,
                    i = n == Pt || 3 == n;
                    y.prototype[t] = function(t) {
                        var e = this.clone();
                        return e.__iteratees__.push({
                            iteratee: ga(t, 3),
                            type: n
                        }),
                        e.__filtered__ = e.__filtered__ || i,
                        e
                    }
                }),
                s(["head", "last"],
                function(t, e) {
                    var n = "take" + (e ? "Right": "");
                    y.prototype[t] = function() {
                        return this[n](1).value()[0]
                    }
                }),
                s(["initial", "tail"],
                function(t, e) {
                    var n = "drop" + (e ? "": "Right");
                    y.prototype[t] = function() {
                        return this.__filtered__ ? new y(this) : this[n](1)
                    }
                }),
                y.prototype.compact = function() {
                    return this.filter(Tc)
                },
                y.prototype.find = function(t) {
                    return this.filter(t).head()
                },
                y.prototype.findLast = function(t) {
                    return this.reverse().find(t)
                },
                y.prototype.invokeMap = tr(function(t, e) {
                    return "function" == typeof t ? new y(this) : this.map(function(n) {
                        return Mi(n, t, e)
                    })
                }),
                y.prototype.reject = function(t) {
                    return this.filter(Cs(ga(t)))
                },
                y.prototype.slice = function(t, e) {
                    t = yu(t);
                    var n = this;
                    return n.__filtered__ && (t > 0 || e < 0) ? new y(n) : (t < 0 ? n = n.takeRight( - t) : t && (n = n.drop(t)), e !== it && (e = yu(e), n = e < 0 ? n.dropRight( - e) : n.take(e - t)), n)
                },
                y.prototype.takeRightWhile = function(t) {
                    return this.reverse().takeWhile(t).reverse()
                },
                y.prototype.toArray = function() {
                    return this.take(Dt)
                },
                li(y.prototype,
                function(t, e) {
                    var i = /^(?:filter|find|map|reject)|While$/.test(e),
                    a = /^(?:head|last)$/.test(e),
                    o = n[a ? "take" + ("last" == e ? "Right": "") : e],
                    s = a || /^find/.test(e);
                    o && (n.prototype[e] = function() {
                        var e = this.__wrapped__,
                        u = a ? [1] : arguments,
                        c = e instanceof y,
                        h = u[0],
                        l = c || pf(e),
                        f = function(t) {
                            var e = o.apply(n, d([t], u));
                            return a && p ? e[0] : e
                        };
                        l && i && "function" == typeof h && 1 != h.length && (c = l = false);
                        var p = this.__chain__,
                        m = !!this.__actions__.length,
                        v = s && !p,
                        g = c && !m;
                        if (!s && l) {
                            e = g ? e: new y(this);
                            var _ = t.apply(e, u);
                            return _.__actions__.push({
                                func: Yo,
                                args: [f],
                                thisArg: it
                            }),
                            new r(_, p)
                        }
                        return v && g ? t.apply(this, u) : (_ = this.thru(f), v ? a ? _.value()[0] : _.value() : _)
                    })
                }),
                s(["pop", "push", "shift", "sort", "splice", "unshift"],
                function(t) {
                    var e = sh[t],
                    i = /^(?:push|sort|unshift)$/.test(t) ? "tap": "thru",
                    r = /^(?:pop|shift)$/.test(t);
                    n.prototype[t] = function() {
                        var t = arguments;
                        if (r && !this.__chain__) {
                            var n = this.value();
                            return e.apply(pf(n) ? n: [], t)
                        }
                        return this[i](function(n) {
                            return e.apply(pf(n) ? n: [], t)
                        })
                    }
                }),
                li(y.prototype,
                function(t, e) {
                    var i = n[e];
                    if (i) {
                        var r = i.name + ""; (tl[r] || (tl[r] = [])).push({
                            name: e,
                            func: i
                        })
                    }
                }),
                tl[Yr(it, vt).name] = [{
                    name: "wrapper",
                    func: it
                }],
                y.prototype.clone = A,
                y.prototype.reverse = J,
                y.prototype.value = tt,
                n.prototype.at = Wl,
                n.prototype.chain = Zo,
                n.prototype.commit = Jo,
                n.prototype.next = Qo,
                n.prototype.plant = $o,
                n.prototype.reverse = ts,
                n.prototype.toJSON = n.prototype.valueOf = n.prototype.value = es,
                n.prototype.first = n.prototype.head,
                Ch && (n.prototype[Ch] = Ko),
                n
            } ();
            Rn._ = qn,
            (r = function() {
                return qn
            }.call(e, n, e, i)) !== it && (i.exports = r)
        }).call(this)
    }).call(e, n("DuR2"), n("3IRH")(t))
},
MKtO: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_MORPHTARGETS\\n\\t#ifndef USE_MORPHNORMALS\\n\\tuniform float morphTargetInfluences[ 8 ];\\n\\t#else\\n\\tuniform float morphTargetInfluences[ 4 ];\\n\\t#endif\\n#endif"
},
MfHs: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_MAP\\n\\tuniform vec4 offsetRepeat;\\n\\tuniform sampler2D map;\\n#endif\\n"
},
UniformsUtils: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return UniformsUtils
    });
    var UniformsUtils = {
        merge: function(t) {
            for (var e = {},
            n = 0; n < t.length; n++) {
                var i = this.clone(t[n]);
                for (var r in i) e[r] = i[r]
            }
            return e
        },
        clone: function(t) {
            var e = {};
            for (var n in t) {
                e[n] = {};
                for (var i in t[n]) {
                    var r = t[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                }
            }
            return e
        }
    }
},
Mnzq: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return o
    });
    var i = n("/E3y"),
    r = n("ytBM"),
    a = n("pi2b"),
    o = function() {
        function t() {
            this.viewers = new Map,
            this.logVersion()
        }
        return t.getInstance = function() {
            return t.instance || (t.instance = new t)
        },
        Object.defineProperty(t.prototype, "Events", {
            get: function() {
                return r.a.getInstance()
            },
            enumerable: true,
            configurable: true
        }),
        t.prototype.createViewer = function(t) {
            var e = new a.a;
            return this.viewers.set(t, e),
            e
        },
        t.prototype.removeViewer = function(t) {
            var e = this.viewers.get(t);
            undefined !== e && (this.viewers.delete(t), e.uninitialize())
        },
        t.prototype.getViewer = function(t) {
            return this.viewers.get(t)
        },
        t.prototype.logVersion = function() {
            console.log("\\n%c%s%c%s%c%s%c%s%c%s%c%s%c%s\\n", "background-color: #369;font-size: 12px;", " ", "background-color: #58a;font-size: 12px;", " ", "background-color: #7ac;font-size: 12px;", " ", "background-color: #9ce;color: #fff; font-weight: lighter;font-size: 12px;", " " + i.t + " ", "background-color: #7ac;font-size: 12px;", " ", "background-color: #58a;font-size: 12px;", " ", "background-color: #369;font-size: 12px;", " ")
        },
        t
    } ()
},
PopChunks: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return o
    });
    var i = n("PopModelData"),
    r = n("PopChunksContent"),
    a = n("PopChunksHeader"),
    o = function() {
        function t() {}
        return t.prototype.readFromStream = function(t) {
            this.header = new PopChunksHeader(),
            this.header.readFromStream(t);
            var e = this.header.chunkDataLength,
            n = t.readBytes(e),
            o = n.length;
            if (o < e) throw new Error("not enough data! we need " + e + " bytes, but only read " + o + " bytes");
            var s = this.decompress(n, this.header.compressType);
            this.content = new PopChunksContent(),
            this.content.readFromStream(new PopModelData(s))
        },
        t.prototype.decompress = function(t, e) {
            return t
        },
        t
    } ()
},
MtLI: function(t, e, n) {
    "use strict";
    e.a = "#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n\\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\\tcolor *= toneMappingExposure;\\n\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n"
},
"N+Ao": function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return o
    });
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = n("i9Nn"),
    a = n("k1O5"),
    o = {
        defines: {
            NORMAL_BIAS: .012,
            HIGH_QUALITY: 1
        },
        uniforms: {
            indexNormalMap: {
                value: null
            },
            texelSize: {
                value: new i.I(1, 1)
            }
        },
        vertexShader: a.a,
        fragmentShader: r.a
    }
},
N570: function(t, e, n) {
    "use strict";

    function i(t) {
        this.manager = undefined !== t ? t: s.a
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("RBSo"),
    a = n("XJ5Z"),
    o = n("vh+C"),
    s = n("OJZr");
    Object.assign(i.prototype, {
        load: function(t, e, n, i) {
            var s = new a.a(this.manager);
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path);
            var u = new o.a;
            return u.image = s.load(t,
            function() {
                var n = t.search(/\\.(jpg|jpeg)$/) > 0 || 0 === t.search(/^data\\:image\\/jpeg / );
                u.format = n ? r._30: r._22,
                u.needsUpdate = true,
                undefined !== e && e(u)
            },
            n, i),
            u
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    })
},
"PointLight": function(t, e, n) {
    "use strict";

    function i(t, e, n, i) {
        r.a.call(this, t, e),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / (4 * Math.PI)
            }
        }),
        this.distance = undefined !== n ? n: 0,
        this.decay = undefined !== i ? i: 1,
        this.shadow = new o.a(new a.a(90, 1, .5, 500))
    }
    var r = n("Light"),
    a = n("PerspectiveCamera"),
    o = n("6f23");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isPointLight: true,
        copy: function(t) {
            return r.a.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.decay = t.decay,
            this.shadow = t.shadow.clone(),
            this
        }
    })
},
"Vector2": function(t, e, n) {
    "use strict";

    function Vector2(t, e) {
        this.x = t || 0,
        this.y = e || 0
    }
    n.d(e, "a",
    function() {
        return Vector2
    }),
    Object.defineProperties(i.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(t) {
                this.x = t
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(t) {
                this.y = t
            }
        }
    }),
    Object.assign(i.prototype, {
        isVector2: true,
        set: function(t, e) {
            return this.x = t,
            this.y = e,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this
        },
        add: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this
        },
        sub: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this
        },
        multiply: function(t) {
            return this.x *= t.x,
            this.y *= t.y,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this
        },
        clampScalar: function() {
            var t = new i,
            e = new i;
            return function(n, i) {
                return t.set(n, n),
                e.set(i, i),
                this.clamp(t, e)
            }
        } (),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var t = Math.atan2(this.y, this.x);
            return t < 0 && (t += 2 * Math.PI),
            t
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
            n = this.y - t.y;
            return e * e + n * n
        },
        distanceToManhattan: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y
        },
        fromArray: function(t, e) {
            return undefined === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this
        },
        toArray: function(t, e) {
            return undefined === t && (t = []),
            undefined === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return undefined !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this
        },
        rotateAround: function(t, e) {
            var n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            a = this.y - t.y;
            return this.x = r * n - a * i + t.x,
            this.y = r * i + a * n + t.y,
            this
        }
    })
},
"NfZ/": function(t, e, n) {
    "use strict";
    e.a = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvarying vec2 vUv;\\n#endif"
},
NsZI: function(t, e, n) {
    "use strict";
    e.a = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n"
},
Nxbn: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_METALNESSMAP\\n\\tuniform sampler2D metalnessMap;\\n#endif"
},
MeshNormalMaterial: function(t, e, n) {
    "use strict";

    function i(t) {
        r.a.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalScale = new Vector2(1, 1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = false,
        this.wireframeLinewidth = 1,
        this.fog = false,
        this.lights = false,
        this.skinning = false,
        this.morphTargets = false,
        this.morphNormals = false,
        this.setValues(t)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Material"),
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isMeshNormalMaterial = true,
    i.prototype.copy = function(t) {
        return r.a.prototype.copy.call(this, t),
        this.bumpMap = t.bumpMap,
        this.bumpScale = t.bumpScale,
        this.normalMap = t.normalMap,
        this.normalScale.copy(t.normalScale),
        this.displacementMap = t.displacementMap,
        this.displacementScale = t.displacementScale,
        this.displacementBias = t.displacementBias,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
},
O0yN: function(t, e, n) {
    "use strict";

    function i(t) {
        function e(e, n) {
            var i = e.array,
            r = e.dynamic ? t.DYNAMIC_DRAW: t.STATIC_DRAW,
            a = t.createBuffer();
            t.bindBuffer(n, a),
            t.bufferData(n, i, r),
            e.onUploadCallback();
            var o = t.FLOAT;
            return i instanceof Float32Array ? o = t.FLOAT: i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? o = t.UNSIGNED_SHORT: i instanceof Int16Array ? o = t.SHORT: i instanceof Uint32Array ? o = t.UNSIGNED_INT: i instanceof Int32Array ? o = t.INT: i instanceof Int8Array ? o = t.BYTE: i instanceof Uint8Array && (o = t.UNSIGNED_BYTE),
            {
                buffer: a,
                type: o,
                bytesPerElement: i.BYTES_PER_ELEMENT,
                version: e.version
            }
        }

        function n(e, n, i) {
            var r = n.array,
            a = n.updateRange;
            t.bindBuffer(i, e),
            false === n.dynamic ? t.bufferData(i, r, t.STATIC_DRAW) : -1 === a.count ? t.bufferSubData(i, 0, r) : 0 === a.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(i, a.offset * r.BYTES_PER_ELEMENT, r.subarray(a.offset, a.offset + a.count)), a.count = -1)
        }

        function i(t) {
            return t.isInterleavedBufferAttribute && (t = t.data),
            o[t.uuid]
        }

        function r(e) {
            e.isInterleavedBufferAttribute && (e = e.data);
            var n = o[e.uuid];
            n && (t.deleteBuffer(n.buffer), delete o[e.uuid])
        }

        function a(t, i) {
            t.isInterleavedBufferAttribute && (t = t.data);
            var r = o[t.uuid];
            undefined === r ? o[t.uuid] = e(t, i) : r.version < t.version && (n(r.buffer, t, i), r.version = t.version)
        }
        var o = {};
        return {
            get: i,
            remove: r,
            update: a
        }
    }
    n.d(e, "a",
    function() {
        return i
    })
},
OCJR: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return r
    });
    var i = n("w6dw"),
    r = function() {
        function t(t) {
            this.viewer = t,
            this.picker = new i.a
        }
        return t.prototype.pick = function(t, e, n, i) {
            var r = this.viewer.getEngine().model;
            return null === r ? [] : (this.picker.setRenderModel(r), this.picker.pick(t, e, n, i))
        },
        t
    } ()
},
IcosahedronGeometry||IcosahedronBufferGeometry: function(t, e, n) {
    "use strict";

    function i(t, e) {
        a.a.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new r(t, e)),
        this.mergeVertices()
    }

    function r(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
        i = [ - 1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
        r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        o.a.call(this, i, r, t, e),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    var a = n("Geometry"),
    o = n("PolyhedronGeometry||PolyhedronBufferGeometry");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
OFyc: function(t, e, n) {
    "use strict";
    e.a = "#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifndef STANDARD\\n\\tuniform float clearCoat;\\n\\tuniform float clearCoatRoughness;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <roughnessmap_fragment>\\n\\t#include <metalnessmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_physical_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n"
},
OJZr: function(t, e, n) {
    "use strict";

    function i(t, e, n) {
        var i = this,
        r = false,
        a = 0,
        o = 0;
        this.onStart = undefined,
        this.onLoad = t,
        this.onProgress = e,
        this.onError = n,
        this.itemStart = function(t) {
            o++,
            false === r && undefined !== i.onStart && i.onStart(t, a, o),
            r = true
        },
        this.itemEnd = function(t) {
            a++,
            undefined !== i.onProgress && i.onProgress(t, a, o),
            a === o && (r = false, undefined !== i.onLoad && i.onLoad())
        },
        this.itemError = function(t) {
            undefined !== i.onError && i.onError(t)
        }
    }
    n.d(e, "a",
    function() {
        return r
    });
    var r = new i
},
Oc0e: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return i
    });
    var i = function() {
        function t(t, e) {
            this.renderer = t,
            this.config = e,
            this.active = true
        }
        return t.prototype.initialize = function() {},
        t.prototype.dispose = function() {},
        t
    } ()
},
Ok5I: function(t, e, n) {
    "use strict";

    function i(t, e, n, i, o, s, u, c, h, l) {
        if ((l = undefined !== l ? l: a.s) !== a.s && l !== a.t) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        undefined === n && l === a.s && (n = a._59),
        undefined === n && l === a.t && (n = a._54),
        r.a.call(this, null, i, o, s, u, c, l, n, h),
        this.image = {
            width: t,
            height: e
        },
        this.magFilter = undefined !== u ? u: a._5,
        this.minFilter = undefined !== c ? c: a._5,
        this.flipY = false,
        this.generateMipmaps = false
    }
    var r = n("vh+C"),
    a = n("RBSo");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isDepthTexture = true
},
Ov69: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return c
    });
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = n("CustomerDefine3"),
    a = n("TJTO"),
    o = n("gRRI"),
    s = n("CustomerDefine2"),
    u = new i.c,
    c = function() {
        function t(e) {
            var n = this;
            this.engine = null,
            this.model = null,
            this.fragIterator = 0,
            this.batch = null,
            this.frags = null,
            this.numFragments = 0,
            this.screenArea = null,
            this.singleBatch = false,
            this.sortFragsByAreaSizeAndRenderOrder = function(t, e) {
                var i = n.model.getObject(t).renderOrder,
                r = n.model.getObject(e).renderOrder;
                return i !== r ? i - r: n.screenArea[e] - n.screenArea[t]
            },
            this.engine = e,
            this.model = this.engine.model,
            this.batch = new s.a(this.engine, t.BATCH_SIZE)
        }
        return t.prototype.reset = function() {
            this.fragIterator = 0,
            this.batch.reset(t.BATCH_SIZE),
            this.numFragments = 0
        },
        t.prototype.updateRenderingFragments = function() {
            var t = this.model.fragments.numFragments; (null === this.frags || this.frags.length < t) && (this.frags = new Int32Array(t), this.screenArea = new Float32Array(t));
            for (var e = 0; e < t; e++) if (1 !== this.model.fragments.tombs[e] && this.engine.testFragmentVisibility(e)) {
                var n = !this.singleBatch || this.singleBatch && this.engine.detailCullingEnabled;
                n && (r.b.setToThree(this.model.fragments.boxes, e, u), this.screenArea[e] = Object(a.a)(u, this.model.camera.position, this.model.projScreenMatrix), this.engine.shouldSkipByDetailCulling(this.screenArea[e])) || (this.frags[this.numFragments++] = e)
            }
            this.singleBatch || Object(o.a)(this.frags, this.sortFragsByAreaSizeAndRenderOrder, 0, this.numFragments)
        },
        t.prototype.nextBatch = function() {
            0 === this.fragIterator && this.updateRenderingFragments();
            var e = this.numFragments,
            n = this.singleBatch ? e: t.BATCH_SIZE;
            for (this.batch.reset(n), this.batch.firstBatch = 0 === this.fragIterator; this.fragIterator < e && this.batch.size < n; this.fragIterator++) this.batch.frags[this.batch.size++] = this.frags[this.fragIterator];
            var i = this.batch;
            return i.lastBatch = !!this.singleBatch || this.fragIterator >= e,
            i.updateRenderList(),
            i
        },
        t.BATCH_SIZE = 500,
        t
    } ()
},
"OzF/": function(t, e, n) {
    "use strict";

    function i() {
        function t(t, a, o, s) {
            e = t,
            n = o,
            i = -3 * t + 3 * a - 2 * o - s,
            r = 2 * t - 2 * a + o + s
        }
        var e = 0,
        n = 0,
        i = 0,
        r = 0;
        return {
            initCatmullRom: function(e, n, i, r, a) {
                t(n, i, a * (i - e), a * (r - n))
            },
            initNonuniformCatmullRom: function(e, n, i, r, a, o, s) {
                var u = (n - e) / a - (i - e) / (a + o) + (i - n) / o,
                c = (i - n) / o - (r - n) / (o + s) + (r - i) / s;
                u *= o,
                c *= o,
                t(n, i, u, c)
            },
            calc: function(t) {
                var a = t * t;
                return e + n * t + i * a + r * (a * t)
            }
        }
    }

    function r(t) {
        o.a.call(this),
        t.length < 2 && console.warn("THREE.CatmullRomCurve3: Points array needs at least two entries."),
        this.points = t || [],
        this.closed = false
    }
    var a = n("Vector3"),
    o = n("Lk8y"),
    s = new a.a,
    u = new i,
    c = new i,
    h = new i;
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r,
    r.prototype.getPoint = function(t) {
        var e = this.points,
        n = e.length,
        i = (n - (this.closed ? 0 : 1)) * t,
        r = Math.floor(i),
        o = i - r;
        this.closed ? r += r > 0 ? 0 : (Math.floor(Math.abs(r) / e.length) + 1) * e.length: 0 === o && r === n - 1 && (r = n - 2, o = 1);
        var l, f, p, d;
        if (this.closed || r > 0 ? l = e[(r - 1) % n] : (s.subVectors(e[0], e[1]).add(e[0]), l = s), f = e[r % n], p = e[(r + 1) % n], this.closed || r + 2 < n ? d = e[(r + 2) % n] : (s.subVectors(e[n - 1], e[n - 2]).add(e[n - 1]), d = s), undefined === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var m = "chordal" === this.type ? .5 : .25,
            v = Math.pow(l.distanceToSquared(f), m),
            g = Math.pow(f.distanceToSquared(p), m),
            y = Math.pow(p.distanceToSquared(d), m);
            g < 1e-4 && (g = 1),
            v < 1e-4 && (v = g),
            y < 1e-4 && (y = g),
            u.initNonuniformCatmullRom(l.x, f.x, p.x, d.x, v, g, y),
            c.initNonuniformCatmullRom(l.y, f.y, p.y, d.y, v, g, y),
            h.initNonuniformCatmullRom(l.z, f.z, p.z, d.z, v, g, y)
        } else if ("catmullrom" === this.type) {
            var _ = undefined !== this.tension ? this.tension: .5;
            u.initCatmullRom(l.x, f.x, p.x, d.x, _),
            c.initCatmullRom(l.y, f.y, p.y, d.y, _),
            h.initCatmullRom(l.z, f.z, p.z, d.z, _)
        }
        return new a.a(u.calc(o), c.calc(o), h.calc(o))
    }
},
P0pb: function(t, e, n) {
    "use strict";

    function i(t, e) {
        return "__" + t + "__" + e + "__"
    }

    function r(t) {
        return t.x * t.y
    }
    n.d(e, "a",
    function() {
        return h
    });
    var a = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    o = n("4Ww7"),
    s = n("LLkA"),
    u = this && this.__assign || Object.assign ||
    function(t) {
        for (var e, n = 1,
        i = arguments.length; n < i; n++) {
            e = arguments[n];
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r])
        }
        return t
    },
    c = new a.J,
    h = function() {
        function t() {
            this.depthInfoMap = new Map,
            this.boxDepthInfoMap = new Map
        }
        return t.prototype.setWebGLRenderer = function(t) {
            this.generator = new s.a(t)
        },
        t.prototype.generateDepthInfoWithType = function(t, e, n, r) {
            var a = i(t, n);
            this.depthInfoMap.set(a, this.generator.generate(e, n, r))
        },
        t.prototype.generateBoxDepthInfoWithType = function(t, e, n) {
            var r = i(t, e);
            this.boxDepthInfoMap.set(r, Object(s.b)(e, n))
        },
        t.prototype.generateDepthInfo = function(t, e, n, i) {
            undefined === n && (n = true),
            this.generator && i ? n ? (this.generateDepthInfoWithType(t, i, o.a.TOP, e), this.generateDepthInfoWithType(t, i, o.a.BOTTOM, e)) : (this.generateDepthInfoWithType(t, i, o.a.FRONT, e), this.generateDepthInfoWithType(t, i, o.a.BACK, e)) : n ? (this.generateBoxDepthInfoWithType(t, o.a.TOP, e), this.generateBoxDepthInfoWithType(t, o.a.BOTTOM, e)) : (this.generateBoxDepthInfoWithType(t, o.a.FRONT, e), this.generateBoxDepthInfoWithType(t, o.a.BACK, e))
        },
        t.prototype.getDepthInfo = function(t, e) {
            var n = this.depthInfoMap.get(i(t, e));
            return n || (console.error("Stacking: cannot find depth info for id: '" + t + "', type: '" + e + "'"), this.boxDepthInfoMap.get(i(t, e)))
        },
        t.prototype.stack = function(t, e, n) {
            undefined === n && (n = true);
            var i = n ? o.a.BOTTOM: o.a.BACK,
            r = n ? o.a.TOP: o.a.FRONT,
            a = this.getDepthInfo(t.meshId, i),
            s = a ? u({},
            t, {
                depthInfo: a
            }) : undefined,
            c = this.getDepthInfo(e.meshId, r),
            h = c ? u({},
            e, {
                depthInfo: c
            }) : undefined;
            if (s && h) return this.compute(s, h)
        },
        t.prototype.compute = function(t, e) {
            var n = new a.p;
            n.getInverse(e.worldMatrix),
            n.multiplyMatrices(n, t.worldMatrix);
            var i = {
                depthAbove: 1 / 0,
                depthBelow: 1 / 0,
                targetObjectId: e.objectId
            },
            o = r(t.depthInfo.boxSize) > r(e.depthInfo.boxSize),
            s = o ? e.depthInfo: t.depthInfo,
            u = o ? t.depthInfo: e.depthInfo,
            h = 1 / 0;
            return s.forEachDepth(function(t, e, r, a) {
                var s = c.set(e, r, a).applyMatrix4(n),
                l = u.getDepth(s.x, s.y, s.z),
                f = t + l;
                f < h && (h = f, i.depthAbove = o ? l: t, i.depthBelow = o ? t: l)
            }),
            i
        },
        t
    } ();
    new h
},
PopChunksHeader: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return i
    });
    var i = function() {
        function t() {}
        return t.prototype.readFromStream = function(t) {
            this.currentLevel = t.readSwappedInt(),
            this.chunkDataLength = t.readSwappedInt(),
            this.objIndex = t.readSwappedShort(),
            this.compressType = t.readByte()
        },
        t
    } ()
},
PFnl: function(t, e, n) {
    "use strict";

    function i(t, e, n, i, a, o, s, u, c) {
        r.a.call(this, t, e, n, i, a, o, s, u, c),
        this.needsUpdate = true
    }
    var r = n("vh+C");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
OctahedronGeometry||OctahedronBufferGeometry: function(t, e, n) {
    "use strict";

    function i(t, e) {
        a.a.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new r(t, e)),
        this.mergeVertices()
    }

    function r(t, e) {
        var n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
        i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        o.a.call(this, n, i, t, e),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    n.d(e, "a",
    function() {
        return r
    });
    var a = n("Geometry"),
    o = n("PolyhedronGeometry||PolyhedronBufferGeometry");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
PO9Y: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return i
    });
    var i = {
        isPerspectiveCamera: function(t) {
            return t.isPerspectiveCamera
        },
        isOrthographicCamera: function(t) {
            return t.isOrthographicCamera
        },
        isArrayCamera: function(t) {
            return t.isArrayCamera
        }
    }
},
POlw: function(t, e, n) {
    "use strict";

    function i(t) {
        for (var e = {},
        n = 0,
        i = Object.keys(t); n < i.length; n++) {
            var r = i[n];
            e[r] = {};
            for (var a = 0,
            o = Object.keys(t[r]); a < o.length; a++) {
                var s = o[a],
                u = t[r][s];
                u && (u.isColor || u.isMatrix3 || u.isMatrix4 || u.isVector2 || u.isVector3 || u.isVector4) ? e[r][s] = u.clone() : Array.isArray(u) ? e[r][s] = u.slice() : e[r][s] = u
            }
        }
        return e
    }

    function r() {
        return function(t) {
            return function(e, n) {
                var i = t || n,
                r = Object.getOwnPropertyDescriptor(e, n);
                Object.defineProperty(e, n, {
                    configurable: true,
                    enumerable: true,
                    get: function() {
                        return this.uniforms[i].value
                    },
                    set: function(t) {
                        r && r.set && r.set.call(this, t),
                        this.uniforms[i].value = t
                    }
                })
            }
        }
    }

    function a() {
        return function(t, e) {
            var n = e ||
            function(t) {
                return !! t
            };
            return function(e, i) {
                var r = "_" + i + "_" + Date.now(),
                a = Object.getOwnPropertyDescriptor(e, i),
                o = a && a.get ||
                function() {
                    return this[r]
                },
                s = function(e) {
                    a && a.set && a.set.call(this, e),
                    this[r] !== e && (this[r] = e, n(e) ? this.defines[t] = "": delete this.defines[t])
                };
                Object.defineProperty(e, i, {
                    configurable: true,
                    enumerable: true,
                    get: o,
                    set: s
                })
            }
        }
    }
    n.d(e, "a",
    function() {
        return o
    });
    var o = {
        cloneUniforms: i,
        getDefineToggle: a,
        getUniformMapping: r
    }
},
PUN1: function(t, e, n) {
    "use strict";

    function i(t, e, n, i) {
        t = t || 10,
        e = e || 10,
        n = new c.a(undefined !== n ? n: 4473924),
        i = new c.a(undefined !== i ? i: 8947848);
        for (var h = e / 2,
        l = t / e,
        f = t / 2,
        p = [], d = [], m = 0, v = 0, g = -f; m <= e; m++, g += l) {
            p.push( - f, 0, g, f, 0, g),
            p.push(g, 0, -f, g, 0, f);
            var y = m === h ? n: i;
            y.toArray(d, v),
            v += 3,
            y.toArray(d, v),
            v += 3,
            y.toArray(d, v),
            v += 3,
            y.toArray(d, v),
            v += 3
        }
        var _ = new u.a;
        _.addAttribute("position", new s.b(p, 3)),
        _.addAttribute("color", new s.b(d, 3));
        var x = new o.a({
            vertexColors: a._60
        });
        r.a.call(this, _, x)
    }
    var r = n("LineSegments"),
    a = n("RBSo"),
    o = n("LineBasicMaterial"),
    s = n("BufferAttribute"),
    u = n("BufferGeometry"),
    c = n("Color");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
PV76: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_BUMPMAP\\n\\tuniform sampler2D bumpMap;\\n\\tuniform float bumpScale;\\n\\tvec2 dHdxy_fwd() {\\n\\t\\tvec2 dSTdx = dFdx( vUv );\\n\\t\\tvec2 dSTdy = dFdy( vUv );\\n\\t\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\\t\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\\t\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\t\\treturn vec2( dBx, dBy );\\n\\t}\\n\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\t\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\\t\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\\t\\tvec3 vN = surf_norm;\\n\\t\\tvec3 R1 = cross( vSigmaY, vN );\\n\\t\\tvec3 R2 = cross( vN, vSigmaX );\\n\\t\\tfloat fDet = dot( vSigmaX, R1 );\\n\\t\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\\t\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\\t}\\n#endif\\n"
},
PXdy: function(t, e, n) {
    "use strict";

    function i(t, e, n, i, a, o, s, u) {
        r.a.call(this),
        this.aX = t,
        this.aY = e,
        this.xRadius = n,
        this.yRadius = i,
        this.aStartAngle = a,
        this.aEndAngle = o,
        this.aClockwise = s,
        this.aRotation = u || 0
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Lk8y"),
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isEllipseCurve = true,
    i.prototype.getPoint = function(t) {
        for (var e = 2 * Math.PI,
        n = this.aEndAngle - this.aStartAngle,
        i = Math.abs(n) < Number.EPSILON; n < 0;) n += e;
        for (; n > e;) n -= e;
        n < Number.EPSILON && (n = i ? 0 : e),
        true !== this.aClockwise || i || (n === e ? n = -e: n -= e);
        var r = this.aStartAngle + t * n,
        o = this.aX + this.xRadius * Math.cos(r),
        s = this.aY + this.yRadius * Math.sin(r);
        if (0 !== this.aRotation) {
            var u = Math.cos(this.aRotation),
            c = Math.sin(this.aRotation),
            h = o - this.aX,
            l = s - this.aY;
            o = h * u - l * c + this.aX,
            s = h * c + l * u + this.aY
        }
        return new Vector2(o, s)
    }
},
PcuP: function(t, e, n) {
    "use strict";

    function i(t, e, n) {
        function i(t) {
            var r = t.target,
            a = h[r.id];
            null !== a.index && e.remove(a.index);
            for (var o in a.attributes) e.remove(a.attributes[o]);
            r.removeEventListener("dispose", i),
            delete h[r.id];
            var s = l[r.id];
            s && (e.remove(s), delete l[r.id]),
            s = l[a.id],
            s && (e.remove(s), delete l[a.id]),
            n.geometries--
        }

        function s(t, e) {
            var r = h[e.id];
            return r || (e.addEventListener("dispose", i), e.isBufferGeometry ? r = e: e.isGeometry && (undefined === e._bufferGeometry && (e._bufferGeometry = (new a.a).setFromObject(t)), r = e._bufferGeometry), h[e.id] = r, n.geometries++, r)
        }

        function u(n) {
            var i = n.index,
            r = n.attributes;
            null !== i && e.update(i, t.ELEMENT_ARRAY_BUFFER);
            for (var a in r) e.update(r[a], t.ARRAY_BUFFER);
            var o = n.morphAttributes;
            for (var a in o) for (var s = o[a], u = 0, c = s.length; u < c; u++) e.update(s[u], t.ARRAY_BUFFER)
        }

        function c(n) {
            var i = l[n.id];
            if (i) return i;
            var a = [],
            s = n.index,
            u = n.attributes;
            if (null !== s) for (var c = s.array,
            h = 0,
            f = c.length; h < f; h += 3) {
                var p = c[h + 0],
                d = c[h + 1],
                m = c[h + 2];
                a.push(p, d, d, m, m, p)
            } else for (var c = u.position.array,
            h = 0,
            f = c.length / 3 - 1; h < f; h += 3) {
                var p = h + 0,
                d = h + 1,
                m = h + 2;
                a.push(p, d, d, m, m, p)
            }
            return i = new(Object(o.a)(a) > 65535 ? r.d: r.c)(a, 1),
            e.update(i, t.ELEMENT_ARRAY_BUFFER),
            l[n.id] = i,
            i
        }
        var h = {},
        l = {};
        return {
            get: s,
            update: u,
            getWireframeAttribute: c
        }
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("BufferAttribute"),
    a = n("BufferGeometry"),
    o = n("pAuK")
},
PpZm: function(t, e, n) {
    "use strict";
    e.a = "#define NORMAL\\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP)\\nvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\nvarying vec3 vNormal;\\n#endif\\n#include <displacementmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <uv_pars_vertex>\\nvoid main() {\\n#include <uv_vertex>\\n#include <beginnormal_vertex>\\n#include <defaultnormal_vertex>\\n#include <morphnormal_vertex>\\n#include <skinbase_vertex>\\n#include <skinnormal_vertex>\\n#ifndef FLAT_SHADED\\n    vNormal = normalize(transformedNormal);\\n#endif\\n#include <begin_vertex>\\n#include <displacementmap_vertex>\\n#include <logdepthbuf_vertex>\\n#include <morphtarget_vertex>\\n#include <project_vertex>\\n#include <skinning_vertex>\\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP)\\n    vViewPosition = -mvPosition.xyz;\\n#endif\\n}\\n"
},
Q2ls: function(t, e, n) {
    "use strict";

    function i(t) {
        return a[0] = t,
        o[0]
    }
    e.a = i;
    var r = new Int8Array(4),
    a = new Int32Array(r.buffer, 0, 1),
    o = new Float32Array(r.buffer, 0, 1)
},
Q3nw: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_COLOR\\n\\tvColor.xyz = color.xyz;\\n#endif"
},
QC0l: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_SKINNING\\n\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\\tvec4 skinned = vec4( 0.0 );\\n\\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\\n"
},
QSwz: function(t, e, n) {
    "use strict";
    e.a = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n"
},
Qlzl: function(t, e, n) {
    "use strict";
    e.a = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\\tvUv2 = uv2;\\n#endif"
},
CustomerDefine1: function(t, e, n) {
    "use strict";

    function i(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder: t.program && e.program && t.program !== e.program ? t.program.id - e.program.id: t.material.id !== e.material.id ? t.material.id - e.material.id: t.z !== e.z ? t.z - e.z: t.id - e.id
    }

    function r(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder: t.z !== e.z ? e.z - t.z: t.id - e.id
    }
    n.d(e, "a",
    function() {
        return a
    });
    var a = function() {
        function t() {
            this.isRenderList = true,
            this.scene = null,
            this.opaqueLastIndex = -1,
            this.transparentLastIndex = -1,
            this.firstBatch = true,
            this.lastBatch = true,
            this.opaque = [],
            this.transparent = [],
            this.lights = [],
            this.sprites = []
        }
        return Object.defineProperty(t.prototype, "overrideMaterial", {
            get: function() {
                return this.scene.overrideMaterial
            },
            set: function(t) {
                this.scene.overrideMaterial = t
            },
            enumerable: true,
            configurable: true
        }),
        t.prototype.init = function() {
            this.opaqueLastIndex = -1,
            this.transparentLastIndex = -1,
            this.lights.length = 0,
            this.sprites.length = 0,
            this.firstBatch = true,
            this.lastBatch = true
        },
        t.prototype.addRenderItemDone = function() {
            this.opaque.length = this.opaqueLastIndex + 1,
            this.transparent.length = this.transparentLastIndex + 1
        },
        t.prototype.sort = function() {
            this.opaque.sort(i),
            this.transparent.sort(r)
        },
        t.prototype.addRenderItem = function(t, e, n, i, r) {
            var a, o;
            n.transparent ? (a = this.transparent, o = ++this.transparentLastIndex) : (a = this.opaque, o = ++this.opaqueLastIndex);
            var s = a[o];
            s ? (s.id = t.id, s.object = t, s.geometry = e, s.material = n, s.program = n.program, s.renderOrder = t.renderOrder, s.z = i, s.group = r) : (s = {
                id: t.id,
                object: t,
                geometry: e,
                material: n,
                program: n.program,
                renderOrder: t.renderOrder,
                z: i,
                group: r
            },
            a.push(s))
        },
        t
    } ()
},
DodecahedronGeometry||DodecahedronBufferGeometry: function(t, e, n) {
    "use strict";

    function i(t, e) {
        a.a.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: t,
            detail: e
        },
        this.fromBufferGeometry(new r(t, e)),
        this.mergeVertices()
    }

    function r(t, e) {
        var n = (1 + Math.sqrt(5)) / 2,
        i = 1 / n,
        r = [ - 1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i],
        a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        o.a.call(this, r, a, t, e),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: t,
            detail: e
        }
    }
    var a = n("Geometry"),
    o = n("PolyhedronGeometry||PolyhedronBufferGeometry");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
QwP0: function(t, e, n) {
    "use strict";
    e.a = "uniform float opacity;\\nuniform sampler2D tDiffuse;\\nvarying vec2 vUv;\\nvoid main() {\\n    vec4 texel = texture2D(tDiffuse, vUv);\\n    gl_FragColor = opacity * texel;\\n}\\n"
},
"R+5/": function(t, e, n) {
    "use strict";

    function i(t, e, n, i) {
        this.parameterPositions = t,
        this._cachedIndex = 0,
        this.resultBuffer = undefined !== i ? i: new e.constructor(n),
        this.sampleValues = e,
        this.valueSize = n
    }
    n.d(e, "a",
    function() {
        return i
    }),
    Object.assign(i.prototype, {
        evaluate: function(t) {
            var e = this.parameterPositions,
            n = this._cachedIndex,
            i = e[n],
            r = e[n - 1];
            t: {
                e: {
                    var a;
                    n: {
                        i: if (! (t < i)) {
                            for (var o = n + 2;;) {
                                if (undefined === i) {
                                    if (t < r) break i;
                                    return n = e.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, t, r)
                                }
                                if (n === o) break;
                                if (r = i, i = e[++n], t < i) break e
                            }
                            a = e.length;
                            break n
                        } {
                            if (t >= r) break t;
                            var s = e[1];
                            t < s && (n = 2, r = s);
                            for (var o = n - 2;;) {
                                if (undefined === r) return this._cachedIndex = 0,
                                this.beforeStart_(0, t, i);
                                if (n === o) break;
                                if (i = r, r = e[--n - 1], t >= r) break e
                            }
                            a = n,
                            n = 0
                        }
                    }
                    for (; n < a;) {
                        var u = n + a >>> 1;
                        t < e[u] ? a = u: n = u + 1
                    }
                    if (i = e[n], undefined === (r = e[n - 1])) return this._cachedIndex = 0,
                    this.beforeStart_(0, t, i);
                    if (undefined === i) return n = e.length,
                    this._cachedIndex = n,
                    this.afterEnd_(n - 1, r, t)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, r, i)
            }
            return this.interpolate_(n, r, t, i)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(t) {
            for (var e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i,
            a = 0; a !== i; ++a) e[a] = n[r + a];
            return e
        },
        interpolate_: function(t, e, n, i) {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function(t, e, n) {}
    }),
    Object.assign(i.prototype, {
        beforeStart_: i.prototype.copySampleValue_,
        afterEnd_: i.prototype.copySampleValue_
    })
},
"R+Hm": function(t, e, n) {
    "use strict";
    e.a = "#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <normal_flip>\\n\\t#include <normal_fragment>\\n\\t#include <emissivemap_fragment>\\n\\t#include <lights_phong_fragment>\\n\\t#include <lights_template>\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\\t#include <envmap_fragment>\\n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n"
},
"R6/u": function(t, e, n) {
    "use strict";

    function i(t, e) {
        this.light = t,
        this.light.updateMatrixWorld();
        var n = new o.a(e, 4, 2),
        i = new a.a({
            wireframe: true,
            fog: false
        });
        i.color.copy(this.light.color),
        r.a.call(this, n, i),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = false
    }
    var r = n("Mesh"),
    a = n("MeshBasicMaterial"),
    o = n("SphereGeometry||SphereBufferGeometry");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    },
    i.prototype.update = function() {
        this.material.color.copy(this.light.color)
    }
},
RBSo: function(t, e, n) {
    "use strict";
    n.d(e, "q",
    function() {
        return i
    }),
    n.d(e, "o",
    function() {
        return r
    }),
    n.d(e, "p",
    function() {
        return a
    }),
    n.d(e, "D",
    function() {
        return o
    }),
    n.d(e, "_19",
    function() {
        return s
    }),
    n.d(e, "_20",
    function() {
        return u
    }),
    n.d(e, "E",
    function() {
        return c
    }),
    n.d(e, "f",
    function() {
        return h
    }),
    n.d(e, "u",
    function() {
        return l
    }),
    n.d(e, "B",
    function() {
        return f
    }),
    n.d(e, "_41",
    function() {
        return p
    }),
    n.d(e, "_10",
    function() {
        return d
    }),
    n.d(e, "A",
    function() {
        return m
    }),
    n.d(e, "_60",
    function() {
        return v
    }),
    n.d(e, "_9",
    function() {
        return g
    }),
    n.d(e, "_12",
    function() {
        return y
    }),
    n.d(e, "c",
    function() {
        return _
    }),
    n.d(e, "_47",
    function() {
        return x
    }),
    n.d(e, "_3",
    function() {
        return b
    }),
    n.d(e, "r",
    function() {
        return w
    }),
    n.d(e, "a",
    function() {
        return M
    }),
    n.d(e, "_46",
    function() {
        return S
    }),
    n.d(e, "_39",
    function() {
        return E
    }),
    n.d(e, "_0",
    function() {
        return T
    }),
    n.d(e, "Z",
    function() {
        return A
    }),
    n.d(e, "_63",
    function() {
        return C
    }),
    n.d(e, "_14",
    function() {
        return P
    }),
    n.d(e, "_45",
    function() {
        return L
    }),
    n.d(e, "_18",
    function() {
        return R
    }),
    n.d(e, "_43",
    function() {
        return I
    }),
    n.d(e, "_17",
    function() {
        return O
    }),
    n.d(e, "v",
    function() {
        return N
    }),
    n.d(e, "_15",
    function() {
        return D
    }),
    n.d(e, "w",
    function() {
        return U
    }),
    n.d(e, "_16",
    function() {
        return B
    }),
    n.d(e, "_44",
    function() {
        return z
    }),
    n.d(e, "_8",
    function() {
        return F
    }),
    n.d(e, "e",
    function() {
        return j
    }),
    n.d(e, "N",
    function() {
        return k
    }),
    n.d(e, "O",
    function() {
        return V
    }),
    n.d(e, "x",
    function() {
        return G
    }),
    n.d(e, "H",
    function() {
        return H
    }),
    n.d(e, "G",
    function() {
        return W
    }),
    n.d(e, "_13",
    function() {
        return X
    }),
    n.d(e, "_4",
    function() {
        return q
    }),
    n.d(e, "_2",
    function() {
        return Y
    }),
    n.d(e, "b",
    function() {
        return Z
    }),
    n.d(e, "_11",
    function() {
        return J
    }),
    n.d(e, "T",
    function() {
        return Q
    }),
    n.d(e, "_37",
    function() {
        return K
    }),
    n.d(e, "_52",
    function() {
        return $
    }),
    n.d(e, "i",
    function() {
        return tt
    }),
    n.d(e, "_51",
    function() {
        return et
    }),
    n.d(e, "k",
    function() {
        return nt
    }),
    n.d(e, "l",
    function() {
        return it
    }),
    n.d(e, "y",
    function() {
        return rt
    }),
    n.d(e, "z",
    function() {
        return at
    }),
    n.d(e, "_42",
    function() {
        return ot
    }),
    n.d(e, "m",
    function() {
        return st
    }),
    n.d(e, "n",
    function() {
        return ut
    }),
    n.d(e, "_38",
    function() {
        return ct
    }),
    n.d(e, "j",
    function() {
        return ht
    }),
    n.d(e, "_1",
    function() {
        return lt
    }),
    n.d(e, "_5",
    function() {
        return ft
    }),
    n.d(e, "_7",
    function() {
        return pt
    }),
    n.d(e, "_6",
    function() {
        return dt
    }),
    n.d(e, "Q",
    function() {
        return mt
    }),
    n.d(e, "S",
    function() {
        return vt
    }),
    n.d(e, "R",
    function() {
        return gt
    }),
    n.d(e, "_53",
    function() {
        return yt
    }),
    n.d(e, "h",
    function() {
        return _t
    }),
    n.d(e, "_40",
    function() {
        return xt
    }),
    n.d(e, "_59",
    function() {
        return bt
    }),
    n.d(e, "J",
    function() {
        return wt
    }),
    n.d(e, "_55",
    function() {
        return Mt
    }),
    n.d(e, "C",
    function() {
        return St
    }),
    n.d(e, "I",
    function() {
        return Et
    }),
    n.d(e, "_56",
    function() {
        return Tt
    }),
    n.d(e, "_57",
    function() {
        return At
    }),
    n.d(e, "_58",
    function() {
        return Ct
    }),
    n.d(e, "_54",
    function() {
        return Pt
    }),
    n.d(e, "d",
    function() {
        return Lt
    }),
    n.d(e, "_30",
    function() {
        return Rt
    }),
    n.d(e, "_22",
    function() {
        return It
    }),
    n.d(e, "Y",
    function() {
        return Ot
    }),
    n.d(e, "X",
    function() {
        return Nt
    }),
    n.d(e, "s",
    function() {
        return Dt
    }),
    n.d(e, "t",
    function() {
        return Ut
    }),
    n.d(e, "_36",
    function() {
        return Bt
    }),
    n.d(e, "_25",
    function() {
        return zt
    }),
    n.d(e, "_26",
    function() {
        return Ft
    }),
    n.d(e, "_27",
    function() {
        return jt
    }),
    n.d(e, "_35",
    function() {
        return kt
    }),
    n.d(e, "_34",
    function() {
        return Vt
    }),
    n.d(e, "_24",
    function() {
        return Gt
    }),
    n.d(e, "_23",
    function() {
        return Ht
    }),
    n.d(e, "_33",
    function() {
        return Wt
    }),
    n.d(e, "U",
    function() {
        return Xt
    }),
    n.d(e, "W",
    function() {
        return qt
    }),
    n.d(e, "V",
    function() {
        return Yt
    }),
    n.d(e, "K",
    function() {
        return Zt
    }),
    n.d(e, "L",
    function() {
        return Jt
    }),
    n.d(e, "M",
    function() {
        return Qt
    }),
    n.d(e, "_62",
    function() {
        return Kt
    }),
    n.d(e, "_64",
    function() {
        return $t
    }),
    n.d(e, "_61",
    function() {
        return te
    }),
    n.d(e, "_50",
    function() {
        return ee
    }),
    n.d(e, "_49",
    function() {
        return ne
    }),
    n.d(e, "_48",
    function() {
        return ie
    }),
    n.d(e, "P",
    function() {
        return re
    }),
    n.d(e, "_65",
    function() {
        return ae
    }),
    n.d(e, "F",
    function() {
        return oe
    }),
    n.d(e, "_29",
    function() {
        return se
    }),
    n.d(e, "_32",
    function() {
        return ue
    }),
    n.d(e, "_31",
    function() {
        return ce
    }),
    n.d(e, "_28",
    function() {
        return he
    }),
    n.d(e, "g",
    function() {
        return le
    }),
    n.d(e, "_21",
    function() {
        return fe
    });
    var i = 0,
    r = 1,
    a = 2,
    o = 0,
    s = 1,
    u = 2,
    c = 0,
    h = 1,
    l = 2,
    f = 1,
    p = 2,
    d = 0,
    m = 1,
    v = 2,
    g = 0,
    y = 1,
    _ = 2,
    x = 3,
    b = 4,
    w = 5,
    M = 100,
    S = 101,
    E = 102,
    T = 103,
    A = 104,
    C = 200,
    P = 201,
    L = 202,
    R = 203,
    I = 204,
    O = 205,
    N = 206,
    D = 207,
    U = 208,
    B = 209,
    z = 210,
    F = 0,
    j = 1,
    k = 2,
    V = 3,
    G = 4,
    H = 5,
    W = 6,
    X = 7,
    q = 0,
    Y = 1,
    Z = 2,
    J = 0,
    Q = 1,
    K = 2,
    $ = 3,
    tt = 4,
    et = 300,
    nt = 301,
    it = 302,
    rt = 303,
    at = 304,
    ot = 305,
    st = 306,
    ut = 307,
    ct = 1e3,
    ht = 1001,
    lt = 1002,
    ft = 1003,
    pt = 1004,
    dt = 1005,
    mt = 1006,
    vt = 1007,
    gt = 1008,
    yt = 1009,
    _t = 1010,
    xt = 1011,
    bt = 1012,
    wt = 1013,
    Mt = 1014,
    St = 1015,
    Et = 1016,
    Tt = 1017,
    At = 1018,
    Ct = 1019,
    Pt = 1020,
    Lt = 1021,
    Rt = 1022,
    It = 1023,
    Ot = 1024,
    Nt = 1025,
    Dt = 1026,
    Ut = 1027,
    Bt = 2001,
    zt = 2002,
    Ft = 2003,
    jt = 2004,
    kt = 2100,
    Vt = 2101,
    Gt = 2102,
    Ht = 2103,
    Wt = 2151,
    Xt = 2200,
    qt = 2201,
    Yt = 2202,
    Zt = 2300,
    Jt = 2301,
    Qt = 2302,
    Kt = 2400,
    $t = 2401,
    te = 2402,
    ee = 0,
    ne = 1,
    ie = 2,
    re = 3e3,
    ae = 3001,
    oe = 3007,
    se = 3002,
    ue = 3004,
    ce = 3005,
    he = 3006,
    le = 3200,
    fe = 3201
},
"RR+E": function(t, e, n) {
    "use strict";

    function i(t, e, n, i) {
        r.a.call(this, t, e, n, i)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("R+5/");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        interpolate_: function(t, e, n, i) {
            return this.copySampleValue_(t - 1)
        }
    })
},
RRa1: function(t, e, n) {
    "use strict";

    function i(t, e, n, i) {
        s.a.call(this, t, e, n, i)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("RBSo"),
    a = n("Vbxv"),
    o = n("y6Pz"),
    s = n("9DcM");
    i.prototype = Object.assign(Object.create(a.a), {
        constructor: i,
        ValueTypeName: "quaternion",
        DefaultInterpolation: r.L,
        InterpolantFactoryMethodLinear: function(t) {
            return new o.a(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: undefined
    })
},
RUnA: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_MAP\\n\\tuniform sampler2D map;\\n#endif\\n"
},
RcPT: function(t, e, n) {
    "use strict";
    e.a = "#if NUM_CLIPPING_PLANES > 0\\n\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\t\\tvarying vec3 vViewPosition;\\n\\t#endif\\n\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n"
},
RciL: function(t, e, n) {
    "use strict";
    e.a = "#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define PI_HALF 1.5707963267949\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\\tvec3 color;\\n\\tvec3 direction;\\n\\tbool visible;\\n};\\nstruct ReflectedLight {\\n\\tvec3 directDiffuse;\\n\\tvec3 directSpecular;\\n\\tvec3 indirectDiffuse;\\n\\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\\tvec3 position;\\n\\tvec3 normal;\\n\\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transpose( const in mat3 v ) {\\n\\tmat3 tmp;\\n\\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\\n\\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\\n\\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\\n\\treturn tmp;\\n}\\n"
},
RdND: function(t, e, n) {
    "use strict";
    e.a = "vec3 transformedNormal = normalMatrix * objectNormal;\\n#ifdef FLIP_SIDED\\n\\ttransformedNormal = - transformedNormal;\\n#endif\\n"
},
RawShaderMaterial: function(t, e, n) {
    "use strict";

    function i(t) {
        r.a.call(this, t),
        this.type = "RawShaderMaterial"
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("ShaderMaterial");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isRawShaderMaterial = true
},
Group: function(t, e, n) {
    "use strict";

    function Group() {
        r.a.call(this),
        this.type = "Group"
    }
    n.d(e, "a",
    function() {
        return Group
    });
    var r = n("Object3D");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i
    })
},
S81n: function(t, e, n) {
    "use strict";

    function i(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), undefined === e) this.calculateInverses();
        else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
        else {
            console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [];
            for (var n = 0,
            i = this.bones.length; n < i; n++) this.boneInverses.push(new r.a)
        }
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Matrix4");
    Object.assign(i.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var t = 0,
            e = this.bones.length; t < e; t++) {
                var n = new r.a;
                this.bones[t] && n.getInverse(this.bones[t].matrixWorld),
                this.boneInverses.push(n)
            }
        },
        pose: function() {
            var t, e, n;
            for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
            for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
        },
        update: function() {
            var t = new new Matrix4(),
            e = new new Matrix4();
            return function() {
                for (var n = this.bones,
                i = this.boneInverses,
                r = this.boneMatrices,
                a = this.boneTexture,
                o = 0,
                s = n.length; o < s; o++) {
                    var u = n[o] ? n[o].matrixWorld: e;
                    t.multiplyMatrices(u, i[o]),
                    t.toArray(r, 16 * o)
                }
                undefined !== a && (a.needsUpdate = true)
            }
        } (),
        clone: function() {
            return new i(this.bones, this.boneInverses)
        }
    })
},
ShDi: function(t, e, n) {
    "use strict";
    e.a = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif"
},
SnSb: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n#endif\\n"
},
"SvK/": function(t, e, n) {
    "use strict";

    function i(t, e) {
        return Math.exp( - t * t / (e * e * 2)) / (Math.sqrt(2 * Math.PI) * e)
    }

    function r(t, e) {
        undefined === e && (e = u);
        for (var n = [], r = 0; r <= t; r++) n.push(i(r, e));
        return n
    }
    n.d(e, "a",
    function() {
        return c
    }),
    e.b = r;
    var a = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    o = n("TZt9"),
    s = n("bMBl"),
    u = 2,
    c = {
        defines: {
            KERNEL_RADIUS: 4
        },
        uniforms: {
            map: {
                value: null
            },
            depthMap: {
                value: null
            },
            axis: {
                value: new a.I(0, 0)
            },
            weights: {
                value: r(4, u)
            },
            texelSize: {
                value: new a.I(1, 1)
            },
            cameraNear: {
                value: 1
            },
            cameraFar: {
                value: 1e3
            },
            edgeSharpness: {
                value: 1.2
            }
        },
        vertexShader: s.a,
        fragmentShader: o.a
    }
},
Color: function(t, e, n) {
    "use strict";

    function Color(t, e, n) {
        return undefined === e && undefined === n ? this.set(t) : this.setRGB(t, e, n)
    }
    n.d(e, "a",
    function() {
        return Color
    });
    var r = n("_Math"),
    //ColorKeywords
    a = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(i.prototype, {
        isColor: true,
        r: 1,
        g: 1,
        b: 1,
        set: function(t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t),
            this
        },
        setScalar: function(t) {
            return this.r = t,
            this.g = t,
            this.b = t,
            this
        },
        setHex: function(t) {
            return t = Math.floor(t),
            this.r = (t >> 16 & 255) / 255,
            this.g = (t >> 8 & 255) / 255,
            this.b = (255 & t) / 255,
            this
        },
        setRGB: function(t, e, n) {
            return this.r = t,
            this.g = e,
            this.b = n,
            this
        },
        setHSL: function() {
            function t(t, e, n) {
                return n < 0 && (n += 1),
                n > 1 && (n -= 1),
                n < 1 / 6 ? t + 6 * (e - t) * n: n < .5 ? e: n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }
            return function(e, n, i) {
                if (e = r.a.euclideanModulo(e, 1), n = r.a.clamp(n, 0, 1), i = r.a.clamp(i, 0, 1), 0 === n) this.r = this.g = this.b = i;
                else {
                    var a = i <= .5 ? i * (1 + n) : i + n - i * n,
                    o = 2 * i - a;
                    this.r = t(o, a, e + 1 / 3),
                    this.g = t(o, a, e),
                    this.b = t(o, a, e - 1 / 3)
                }
                return this
            }
        } (),
        setStyle: function(t) {
            function e(e) {
                undefined !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var n;
            if (n = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(t)) {
                var i, r = n[1],
                o = n[2];
                switch (r) {
                case "rgb":
                case "rgba":
                    if (i = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255,
                    this.g = Math.min(255, parseInt(i[2], 10)) / 255,
                    this.b = Math.min(255, parseInt(i[3], 10)) / 255,
                    e(i[5]),
                    this;
                    if (i = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100,
                    this.g = Math.min(100, parseInt(i[2], 10)) / 100,
                    this.b = Math.min(100, parseInt(i[3], 10)) / 100,
                    e(i[5]),
                    this;
                    break;
                case "hsl":
                case "hsla":
                    if (i = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(o)) {
                        var s = parseFloat(i[1]) / 360,
                        u = parseInt(i[2], 10) / 100,
                        c = parseInt(i[3], 10) / 100;
                        return e(i[5]),
                        this.setHSL(s, u, c)
                    }
                }
            } else if (n = /^\\#([A-Fa-f0-9]+)$/.exec(t)) {
                var h = n[1],
                l = h.length;
                if (3 === l) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255,
                this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255,
                this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255,
                this;
                if (6 === l) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255,
                this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255,
                this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255,
                this
            }
            if (t && t.length > 0) {
                var h = a[t];
                undefined !== h ? this.setHex(h) : console.warn("THREE.Color: Unknown color " + t)
            }
            return this
        },
        clone: function() {
            return new this.constructor(this.r, this.g, this.b)
        },
        copy: function(t) {
            return this.r = t.r,
            this.g = t.g,
            this.b = t.b,
            this
        },
        copyGammaToLinear: function(t, e) {
            return undefined === e && (e = 2),
            this.r = Math.pow(t.r, e),
            this.g = Math.pow(t.g, e),
            this.b = Math.pow(t.b, e),
            this
        },
        copyLinearToGamma: function(t, e) {
            undefined === e && (e = 2);
            var n = e > 0 ? 1 / e: 1;
            return this.r = Math.pow(t.r, n),
            this.g = Math.pow(t.g, n),
            this.b = Math.pow(t.b, n),
            this
        },
        convertGammaToLinear: function() {
            var t = this.r,
            e = this.g,
            n = this.b;
            return this.r = t * t,
            this.g = e * e,
            this.b = n * n,
            this
        },
        convertLinearToGamma: function() {
            return this.r = Math.sqrt(this.r),
            this.g = Math.sqrt(this.g),
            this.b = Math.sqrt(this.b),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice( - 6)
        },
        getHSL: function(t) {
            var e, n, i = t || {
                h: 0,
                s: 0,
                l: 0
            },
            r = this.r,
            a = this.g,
            o = this.b,
            s = Math.max(r, a, o),
            u = Math.min(r, a, o),
            c = (u + s) / 2;
            if (u === s) e = 0,
            n = 0;
            else {
                var h = s - u;
                switch (n = c <= .5 ? h / (s + u) : h / (2 - s - u), s) {
                case r:
                    e = (a - o) / h + (a < o ? 6 : 0);
                    break;
                case a:
                    e = (o - r) / h + 2;
                    break;
                case o:
                    e = (r - a) / h + 4
                }
                e /= 6
            }
            return i.h = e,
            i.s = n,
            i.l = c,
            i
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: function(t, e, n) {
            var i = this.getHSL();
            return i.h += t,
            i.s += e,
            i.l += n,
            this.setHSL(i.h, i.s, i.l),
            this
        },
        add: function(t) {
            return this.r += t.r,
            this.g += t.g,
            this.b += t.b,
            this
        },
        addColors: function(t, e) {
            return this.r = t.r + e.r,
            this.g = t.g + e.g,
            this.b = t.b + e.b,
            this
        },
        addScalar: function(t) {
            return this.r += t,
            this.g += t,
            this.b += t,
            this
        },
        sub: function(t) {
            return this.r = Math.max(0, this.r - t.r),
            this.g = Math.max(0, this.g - t.g),
            this.b = Math.max(0, this.b - t.b),
            this
        },
        multiply: function(t) {
            return this.r *= t.r,
            this.g *= t.g,
            this.b *= t.b,
            this
        },
        multiplyScalar: function(t) {
            return this.r *= t,
            this.g *= t,
            this.b *= t,
            this
        },
        lerp: function(t, e) {
            return this.r += (t.r - this.r) * e,
            this.g += (t.g - this.g) * e,
            this.b += (t.b - this.b) * e,
            this
        },
        equals: function(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        },
        fromArray: function(t, e) {
            return undefined === e && (e = 0),
            this.r = t[e],
            this.g = t[e + 1],
            this.b = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return undefined === t && (t = []),
            undefined === e && (e = 0),
            t[e] = this.r,
            t[e + 1] = this.g,
            t[e + 2] = this.b,
            t
        },
        toJSON: function() {
            return this.getHex()
        }
    })
},
ShadowMaterial: function(t, e, n) {
    "use strict";

    function i(t) {
        r.a.call(this, {
            uniforms: s.a.merge([o.a.lights, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: a.a.shadow_vert,
            fragmentShader: a.a.shadow_frag
        }),
        this.lights = true,
        this.transparent = true,
        Object.defineProperties(this, {
            opacity: {
                enumerable: true,
                get: function() {
                    return this.uniforms.opacity.value
                },
                set: function(t) {
                    this.uniforms.opacity.value = t
                }
            }
        }),
        this.setValues(t)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("ShaderMaterial"),
    a = n("WqzK"),
    o = n("yQK5"),
    s = n("UniformsUtils");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isShadowMaterial = true
},
TJTO: function(t, e, n) {
    "use strict";

    function i(t, e, n) {
        var i = t.min,
        r = t.max,
        u = (e.x < i.x ? 1 : 0) + (e.x > r.x ? 2 : 0) + (e.y < i.y ? 4 : 0) + (e.y > r.y ? 8 : 0) + (e.z < i.z ? 16 : 0) + (e.z > r.z ? 32 : 0),
        c = a[u][6];
        if (0 === c) return 4;
        o[0].set(i.x, i.y, i.z),
        o[1].set(r.x, i.y, i.z),
        o[2].set(r.x, r.y, i.z),
        o[3].set(i.x, r.y, i.z),
        o[4].set(i.x, i.y, r.z),
        o[5].set(r.x, i.y, r.z),
        o[6].set(r.x, r.y, r.z),
        o[7].set(i.x, r.y, r.z);
        for (var h = 0; h < c; ++h) {
            var l = o[a[u][h]];
            l.applyMatrix4(n),
            s[h].set(l.x, -l.y)
        }
        for (var f, p = -1,
        d = s[c - 1], m = 0; ++p < c;) f = d,
        d = s[p],
        m += f.y * d.x - f.x * d.y;
        return m < 0 || m > 8 ? 4 : .5 * m
    }
    e.a = i;
    var r = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    a = [[ - 1, -1, -1, -1, -1, -1, 0], [0, 4, 7, 3, -1, -1, 4], [1, 2, 6, 5, -1, -1, 4], [ - 1, -1, -1, -1, -1, -1, 0], [0, 1, 5, 4, -1, -1, 4], [0, 1, 5, 4, 7, 3, 6], [0, 1, 2, 6, 5, 4, 6], [ - 1, -1, -1, -1, -1, -1, 0], [2, 3, 7, 6, -1, -1, 4], [0, 4, 7, 6, 2, 3, 6], [1, 2, 3, 7, 6, 5, 6], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [0, 3, 2, 1, -1, -1, 4], [0, 4, 7, 3, 2, 1, 6], [0, 3, 2, 6, 5, 1, 6], [ - 1, -1, -1, -1, -1, -1, 0], [0, 3, 2, 1, 5, 4, 6], [1, 5, 4, 7, 3, 2, 6], [0, 3, 2, 6, 5, 4, 6], [ - 1, -1, -1, -1, -1, -1, 0], [0, 3, 7, 6, 2, 1, 6], [0, 4, 7, 6, 2, 1, 6], [0, 3, 7, 6, 5, 1, 6], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [4, 5, 6, 7, -1, -1, 4], [0, 4, 5, 6, 7, 3, 6], [1, 2, 6, 7, 4, 5, 6], [ - 1, -1, -1, -1, -1, -1, 0], [0, 1, 5, 6, 7, 4, 6], [0, 1, 5, 6, 7, 3, 6], [0, 1, 2, 6, 7, 4, 6], [ - 1, -1, -1, -1, -1, -1, 0], [2, 3, 7, 4, 5, 6, 6], [0, 4, 5, 6, 2, 3, 6], [1, 2, 3, 7, 4, 5, 6], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0], [ - 1, -1, -1, -1, -1, -1, 0]],
    o = [new r.J( - 1, -1, -1), new r.J( - 1, -1, -1), new r.J( - 1, -1, -1), new r.J( - 1, -1, -1), new r.J( - 1, -1, -1), new r.J( - 1, -1, -1), new r.J( - 1, -1, -1), new r.J( - 1, -1, -1)],
    s = [new r.I( - 1, -1), new r.I( - 1, -1), new r.I( - 1, -1), new r.I( - 1, -1), new r.I( - 1, -1), new r.I( - 1, -1)]
},
TQJV: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return i
    });
    var i; !
    function(t) {
        t[t.ARROW_LEFT = 37] = "ARROW_LEFT",
        t[t.ARROW_UP = 38] = "ARROW_UP",
        t[t.ARROW_RIGHT = 39] = "ARROW_RIGHT",
        t[t.ARROW_DOWN = 40] = "ARROW_DOWN",
        t[t.A = 65] = "A",
        t[t.B = 66] = "B",
        t[t.C = 67] = "C",
        t[t.D = 68] = "D",
        t[t.E = 69] = "E",
        t[t.F = 70] = "F",
        t[t.G = 71] = "G",
        t[t.H = 72] = "H",
        t[t.I = 73] = "I",
        t[t.J = 74] = "J",
        t[t.K = 75] = "K",
        t[t.L = 76] = "L",
        t[t.M = 77] = "M",
        t[t.N = 78] = "N",
        t[t.O = 79] = "O",
        t[t.P = 80] = "P",
        t[t.Q = 81] = "Q",
        t[t.R = 82] = "R",
        t[t.S = 83] = "S",
        t[t.T = 84] = "T",
        t[t.U = 85] = "U",
        t[t.V = 86] = "V",
        t[t.W = 87] = "W",
        t[t.X = 88] = "X",
        t[t.Y = 89] = "Y",
        t[t.Z = 90] = "Z"
    } (i || (i = {}))
},
TRUI: function(t, e, n) {
    "use strict";

    function i() {
        this.seq = [],
        this.map = {}
    }

    function r(t, e, n) {
        var i = t[0];
        if (i <= 0 || i > 0) return t;
        var r = e * n,
        a = k[r];
        if (undefined === a && (a = new Float32Array(r), k[r] = a), 0 !== e) {
            i.toArray(a, 0);
            for (var o = 1,
            s = 0; o !== e; ++o) s += n,
            t[o].toArray(a, s)
        }
        return a
    }

    function a(t, e) {
        var n = V[e];
        undefined === n && (n = new Int32Array(e), V[e] = n);
        for (var i = 0; i !== e; ++i) n[i] = t.allocTextureUnit();
        return n
    }

    function o(t, e) {
        t.uniform1f(this.addr, e)
    }

    function s(t, e) {
        t.uniform1i(this.addr, e)
    }

    function u(t, e) {
        undefined === e.x ? t.uniform2fv(this.addr, e) : t.uniform2f(this.addr, e.x, e.y)
    }

    function c(t, e) {
        undefined !== e.x ? t.uniform3f(this.addr, e.x, e.y, e.z) : undefined !== e.r ? t.uniform3f(this.addr, e.r, e.g, e.b) : t.uniform3fv(this.addr, e)
    }

    function h(t, e) {
        undefined === e.x ? t.uniform4fv(this.addr, e) : t.uniform4f(this.addr, e.x, e.y, e.z, e.w)
    }

    function l(t, e) {
        t.uniformMatrix2fv(this.addr, false, e.elements || e)
    }

    function f(t, e) {
        undefined === e.elements ? t.uniformMatrix3fv(this.addr, false, e) : (H.set(e.elements), t.uniformMatrix3fv(this.addr, false, H))
    }

    function p(t, e) {
        undefined === e.elements ? t.uniformMatrix4fv(this.addr, false, e) : (G.set(e.elements), t.uniformMatrix4fv(this.addr, false, G))
    }

    function d(t, e, n) {
        var i = n.allocTextureUnit();
        t.uniform1i(this.addr, i),
        n.setTexture2D(e || F, i)
    }

    function m(t, e, n) {
        var i = n.allocTextureUnit();
        t.uniform1i(this.addr, i),
        n.setTextureCube(e || j, i)
    }

    function v(t, e) {
        t.uniform2iv(this.addr, e)
    }

    function g(t, e) {
        t.uniform3iv(this.addr, e)
    }

    function y(t, e) {
        t.uniform4iv(this.addr, e)
    }

    function _(t) {
        switch (t) {
        case 5126:
            return o;
        case 35664:
            return u;
        case 35665:
            return c;
        case 35666:
            return h;
        case 35674:
            return l;
        case 35675:
            return f;
        case 35676:
            return p;
        case 35678:
        case 36198:
            return d;
        case 35680:
            return m;
        case 5124:
        case 35670:
            return s;
        case 35667:
        case 35671:
            return v;
        case 35668:
        case 35672:
            return g;
        case 35669:
        case 35673:
            return y
        }
    }

    function x(t, e) {
        t.uniform1fv(this.addr, e)
    }

    function b(t, e) {
        t.uniform1iv(this.addr, e)
    }

    function w(t, e) {
        t.uniform2fv(this.addr, r(e, this.size, 2))
    }

    function M(t, e) {
        t.uniform3fv(this.addr, r(e, this.size, 3))
    }

    function S(t, e) {
        t.uniform4fv(this.addr, r(e, this.size, 4))
    }

    function E(t, e) {
        t.uniformMatrix2fv(this.addr, false, r(e, this.size, 4))
    }

    function T(t, e) {
        t.uniformMatrix3fv(this.addr, false, r(e, this.size, 9))
    }

    function A(t, e) {
        t.uniformMatrix4fv(this.addr, false, r(e, this.size, 16))
    }

    function C(t, e, n) {
        var i = e.length,
        r = a(n, i);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== i; ++o) n.setTexture2D(e[o] || F, r[o])
    }

    function P(t, e, n) {
        var i = e.length,
        r = a(n, i);
        t.uniform1iv(this.addr, r);
        for (var o = 0; o !== i; ++o) n.setTextureCube(e[o] || j, r[o])
    }

    function L(t) {
        switch (t) {
        case 5126:
            return x;
        case 35664:
            return w;
        case 35665:
            return M;
        case 35666:
            return S;
        case 35674:
            return E;
        case 35675:
            return T;
        case 35676:
            return A;
        case 35678:
            return C;
        case 35680:
            return P;
        case 5124:
        case 35670:
            return b;
        case 35667:
        case 35671:
            return v;
        case 35668:
        case 35672:
            return g;
        case 35669:
        case 35673:
            return y
        }
    }

    function R(t, e, n) {
        this.id = t,
        this.addr = n,
        this.setValue = _(e.type)
    }

    function I(t, e, n) {
        this.id = t,
        this.addr = n,
        this.size = e.size,
        this.setValue = L(e.type)
    }

    function O(t) {
        this.id = t,
        i.call(this)
    }

    function N(t, e) {
        t.seq.push(e),
        t.map[e.id] = e
    }

    function D(t, e, n) {
        var i = t.name,
        r = i.length;
        for (W.lastIndex = 0;;) {
            var a = W.exec(i),
            o = W.lastIndex,
            s = a[1],
            u = "]" === a[2],
            c = a[3];
            if (u && (s |= 0), undefined === c || "[" === c && o + 2 === r) {
                N(n, undefined === c ? new R(s, t, e) : new I(s, t, e));
                break
            }
            var h = n.map,
            l = h[s];
            undefined === l && (l = new O(s), N(n, l)),
            n = l
        }
    }

    function U(t, e, n) {
        i.call(this),
        this.renderer = n;
        for (var r = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), a = 0; a < r; ++a) {
            var o = t.getActiveUniform(e, a),
            s = o.name;
            D(o, t.getUniformLocation(e, s), this)
        }
    }
    n.d(e, "a",
    function() {
        return U
    });
    var B = n("mUPD"),
    z = n("vh+C"),
    F = new z.a,
    j = new B.a,
    k = [],
    V = [],
    G = new Float32Array(16),
    H = new Float32Array(9);
    O.prototype.setValue = function(t, e) {
        for (var n = this.seq,
        i = 0,
        r = n.length; i !== r; ++i) {
            var a = n[i];
            a.setValue(t, e[a.id])
        }
    };
    //var W = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g;
    U.prototype.setValue = function(t, e, n) {
        var i = this.map[e];
        undefined !== i && i.setValue(t, n, this.renderer)
    },
    U.prototype.setOptional = function(t, e, n) {
        var i = e[n];
        undefined !== i && this.setValue(t, n, i)
    },
    U.upload = function(t, e, n, i) {
        for (var r = 0,
        a = e.length; r !== a; ++r) {
            var o = e[r],
            s = n[o.id]; ! 1 !== s.needsUpdate && o.setValue(t, s.value, i)
        }
    },
    U.seqWithValue = function(t, e) {
        for (var n = [], i = 0, r = t.length; i !== r; ++i) {
            var a = t[i];
            a.id in e && n.push(a)
        }
        return n
    }
},
TSrf: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_ENVMAP\\n\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\t\\tvWorldPosition = worldPosition.xyz;\\n\\t#else\\n\\t\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\t\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\\t\\t#ifdef ENVMAP_MODE_REFLECTION\\n\\t\\t\\tvReflect = reflect( cameraToVertex, worldNormal );\\n\\t\\t#else\\n\\t\\t\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\t\\t#endif\\n\\t#endif\\n#endif\\n"
},
TTda: function(t, e, n) {
    "use strict";

    function i(t) {
        this.manager = undefined !== t ? t: c.a
    }
    var r = n("Sphere"),
    a = n("Vector3"),
    o = n("BufferAttribute"),
    s = n("BufferGeometry"),
    u = n("w2Sq"),
    c = n("OJZr");
    Object.assign(i.prototype, {
        load: function(t, e, n, i) {
            var r = this;
            new u.a(r.manager).load(t,
            function(t) {
                e(r.parse(JSON.parse(t)))
            },
            n, i)
        },
        parse: function(t) {
            var e = new s.a,
            n = t.data.index;
            if (undefined !== n) {
                var i = new h[n.type](n.array);
                e.setIndex(new o.a(i, 1))
            }
            var u = t.data.attributes;
            for (var c in u) {
                var l = u[c],
                i = new h[l.type](l.array);
                e.addAttribute(c, new o.a(i, l.itemSize, l.normalized))
            }
            var f = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (undefined !== f) for (var p = 0,
            d = f.length; p !== d; ++p) {
                var m = f[p];
                e.addGroup(m.start, m.count, m.materialIndex)
            }
            var v = t.data.boundingSphere;
            if (undefined !== v) {
                var g = new a.a;
                undefined !== v.center && g.fromArray(v.center),
                e.boundingSphere = new r.a(g, v.radius)
            }
            return e
        }
    });
    var h = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray: Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    }
},
TTgl: function(t, e, n) {
    "use strict";
    e.a = "#define PI2 6.28318530718\\n#define UNIT_TO_M 0.001\\nvarying vec2 vUv;\\nuniform sampler2D depthMap;\\n#ifdef NORMAL_TEXTURE\\nuniform sampler2D normalMap;\\n#endif\\nuniform sampler2D noiseMap;\\nuniform float radius;\\nuniform float bias;\\nuniform float intensityDivR6;\\nuniform float projectionScale;\\nuniform vec2 noiseScale;\\nuniform vec2 texelSize;\\nuniform float cameraNear;\\nuniform float cameraFar;\\nuniform mat4 cameraProjectionMatrix;\\nuniform mat4 cameraInverseProjectionMatrix;\\n#include <packing>\\nconst float INV_NUM_SAMPLES = 1.0 /float(NUM_SAMPLES);\\nfloat noise(vec2 uv) {\\nreturn texture2D(noiseMap, uv * noiseScale).x;\\n}\\nfloat reconstructCSZ(float depth) {\\nreturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\\n}\\nvec3 reconstructCSPosition(vec2 uv, float z) {\\n float clipW = cameraProjectionMatrix[2][3] * z + cameraProjectionMatrix[3][3];\\n vec4 clipPosition = vec4((vec3(uv, z) - 0.5) * 2.0, 1.0);\\n clipPosition *= clipW;\\nreturn (cameraInverseProjectionMatrix * clipPosition).xyz * UNIT_TO_M;\\n}\\nvec3 reconstructCSFaceNormal(vec3 position) {\\nreturn normalize(cross(dFdx(position), dFdy(position)));\\n}\\nfloat getDepth(vec2 uv) {\\n # ifdef DEPTH_TEXTURE\\ nreturn texture2D(depthMap, uv).x;\\n #else\\ nreturn unpackRGBAToDepth(texture2D(depthMap, uv));\\n # endif\\ n}\\nvec3 getPosition(vec2 uv) {\\n float zDepth = getDepth(uv);\\n float depthCS = reconstructCSZ(zDepth);\\nreturn reconstructCSPosition(uv, depthCS);\\n}\\nvec3 getNormal(vec2 uv, vec3 position) {\\n # ifdef NORMAL_TEXTURE\\ nreturn (texture2D(normalMap, uv).xyz - 0.5) * 2.0;\\n #else\\ nreturn reconstructCSFaceNormal(position);\\n # endif\\ n}\\nvec2 tapLocation(int sampleNumber, float spinAngle, out float radiusSS) {\\n float alpha = (float(sampleNumber) + 0.5) * INV_NUM_SAMPLES;\\n float angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;\\n radiusSS = alpha;\\nreturn vec2(cos(angle), sin(angle));\\n}\\nvec3 getOffsetPosition(vec2 uv, vec2 unitOffset, float radiusSS) {\\n uv = uv + radiusSS * unitOffset * texelSize;\\nreturn getPosition(uv);\\n}\\nfloat sampleAO(vec2 uv, vec3 positionCS, vec3 normalCS, float diskRadiusSS, int tapIndex, float rotationAngle) {\\n float radius2 = radius * radius;\\n float radiusSS;\\n vec2 unitOffset = tapLocation(tapIndex, rotationAngle, radiusSS);\\n radiusSS *= diskRadiusSS;\\n vec3 Q = getOffsetPosition(uv, unitOffset, radiusSS);\\n vec3 v = Q - positionCS;\\n float vv = dot(v, v);\\n float vn = dot(v, normalCS);\\nconst float epsilon = 0.05;\\n float f = max(radius2 - vv, 0.0);return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);\\n}\\nvoid main() {\\n vec3 originCS = getPosition(vUv);\\n vec3 normalCS = getNormal(vUv, originCS);\\n float randomPatternRotationAngle = PI2 * noise(vUv);\\n float radiusSS = min(-radius * projectionScale / originCS.z, float(MAX_SS_RADIUS));\\n float sum = 0.0;\\nfor (int i = 0; i < NUM_SAMPLES; ++i) {\\n sum += sampleAO(vUv, originCS, normalCS, radiusSS, i, randomPatternRotationAngle);\\n}\\n float occlusion = max(0.1, 1.0 - sum * intensityDivR6 * INV_NUM_SAMPLES);\\n gl_FragColor = vec4(occlusion, occlusion, occlusion, 1.0);\\n}\\n "
},
Quaternion: function(t, e, n) {
    "use strict ";

    function i(t, e, n, i) {
        this._x = t || 0,
        this._y = e || 0,
        this._z = n || 0,
        this._w = undefined !== i ? i: 1
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Vector3 ");
    Object.assign(i, {
        slerp: function(t, e, n, i) {
            return n.copy(t).slerp(e, i)
        },
        slerpFlat: function(t, e, n, i, r, a, o) {
            var s = n[i + 0],
            u = n[i + 1],
            c = n[i + 2],
            h = n[i + 3],
            l = r[a + 0],
            f = r[a + 1],
            p = r[a + 2],
            d = r[a + 3];
            if (h !== d || s !== l || u !== f || c !== p) {
                var m = 1 - o,
                v = s * l + u * f + c * p + h * d,
                g = v >= 0 ? 1 : -1,
                y = 1 - v * v;
                if (y > Number.EPSILON) {
                    var _ = Math.sqrt(y),
                    x = Math.atan2(_, v * g);
                    m = Math.sin(m * x) / _,
                    o = Math.sin(o * x) / _
                }
                var b = o * g;
                if (s = s * m + l * b, u = u * m + f * b, c = c * m + p * b, h = h * m + d * b, m === 1 - o) {
                    var w = 1 / Math.sqrt(s * s + u * u + c * c + h * h);
                    s *= w,
                    u *= w,
                    c *= w,
                    h *= w
                }
            }
            t[e] = s,
            t[e + 1] = u,
            t[e + 2] = c,
            t[e + 3] = h
        }
    }),
    Object.defineProperties(i.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(t) {
                this._x = t,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(t) {
                this._y = t,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(t) {
                this._z = t,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(t) {
                this._w = t,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(i.prototype, {
        set: function(t, e, n, i) {
            return this._x = t,
            this._y = e,
            this._z = n,
            this._w = i,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x, this._y, this._z, this._w)
        },
        copy: function(t) {
            return this._x = t.x,
            this._y = t.y,
            this._z = t.z,
            this._w = t.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(t, e) {
            if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var n = t._x,
            i = t._y,
            r = t._z,
            a = t.order,
            o = Math.cos,
            s = Math.sin,
            u = o(n / 2),
            c = o(i / 2),
            h = o(r / 2),
            l = s(n / 2),
            f = s(i / 2),
            p = s(r / 2);
            return "XYZ " === a ? (this._x = l * c * h + u * f * p, this._y = u * f * h - l * c * p, this._z = u * c * p + l * f * h, this._w = u * c * h - l * f * p) : "YXZ " === a ? (this._x = l * c * h + u * f * p, this._y = u * f * h - l * c * p, this._z = u * c * p - l * f * h, this._w = u * c * h + l * f * p) : "ZXY " === a ? (this._x = l * c * h - u * f * p, this._y = u * f * h + l * c * p, this._z = u * c * p + l * f * h, this._w = u * c * h - l * f * p) : "ZYX " === a ? (this._x = l * c * h - u * f * p, this._y = u * f * h + l * c * p, this._z = u * c * p - l * f * h, this._w = u * c * h + l * f * p) : "YZX " === a ? (this._x = l * c * h + u * f * p, this._y = u * f * h + l * c * p, this._z = u * c * p - l * f * h, this._w = u * c * h - l * f * p) : "XZY " === a && (this._x = l * c * h - u * f * p, this._y = u * f * h - l * c * p, this._z = u * c * p + l * f * h, this._w = u * c * h + l * f * p),
            false !== e && this.onChangeCallback(),
            this
        },
        setFromAxisAngle: function(t, e) {
            var n = e / 2,
            i = Math.sin(n);
            return this._x = t.x * i,
            this._y = t.y * i,
            this._z = t.z * i,
            this._w = Math.cos(n),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(t) {
            var e, n = t.elements,
            i = n[0],
            r = n[4],
            a = n[8],
            o = n[1],
            s = n[5],
            u = n[9],
            c = n[2],
            h = n[6],
            l = n[10],
            f = i + s + l;
            return f > 0 ? (e = .5 / Math.sqrt(f + 1), this._w = .25 / e, this._x = (h - u) * e, this._y = (a - c) * e, this._z = (o - r) * e) : i > s && i > l ? (e = 2 * Math.sqrt(1 + i - s - l), this._w = (h - u) / e, this._x = .25 * e, this._y = (r + o) / e, this._z = (a + c) / e) : s > l ? (e = 2 * Math.sqrt(1 + s - i - l), this._w = (a - c) / e, this._x = (r + o) / e, this._y = .25 * e, this._z = (u + h) / e) : (e = 2 * Math.sqrt(1 + l - i - s), this._w = (o - r) / e, this._x = (a + c) / e, this._y = (u + h) / e, this._z = .25 * e),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: function() {
            var t, e;
            return function(n, i) {
                return undefined === t && (t = new r.a),
                e = n.dot(i) + 1,
                e < 1e-6 ? (e = 0, Math.abs(n.x) > Math.abs(n.z) ? t.set( - n.y, n.x, 0) : t.set(0, -n.z, n.y)) : t.crossVectors(n, i),
                this._x = t.x,
                this._y = t.y,
                this._z = t.z,
                this._w = e,
                this.normalize()
            }
        } (),
        inverse: function() {
            return this.conjugate().normalize()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var t = this.length();
            return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t),
            this.onChangeCallback(),
            this
        },
        multiply: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument.Use.multiplyQuaternions(a, b) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        },
        premultiply: function(t) {
            return this.multiplyQuaternions(t, this)
        },
        multiplyQuaternions: function(t, e) {
            var n = t._x,
            i = t._y,
            r = t._z,
            a = t._w,
            o = e._x,
            s = e._y,
            u = e._z,
            c = e._w;
            return this._x = n * c + a * o + i * u - r * s,
            this._y = i * c + a * s + r * o - n * u,
            this._z = r * c + a * u + n * s - i * o,
            this._w = a * c - n * o - i * s - r * u,
            this.onChangeCallback(),
            this
        },
        slerp: function(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var n = this._x,
            i = this._y,
            r = this._z,
            a = this._w,
            o = a * t._w + n * t._x + i * t._y + r * t._z;
            if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = a,
            this._x = n,
            this._y = i,
            this._z = r,
            this;
            var s = Math.sqrt(1 - o * o);
            if (Math.abs(s) < .001) return this._w = .5 * (a + this._w),
            this._x = .5 * (n + this._x),
            this._y = .5 * (i + this._y),
            this._z = .5 * (r + this._z),
            this;
            var u = Math.atan2(s, o),
            c = Math.sin((1 - e) * u) / s,
            h = Math.sin(e * u) / s;
            return this._w = a * c + this._w * h,
            this._x = n * c + this._x * h,
            this._y = i * c + this._y * h,
            this._z = r * c + this._z * h,
            this.onChangeCallback(),
            this
        },
        equals: function(t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        },
        fromArray: function(t, e) {
            return undefined === e && (e = 0),
            this._x = t[e],
            this._y = t[e + 1],
            this._z = t[e + 2],
            this._w = t[e + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(t, e) {
            return undefined === t && (t = []),
            undefined === e && (e = 0),
            t[e] = this._x,
            t[e + 1] = this._y,
            t[e + 2] = this._z,
            t[e + 3] = this._w,
            t
        },
        onChange: function(t) {
            return this.onChangeCallback = t,
            this
        },
        onChangeCallback: function() {}
    })
},
TZt9: function(t, e, n) {
    "use strict ";
    e.a = "varying vec2 vUv;\\nuniform sampler2D map;\\nuniform sampler2D depthMap;\\nuniform vec2 axis;\\nuniform vec2 texelSize;\\nuniform float weights[KERNEL_RADIUS + 1];\\nuniform float cameraNear;\\nuniform float cameraFar;\\nuniform float edgeSharpness;\\n # include < packing > \\nfloat reconstructCSZ(vec2 uv) {\\n float depth = unpackRGBAToDepth(texture2D(depthMap, uv));\\nreturn perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\\n}\\nvoid main() {\\n vec3 color = texture2D(map, vUv).rgb;\\n float depth = reconstructCSZ(vUv);\\n vec3 sum = color;\\n float base = weights[0];\\n float totalWeight = base;\\n sum *= totalWeight;\\n float factor = edgeSharpness / (-depth) * 100.0;\\nfor (int r = 1; r <= KERNEL_RADIUS; ++r) {\\n vec2 offset = axis * float(r) * texelSize;\\n float tapWeight = 0.3 + weights[r];\\n vec2 tapUv = vUv + offset;\\n vec3 tapColor = texture2D(map, tapUv).rgb;\\n float tapDepth = reconstructCSZ(tapUv);\\n tapWeight *= max(0.0, 1.0 - abs(tapDepth - depth) * factor);\\n totalWeight += tapWeight;\\n sum += tapColor * tapWeight;\\n tapUv = vUv - offset;\\n tapColor = texture2D(map, tapUv).rgb;\\n tapDepth = reconstructCSZ(tapUv);\\n tapWeight *= max(0.0, 1.0 - abs(tapDepth - depth) * factor);\\n totalWeight += tapWeight;\\n sum += tapColor * tapWeight;\\n}\\nconst float epsilon = 0.0001;\\n gl_FragColor = vec4(sum / (totalWeight + epsilon), 1.0);\\n}\\n "
},
TaIP: function(t, e, n) {
    "use strict ";
    e.a = "#if NUM_CLIPPING_PLANES > 0\\ n\\ tfor(int i = 0; i < UNION_CLIPPING_PLANES; ++i) {\\n\\ t\\ tvec4 plane = clippingPlanes[i];\\n\\ t\\ tif(dot(vViewPosition, plane.xyz) > plane.w) discard;\\n\\ t}\\n\\ t\\ t\\ n\\ t #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\ n\\ t\\ tbool clipped = true;\\n\\ t\\ tfor(int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++i) {\\n\\ t\\ t\\ tvec4 plane = clippingPlanes[i];\\n\\ t\\ t\\ tclipped = (dot(vViewPosition, plane.xyz) > plane.w) && clipped;\\n\\ t\\ t}\\n\\ t\\ tif(clipped) discard;\\n\\ t\\ n\\ t # endif\\ n # endif\\ n "
},
TeME: function(t, e, n) {
    "use strict ";
    function i() {
        function t() {
            l.value !== i && (l.value = i, l.needsUpdate = o > 0),
            n.numPlanes = o,
            n.numIntersection = 0
        }
        function e(t, e, i, r) {
            var a = null !== t ? t.length: 0,
            o = null;
            if (0 !== a) {
                if (o = l.value, true !== r || null === o) {
                    var s = i + 4 * a,
                    u = e.matrixWorldInverse;
                    h.getNormalMatrix(u),
                    (null === o || o.length < s) && (o = new Float32Array(s));
                    for (var f = 0,
                    p = i; f !== a; ++f, p += 4) c.copy(t[f]).applyMatrix4(u, h),
                    c.normal.toArray(o, p),
                    o[p + 3] = c.constant
                }
                l.value = o,
                l.needsUpdate = true
            }
            return n.numPlanes = a,
            o
        }
        var n = this,
        i = null,
        o = 0,
        s = false,
        u = false,
        c = new a.a,
        h = new r.a,
        l = {
            value: null,
            needsUpdate: false
        };
        this.uniform = l,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(t, n, r) {
            var a = 0 !== t.length || n || 0 !== o || s;
            return s = n,
            i = e(t, r, 0),
            o = t.length,
            a
        },
        this.beginShadows = function() {
            u = true,
            e(null)
        },
        this.endShadows = function() {
            u = false,
            t()
        },
        this.setState = function(n, r, a, c, h, f) {
            if (!s || null === n || 0 === n.length || u && !a) u ? e(null) : t();
            else {
                var p = u ? 0 : o,
                d = 4 * p,
                m = h.clippingState || null;
                l.value = m,
                m = e(n, c, d, f);
                for (var v = 0; v !== d; ++v) m[v] = i[v];
                h.clippingState = m,
                this.numIntersection = r ? this.numPlanes: 0,
                this.numPlanes += p
            }
        }
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Matrix3 "),
    a = n("Plane ")
},
MeshLambertMaterial: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.type = "MeshLambertMaterial ",
        this.color = new o.a(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new o.a(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = a._4,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = false,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round ",
        this.wireframeLinejoin = "round ",
        this.skinning = false,
        this.morphTargets = false,
        this.morphNormals = false,
        this.setValues(t)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Material "),
    a = n("RBSo "),
    o = n("Color ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isMeshLambertMaterial = true,
    i.prototype.copy = function(t) {
        return r.a.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.emissive.copy(t.emissive),
        this.emissiveMap = t.emissiveMap,
        this.emissiveIntensity = t.emissiveIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this
    }
},
TiW2: function(t, e, n) {
    "use strict ";

    function i(t, e, n, i) {
        f.a.apply(this, arguments)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Vbxv "),
    a = n("bv29 "),
    o = n("onH + "),
    s = n("RRa1 "),
    u = n("h6VZ "),
    c = n("j6 + M "),
    h = n("pINk "),
    l = n("4 W4M "),
    f = n("9 DcM ");
    i.prototype = r.a,
    r.a.constructor = i,
    Object.assign(i, {
        parse: function(t) {
            if (undefined === t.type) throw new Error("track type undefined, can not parse ");
            var e = i._getTrackTypeForValueTypeName(t.type);
            if (undefined === t.times) {
                var n = [],
                r = [];
                l.a.flattenJSON(t.keys, n, r, "value "),
                t.times = n,
                t.values = r
            }
            return undefined !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
        },
        toJSON: function(t) {
            var e, n = t.constructor;
            if (undefined !== n.toJSON) e = n.toJSON(t);
            else {
                e = {
                    name: t.name,
                    times: l.a.convertArray(t.times, Array),
                    values: l.a.convertArray(t.values, Array)
                };
                var i = t.getInterpolation();
                i !== t.DefaultInterpolation && (e.interpolation = i)
            }
            return e.type = t.ValueTypeName,
            e
        },
        _getTrackTypeForValueTypeName: function(t) {
            switch (t.toLowerCase()) {
            case "scalar ":
            case "double ":
            case "float ":
            case "number ":
            case "integer ":
                return h.a;
            case "vector ":
            case "vector2 ":
            case "vector3 ":
            case "vector4 ":
                return c.a;
            case "color ":
                return u.a;
            case "quaternion ":
                return s.a;
            case "bool ":
            case "boolean ":
                return o.a;
            case "string ":
                return a.a
            }
            throw new Error("Unsupported typeName: " + t)
        }
    })
},
TkQk: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef ENVMAP_TYPE_CUBE_UV\\ n # define cubeUV_textureSize(1024.0)\\ nint getFaceFromDirection(vec3 direction) {\\n\\ tvec3 absDirection = abs(direction);\\n\\ tint face = -1;\\n\\ tif(absDirection.x > absDirection.z) {\\n\\ t\\ tif(absDirection.x > absDirection.y)\\ n\\ t\\ t\\ tface = direction.x > 0.0 ? 0 : 3;\\n\\ t\\ telse\\ n\\ t\\ t\\ tface = direction.y > 0.0 ? 1 : 4;\\n\\ t}\\n\\ telse {\\n\\ t\\ tif(absDirection.z > absDirection.y)\\ n\\ t\\ t\\ tface = direction.z > 0.0 ? 2 : 5;\\n\\ t\\ telse\\ n\\ t\\ t\\ tface = direction.y > 0.0 ? 1 : 4;\\n\\ t}\\n\\ treturn face;\\n}\\n # define cubeUV_maxLods1(log2(cubeUV_textureSize * 0.25) - 1.0)\\ n # define cubeUV_rangeClamp(exp2((6.0 - 1.0) * 2.0))\\ nvec2 MipLevelInfo(vec3 vec, float roughnessLevel, float roughness) {\\n\\ tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\\ tfloat dxRoughness = dFdx(roughness);\\n\\ tfloat dyRoughness = dFdy(roughness);\\n\\ tvec3 dx = dFdx(vec * scale * dxRoughness);\\n\\ tvec3 dy = dFdy(vec * scale * dyRoughness);\\n\\ tfloat d = max(dot(dx, dx), dot(dy, dy));\\n\\ td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\\ tfloat mipLevel = 0.5 * log2(d);\\n\\ treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n # define cubeUV_maxLods2(log2(cubeUV_textureSize * 0.25) - 2.0)\\ n # define cubeUV_rcpTextureSize(1.0 / cubeUV_textureSize)\\ nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\\ tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\\ tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\\ tvec2 exp2_packed = exp2(vec2(roughnessLevel, mipLevel));\\n\\ tvec2 rcp_exp2_packed = vec2(1.0) / exp2_packed;\\n\\ tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\\ tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\\ tfloat mipOffset = 0.75 * (1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\\ tbool bRes = mipLevel == 0.0;\\n\\ tscale = bRes && (scale < a) ? a : scale;\\n\\ tvec3 r;\\n\\ tvec2 offset;\\n\\ tint face = getFaceFromDirection(direction);\\n\\ tfloat rcpPowScale = 1.0 / powScale;\\n\\ tif(face == 0) {\\n\\ t\\ tr = vec3(direction.x, -direction.z, direction.y);\\n\\ t\\ toffset = vec2(0.0 + mipOffset, 0.75 * rcpPowScale);\\n\\ t\\ toffset.y = bRes && (offset.y < 2.0 * a) ? a : offset.y;\\n\\ t}\\n\\ telseif (face == 1) {\\n\\ t\\ tr = vec3(direction.y, direction.x, direction.z);\\n\\ t\\ toffset = vec2(scale + mipOffset, 0.75 * rcpPowScale);\\n\\ t\\ toffset.y = bRes && (offset.y < 2.0 * a) ? a : offset.y;\\n\\ t}\\n\\ telseif (face == 2) {\\n\\ t\\ tr = vec3(direction.z, direction.x, direction.y);\\n\\ t\\ toffset = vec2(2.0 * scale + mipOffset, 0.75 * rcpPowScale);\\n\\ t\\ toffset.y = bRes && (offset.y < 2.0 * a) ? a : offset.y;\\n\\ t}\\n\\ telseif (face == 3) {\\n\\ t\\ tr = vec3(direction.x, direction.z, direction.y);\\n\\ t\\ toffset = vec2(0.0 + mipOffset, 0.5 * rcpPowScale);\\n\\ t\\ toffset.y = bRes && (offset.y < 2.0 * a) ? 0.0 : offset.y;\\n\\ t}\\n\\ telseif (face == 4) {\\n\\ t\\ tr = vec3(direction.y, direction.x, -direction.z);\\n\\ t\\ toffset = vec2(scale + mipOffset, 0.5 * rcpPowScale);\\n\\ t\\ toffset.y = bRes && (offset.y < 2.0 * a) ? 0.0 : offset.y;\\n\\ t}\\n\\ telse {\\n\\ t\\ tr = vec3(direction.z, -direction.x, direction.y);\\n\\ t\\ toffset = vec2(2.0 * scale + mipOffset, 0.5 * rcpPowScale);\\n\\ t\\ toffset.y = bRes && (offset.y < 2.0 * a) ? 0.0 : offset.y;\\n\\ t}\\n\\ tr = normalize(r);\\n\\ tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\\ tvec2 s = (r.yz / abs(r.x) + vec2(1.0)) * 0.5;\\n\\ tvec2 base = offset + vec2(texelOffset);\\n\\ treturn base + s * (scale - 2.0 * texelOffset);\\n}\\n # define cubeUV_maxLods3(log2(cubeUV_textureSize * 0.25) - 3.0)\\ nvec4 textureCubeUV(vec3 reflectedDirection, float roughness) {\\n\\ tfloat roughnessVal = roughness * cubeUV_maxLods3;\\n\\ tfloat r1 = floor(roughnessVal);\\n\\ tfloat r2 = r1 + 1.0;\\n\\ tfloat t = fract(roughnessVal);\\n\\ tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\\ tfloat s = mipInfo.y;\\n\\ tfloat level0 = mipInfo.x;\\n\\ tfloat level1 = level0 + 1.0;\\n\\ tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\\ tlevel0 += min(floor(s + 0.5), 5.0);\\n\\ tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\\ tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\\ tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\\ tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\\ tvec4 result = mix(color10, color20, t);\\n\\ treturn vec4(result.rgb, 1.0);\\n}\\n # endif\\ n "
},
Tn3k: function(t, e, n) {
    "use strict ";
    e.a = "\\nGeometricContext geometry;\\ngeometry.position = -vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize(vViewPosition);\\nIncidentLight directLight;\\n #if (NUM_POINT_LIGHTS > 0) && defined(RE_Direct)\\ n\\ tPointLight pointLight;\\n\\ tfor(int i = 0; i < NUM_POINT_LIGHTS; i++) {\\n\\ t\\ tpointLight = pointLights[i];\\n\\ t\\ tgetPointDirectLightIrradiance(pointLight, geometry, directLight);\\n\\ t\\ t # ifdef USE_SHADOWMAP\\ n\\ t\\ tdirectLight.color *= all(bvec2(pointLight.shadow, directLight.visible)) ? getPointShadow(pointShadowMap[i], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[i]) : 1.0;\\n\\ t\\ t # endif\\ n\\ t\\ tRE_Direct(directLight, geometry, material, reflectedLight);\\n\\ t}\\n # endif\\ n #if (NUM_SPOT_LIGHTS > 0) && defined(RE_Direct)\\ n\\ tSpotLight spotLight;\\n\\ tfor(int i = 0; i < NUM_SPOT_LIGHTS; i++) {\\n\\ t\\ tspotLight = spotLights[i];\\n\\ t\\ tgetSpotDirectLightIrradiance(spotLight, geometry, directLight);\\n\\ t\\ t # ifdef USE_SHADOWMAP\\ n\\ t\\ tdirectLight.color *= all(bvec2(spotLight.shadow, directLight.visible)) ? getShadow(spotShadowMap[i], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[i]) : 1.0;\\n\\ t\\ t # endif\\ n\\ t\\ tRE_Direct(directLight, geometry, material, reflectedLight);\\n\\ t}\\n # endif\\ n #if (NUM_DIR_LIGHTS > 0) && defined(RE_Direct)\\ n\\ tDirectionalLight directionalLight;\\n\\ tfor(int i = 0; i < NUM_DIR_LIGHTS; i++) {\\n\\ t\\ tdirectionalLight = directionalLights[i];\\n\\ t\\ tgetDirectionalDirectLightIrradiance(directionalLight, geometry, directLight);\\n\\ t\\ t # ifdef USE_SHADOWMAP\\ n\\ t\\ tdirectLight.color *= all(bvec2(directionalLight.shadow, directLight.visible)) ? getShadow(directionalShadowMap[i], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[i]) : 1.0;\\n\\ t\\ t # endif\\ n\\ t\\ tRE_Direct(directLight, geometry, material, reflectedLight);\\n\\ t}\\n # endif\\ n #if (NUM_RECT_AREA_LIGHTS > 0) && defined(RE_Direct_RectArea)\\ n\\ tRectAreaLight rectAreaLight;\\n\\ tfor(int i = 0; i < NUM_RECT_AREA_LIGHTS; i++) {\\n\\ t\\ trectAreaLight = rectAreaLights[i];\\n\\ t\\ tRE_Direct_RectArea(rectAreaLight, geometry, material, reflectedLight);\\n\\ t}\\n # endif\\ n #if defined(RE_IndirectDiffuse)\\ n\\ tvec3 irradiance = getAmbientLightIrradiance(ambientLightColor);\\n\\ t # ifdef USE_LIGHTMAP\\ n\\ t\\ tvec3 lightMapIrradiance = texture2D(lightMap, vUv2).xyz * lightMapIntensity;\\n\\ t\\ t # ifndef PHYSICALLY_CORRECT_LIGHTS\\ n\\ t\\ t\\ tlightMapIrradiance *= PI;\\n\\ t\\ t # endif\\ n\\ t\\ tirradiance += lightMapIrradiance;\\n\\ t # endif\\ n\\ t #if (NUM_HEMI_LIGHTS > 0)\\ n\\ t\\ tfor(int i = 0; i < NUM_HEMI_LIGHTS; i++) {\\n\\ t\\ t\\ tirradiance += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\\n\\ t\\ t}\\n\\ t # endif\\ n\\ t #if defined(USE_ENVMAP) && defined(PHYSICAL) && defined(ENVMAP_TYPE_CUBE_UV)\\ n\\ t\\ tirradiance += getLightProbeIndirectIrradiance(geometry, 8);\\n\\ t # endif\\ n\\ tRE_IndirectDiffuse(irradiance, geometry, material, reflectedLight);\\n # endif\\ n #if defined(USE_ENVMAP) && defined(RE_IndirectSpecular)\\ n\\ tvec3 radiance = getLightProbeIndirectRadiance(geometry, Material_BlinnShininessExponent(material), 8);\\n\\ t # ifndef STANDARD\\ n\\ t\\ tvec3 clearCoatRadiance = getLightProbeIndirectRadiance(geometry, Material_ClearCoat_BlinnShininessExponent(material), 8);\\n\\ t #else\\ n\\ t\\ tvec3 clearCoatRadiance = vec3(0.0);\\n\\ t # endif\\ n\\ tRE_IndirectSpecular(radiance, clearCoatRadiance, geometry, material, reflectedLight);\\n # endif\\ n "
},
Sphere: function(t, e, n) {
    "use strict ";
    function Sphere(t, e) {
        this.center = undefined !== t ? t: new a.a,
        this.radius = undefined !== e ? e: 0
    }
    n.d(e, "a ",
    function() {
        return Sphere
    });
    var r = n(" + WEs "),
    a = n("Vector3 ");
    Object.assign(i.prototype, {
        set: function(t, e) {
            return this.center.copy(t),
            this.radius = e,
            this
        },
        setFromPoints: function() {
            var t;
            return function(e, n) {
                undefined === t && (t = new r.a);
                var i = this.center;
                undefined !== n ? i.copy(n) : t.setFromPoints(e).getCenter(i);
                for (var a = 0,
                o = 0,
                s = e.length; o < s; o++) a = Math.max(a, i.distanceToSquared(e[o]));
                return this.radius = Math.sqrt(a),
                this
            }
        } (),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.center.copy(t.center),
            this.radius = t.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(t) {
            return t.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        },
        intersectsBox: function(t) {
            return t.intersectsSphere(this)
        },
        intersectsPlane: function(t) {
            return Math.abs(this.center.dot(t.normal) - t.constant) <= this.radius
        },
        clampPoint: function(t, e) {
            var n = this.center.distanceToSquared(t),
            i = e || new a.a;
            return i.copy(t),
            n > this.radius * this.radius && (i.sub(this.center).normalize(), i.multiplyScalar(this.radius).add(this.center)),
            i
        },
        getBoundingBox: function(t) {
            var e = t || new r.a;
            return e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e
        },
        applyMatrix4: function(t) {
            return this.center.applyMatrix4(t),
            this.radius = this.radius * t.getMaxScaleOnAxis(),
            this
        },
        translate: function(t) {
            return this.center.add(t),
            this
        },
        equals: function(t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    })
},
UCtH: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return r
    });
    var i = n("F0 + n "),
    r = function() {
        function t(t) {
            this.objects = new i.a(t)
        }
        return t.prototype.dispose = function() {
            this.objects.forEach(function(t) {
                t._egsObjId = undefined,
                t._egsFragIds = undefined
            })
        },
        t.prototype.reset = function() {
            this.objects.reset()
        },
        t.prototype.addObject = function(t) {
            var e = this.objects.addItemNoduplicate(t);
            return - 1 !== e && (t._egsObjId = e),
            t._egsObjId
        },
        t.prototype.removeObject = function(t) {
            undefined !== t._egsObjId && (this.objects.removeItem(t, t._egsObjId), t._egsObjId = undefined)
        },
        t.prototype.findObject = function(t) {
            return this.objects.data[t]
        },
        t
    } ()
},
RingGeometry||RingBufferGeometry: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, o, s) {
        a.a.call(this),
        this.type = "RingGeometry ",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: o,
            thetaLength: s
        },
        this.fromBufferGeometry(new r(t, e, n, i, o, s)),
        this.mergeVertices()
    }
    function r(t, e, n, i, r, a) {
        o.a.call(this),
        this.type = "RingBufferGeometry ",
        this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: r,
            thetaLength: a
        },
        t = t || 20,
        e = e || 50,
        r = undefined !== r ? r: 0,
        a = undefined !== a ? a: 2 * Math.PI,
        n = undefined !== n ? Math.max(3, n) : 8,
        i = undefined !== i ? Math.max(1, i) : 1;
        var h, l, f, p = [],
        d = [],
        m = [],
        v = [],
        g = t,
        y = (e - t) / i,
        _ = new c.a,
        x = new u.a;
        for (l = 0; l <= i; l++) {
            for (f = 0; f <= n; f++) h = r + f / n * a,
            _.x = g * Math.cos(h),
            _.y = g * Math.sin(h),
            d.push(_.x, _.y, _.z),
            m.push(0, 0, 1),
            x.x = (_.x / e + 1) / 2,
            x.y = (_.y / e + 1) / 2,
            v.push(x.x, x.y);
            g += y
        }
        for (l = 0; l < i; l++) {
            var b = l * (n + 1);
            for (f = 0; f < n; f++) {
                h = f + b;
                var w = h,
                M = h + n + 1,
                S = h + n + 2,
                E = h + 1;
                p.push(w, M, E),
                p.push(M, S, E)
            }
        }
        this.setIndex(p),
        this.addAttribute("position ", new s.b(d, 3)),
        this.addAttribute("normal ", new s.b(m, 3)),
        this.addAttribute("uv ", new s.b(v, 2))
    }
    var a = n("Geometry "),
    o = n("BufferGeometry "),
    s = n("BufferAttribute "),
    u = n("Ne + j "),
    c = n("Vector3 ");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
UI9A: function(t, e, n) {
    "use strict ";
    var i = n("K61l ");
    n.d(e, "e ",
    function() {
        return i.a
    });
    var r = n("P0pb ");
    n.d(e, "d ",
    function() {
        return r.a
    });
    var a = n("XsOC ");
    n.d(e, "a ",
    function() {
        return a.a
    });
    var o = n("uiDP ");
    n.d(e, "b ",
    function() {
        return o.a
    });
    var s = n("CJFc ");
    n.d(e, "c ",
    function() {
        return s.a
    })
},
UJyc: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return r
    });
    var i = n("8 tXX "),
    r = function() {
        function t(t, e, n) {
            var r = this;
            this.detailCullingSize = 0,
            this.dynamicCullingSizeRatio = 0,
            this.ssaoActive = false,
            this.outlineHighQuality = true,
            this.cameraInInteraction = false,
            this.needsResetDefaults = false,
            this.onRequestRender = function() {},
            this.onDynamicEnabled = function(t) { ! 0 === t && r.backupDefaults()
            },
            this.onCameraChangeStart = function() {
                r.cameraInInteraction = true
            },
            this.onCameraChangeEnd = function() {
                r.cameraInInteraction = false,
                r.needsResetDefaults = true,
                r.onRequestRender()
            },
            this._monitor = e,
            this.config = n,
            this.cameraObserver = new i.a,
            this.engine = t
        }
        return Object.defineProperty(t.prototype, "monitor ", {
            get: function() {
                return this._monitor
            },
            enumerable: true,
            configurable: true
        }),
        t.prototype.initialize = function() {
            this.cameraObserver.addEventListener("change - start ", this.onCameraChangeStart),
            this.cameraObserver.addEventListener("change - end ", this.onCameraChangeEnd),
            this.config.addValueListener("engine / dynamicOptimizer / enabled ", this.onDynamicEnabled)
        },
        t.prototype.uninitialize = function() {
            this.cameraObserver.dispose(),
            this.onRequestRender = undefined,
            this.cameraObserver.removeEventListener("change - start ", this.onCameraChangeStart),
            this.cameraObserver.removeEventListener("change - end ", this.onCameraChangeEnd),
            this.config.removeValueListener("engine / dynamicOptimizer / enabled ", this.onDynamicEnabled),
            this.cameraObserver.dispose()
        },
        t.prototype.setCamera = function(t) {
            this.cameraObserver.setCamera(t)
        },
        t.prototype.downgrade = function() {
            this.dynamicCullingSizeRatio < 1 && (this.dynamicCullingSizeRatio = this.dynamicCullingSizeRatio + .05, this.engine.detailCullingEnabled = true, this.engine.setDetailCullingSizeInPixels(this.detailCullingSize * this.dynamicCullingSizeRatio))
        },
        t.prototype.upgrade = function() {
            this.dynamicCullingSizeRatio > .05 && (this.dynamicCullingSizeRatio = this.dynamicCullingSizeRatio - .05, this.engine.detailCullingEnabled = true, this.engine.setDetailCullingSizeInPixels(this.detailCullingSize * this.dynamicCullingSizeRatio))
        },
        t.prototype.backupDefaults = function() {
            this.defaults = {
                detailCullingEnabled: this.engine.detailCullingEnabled,
                detailCullingSize: this.engine.detailCullingSize,
                outlineHighQuality: this.config.getValue("engine / outline / highQuality ", true)
            }
        },
        t.prototype.optimizeUpdate = function() {
            if (this.needsResetDefaults) return this.resetDefaults(),
            this.monitor.resetAverageFps(),
            void(this.needsResetDefaults = false);
            var t = this.monitor.getAverageFps(),
            e = this.monitor.getLastFps();
            if (t < 30) {
                if (this.ssaoEnabled && this.ssaoActive) return this.ssaoActive = false,
                void this.config.setValue("engine / ao / active ", this.ssaoActive);
                if (this.outlineModeEnabled && this.outlineHighQuality) return this.outlineHighQuality = false,
                void this.config.setValue("engine / outline / highQuality ", this.outlineHighQuality)
            }
            if (this.cameraInInteraction) {
                if (t < 20 && e < 40) return void this.downgrade();
                if (t > 35 && e > 60) return void this.upgrade()
            }
            if (t > 50 && e > 60) {
                if (this.outlineModeEnabled && !this.outlineHighQuality) return this.outlineHighQuality = true,
                void this.config.setValue("engine / outline / highQuality ", this.outlineHighQuality);
                if (this.ssaoEnabled && !this.ssaoActive) return this.ssaoActive = true,
                void this.config.setValue("engine / ao / active ", this.ssaoActive)
            }
        },
        t.prototype.resetDefaults = function() {
            undefined === this.defaults && this.backupDefaults(),
            this.ssaoEnabled && !this.ssaoActive && (this.ssaoActive = true, this.config.setValue("engine / ao / active ", true)),
            this.outlineModeEnabled && (this.config.setValue("engine / outline / highQuality ", this.defaults.outlineHighQuality), this.outlineHighQuality = this.defaults.outlineHighQuality),
            this.engine.detailCullingEnabled = this.defaults.detailCullingEnabled,
            this.engine.detailCullingSize = this.defaults.detailCullingSize,
            this.dynamicCullingSizeRatio = this.engine.detailCullingEnabled ? this.engine.detailCullingSize / this.detailCullingSize: 0
        },
        t
    } ()
},
UKz4: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return h
    });
    var i = n("BzvE "),
    r = (n.n(i), n("5 qJX ")),
    a = n("a1st "),
    o = n("Jjpd "),
    s = n("f / n6 "),
    u = n("9 qOK "),
    c = this && this.__extends ||
    function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array &&
        function(t, e) {
            t.__proto__ = e
        } ||
        function(t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        };
        return function(e, n) {
            function i() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
        }
    } (),
    h = function(t) {
        function e() {
            var e = t.call(this) || this;
            return e.sceneChanged = true,
            e.cameraChanged = true,
            e.model = new a.a,
            e.modelBuilder = new r.a(e),
            e.modelBuilder.model = e.model,
            e
        }
        return c(e, t),
        Object.defineProperty(e.prototype, "scene ", {
            get: function() {
                return this._scene
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(e.prototype, "camera ", {
            get: function() {
                return this._camera
            },
            enumerable: true,
            configurable: true
        }),
        e.prototype.setCamera = function(t) {
            undefined !== this._camera && (this._camera.sceneNode = undefined),
            undefined === t.sceneNode && (t.sceneNode = new o.a(this, t)),
            this._camera = t,
            this.model.camera = t,
            this.cameraChanged = true,
            this.emit("scenedoc - changed ")
        },
        e.prototype.setScene = function(t) {
            this._scene = t,
            this.model.scene = t,
            this.model.resetModel(),
            undefined !== this._scene && Object(u.a)(this._scene,
            function(t) {
                t.sceneNode = undefined
            }),
            this.sceneChanged = true,
            this.emit("scenedoc - changed ")
        },
        e.prototype.onObjectChanged = function(t) {
            t.isCamera ? this.cameraChanged = true : this.sceneChanged = true,
            this.emit("scenedoc - changed ")
        },
        e.prototype.onObjectRemoved = function(t) {
            this.modelBuilder.onSceneObjectRemoved(t)
        },
        e.prototype.updateScene = function() {
            undefined !== this.scene && ((this.sceneChanged || 
                this.cameraChanged) && this.modelBuilder.build(), 
            this.cameraChanged && this.model.updateFrustrum(), 
            this.sceneChanged && (this.sceneChanged = false), 
            this.cameraChanged && (this.cameraChanged = false))
        },
        e.prototype.downloadSceneData = function() {
            if(this.scene) {
                function a(t) {
                    if (undefined !== window.TextEncoder) return (new window.TextEncoder).encode(t).buffer;
                    for (var e = new ArrayBuffer(t.length), 
                        n = new Uint8Array(e), i = 0; i < t.length; ++i) n[i] = 
                        t.charCodeAt(i);
                    return e
                }
            }


            this.scene && Object(s.a)(this.scene)
        },
        e
    } (i.EventEmitter)
},
UTHa: function(t, e, n) {
    "use strict ";
    e.a = "uniform float size;\\nuniform float scale;\\n # include < common > \\n # include < color_pars_vertex > \\n # include < fog_pars_vertex > \\n # include < shadowmap_pars_vertex > \\n # include < logdepthbuf_pars_vertex > \\n # include < clipping_planes_pars_vertex > \\nvoid main() {\\n\\ t # include < color_vertex > \\n\\ t # include < begin_vertex > \\n\\ t # include < project_vertex > \\n\\ t # ifdef USE_SIZEATTENUATION\\ n\\ t\\ tgl_PointSize = size * (scale / -mvPosition.z);\\n\\ t #else\\ n\\ t\\ tgl_PointSize = size;\\n\\ t # endif\\ n\\ t # include < logdepthbuf_vertex > \\n\\ t # include < clipping_planes_vertex > \\n\\ t # include < worldpos_vertex > \\n\\ t # include < shadowmap_vertex > \\n\\ t # include < fog_vertex > \\n}\\n "
},
UoFS: function(t, e, n) {
    "use strict ";

    function i(t, e) {
        this.object = t,
        undefined === e && (e = 16776960);
        var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
        i = new Float32Array(24),
        r = new u.a;
        r.setIndex(new s.a(n, 1)),
        r.addAttribute("position ", new s.a(i, 3)),
        a.a.call(this, r, new o.a({
            color: e
        })),
        this.matrixAutoUpdate = false,
        this.update()
    }
    var r = n(" + WEs "),
    a = n("LineSegments "),
    o = n("LineBasicMaterial"),
    s = n("BufferAttribute "),
    u = n("BufferGeometry ");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    i.prototype.update = function() {
        var t = new r.a;
        return function(e) {
            if (undefined !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), undefined !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                var n = t.min,
                i = t.max,
                r = this.geometry.attributes.position,
                a = r.array;
                a[0] = i.x,
                a[1] = i.y,
                a[2] = i.z,
                a[3] = n.x,
                a[4] = i.y,
                a[5] = i.z,
                a[6] = n.x,
                a[7] = n.y,
                a[8] = i.z,
                a[9] = i.x,
                a[10] = n.y,
                a[11] = i.z,
                a[12] = i.x,
                a[13] = i.y,
                a[14] = n.z,
                a[15] = n.x,
                a[16] = i.y,
                a[17] = n.z,
                a[18] = n.x,
                a[19] = n.y,
                a[20] = n.z,
                a[21] = i.x,
                a[22] = n.y,
                a[23] = n.z,
                r.needsUpdate = true,
                this.geometry.computeBoundingSphere()
            }
        }
    } (),
    i.prototype.setFromObject = function(t) {
        return this.object = t,
        this.update(),
        this
    }
},
StereoCamera: function(t, e, n) {
    "use strict ";
    function i() {
        this.type = "StereoCamera ",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new o.a,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = false,
        this.cameraR = new o.a,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = false
    }
    var r = n("6 HoM "),
    a = n("7 MDU "),
    o = n("PerspectiveCamera ");
    Object.assign(i.prototype, {
        update: function() {
            var t, e, n, i, o, s, u, c, h = new r.a,
            l = new r.a;
            return function(r) {
                if (t !== this || e !== r.focus || n !== r.fov || i !== r.aspect * this.aspect || o !== r.near || s !== r.far || u !== r.zoom || c !== this.eyeSep) {
                    t = this,
                    e = r.focus,
                    n = r.fov,
                    i = r.aspect * this.aspect,
                    o = r.near,
                    s = r.far,
                    u = r.zoom;
                    var f = r.projectionMatrix.clone();
                    c = this.eyeSep / 2;
                    var p, d, m = c * o / e,
                    v = o * Math.tan(a.a.DEG2RAD * n * .5) / u;
                    l.elements[12] = -c,
                    h.elements[12] = c,
                    p = -v * i + m,
                    d = v * i + m,
                    f.elements[0] = 2 * o / (d - p),
                    f.elements[8] = (d + p) / (d - p),
                    this.cameraL.projectionMatrix.copy(f),
                    p = -v * i - m,
                    d = v * i - m,
                    f.elements[0] = 2 * o / (d - p),
                    f.elements[8] = (d + p) / (d - p),
                    this.cameraR.projectionMatrix.copy(f)
                }
                this.cameraL.matrixWorld.copy(r.matrixWorld).multiply(l),
                this.cameraR.matrixWorld.copy(r.matrixWorld).multiply(h)
            }
        } ()
    })
},
VAyI: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_MAP\\ n\\ tvec4 texelColor = texture2D(map, vUv);\\n\\ ttexelColor = mapTexelToLinear(texelColor);\\n\\ tdiffuseColor *= texelColor;\\n # endif\\ n "
},
Material: function(t, e, n) {
    "use strict ";
    function i() {
        Object.defineProperty(this, "id ", {
            value: s++
        }),
        this.uuid = o.a.generateUUID(),
        this.inReusedArray = false,
        this.reusedArrayIndex = -1,
        this.name = "",
        this.type = "Material ",
        this.fog = true,
        this.lights = true,
        this.blending = a._12,
        this.side = a.E,
        this.shading = a._41,
        this.vertexColors = a._10,
        this.opacity = 1,
        this.transparent = false,
        this.blendSrc = a._43,
        this.blendDst = a._17,
        this.blendEquation = a.a,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = a.O,
        this.depthTest = true,
        this.depthWrite = true,
        this.clippingPlanes = null,
        this.clipIntersection = false,
        this.clipShadows = false,
        this.colorWrite = true,
        this.precision = null,
        this.polygonOffset = false,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = false,
        this.alphaTest = 0,
        this.premultipliedAlpha = false,
        this.overdraw = 0,
        this.visible = true,
        this.needsUpdate = true
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("2 aAi "),
    a = n("RBSo "),
    o = n("7 MDU "),
    s = 0;
    Object.assign(i.prototype, r.a.prototype, {
        isMaterial: true,
        onBeforeCompile: function() {},
        setValues: function(t) {
            if (undefined !== t) {
                for (var e in t) {
                    var n = t[e];
                    if (undefined !== n) {
                        var i = this[e];
                        undefined !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = "overdraw " === e ? Number(n) : n: console.warn("THREE." + this.type + ": '" + e + "'is not a property of this material.")
                    } else console.warn("THREE.Material: '" + e + "'parameter is undefined.")
                }
            }
        },
        toJSON: function(t) {
            function e(t) {
                var e = [];
                for (var n in t) {
                    var i = t[n];
                    delete i.metadata,
                    e.push(i)
                }
                return e
            }
            var n = undefined === t;
            n && (t = {
                textures: {},
                images: {}
            });
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Material ",
                    generator: "Material.toJSON "
                }
            };
            if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), undefined !== this.roughness && (i.roughness = this.roughness), undefined !== this.metalness && (i.metalness = this.metalness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), undefined !== this.shininess && (i.shininess = this.shininess), undefined !== this.clearCoat && (i.clearCoat = this.clearCoat), undefined !== this.clearCoatRoughness && (i.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(t).uuid), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(t).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(t).uuid, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(t).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(t).uuid, i.reflectivity = this.reflectivity), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(t).uuid), undefined !== this.size && (i.size = this.size), undefined !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== a._12 && (i.blending = this.blending), this.shading !== a._41 && (i.shading = this.shading), this.side !== a.E && (i.side = this.side), this.vertexColors !== a._10 && (i.vertexColors = this.vertexColors), this.opacity < 1 && (i.opacity = this.opacity), true === this.transparent && (i.transparent = this.transparent), i.depthFunc = this.depthFunc, i.depthTest = this.depthTest, i.depthWrite = this.depthWrite, this.alphaTest > 0 && (i.alphaTest = this.alphaTest), true === this.premultipliedAlpha && (i.premultipliedAlpha = this.premultipliedAlpha), true === this.wireframe && (i.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), "round " !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap), "round " !== this.wireframeLinejoin && (i.wireframeLinejoin = this.wireframeLinejoin), i.skinning = this.skinning, i.morphTargets = this.morphTargets, i.dithering = this.dithering, n) {
                var r = e(t.textures),
                o = e(t.images);
                r.length > 0 && (i.textures = r),
                o.length > 0 && (i.images = o)
            }
            return i
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            this.name = t.name,
            this.fog = t.fog,
            this.lights = t.lights,
            this.blending = t.blending,
            this.side = t.side,
            this.shading = t.shading,
            this.vertexColors = t.vertexColors,
            this.opacity = t.opacity,
            this.transparent = t.transparent,
            this.blendSrc = t.blendSrc,
            this.blendDst = t.blendDst,
            this.blendEquation = t.blendEquation,
            this.blendSrcAlpha = t.blendSrcAlpha,
            this.blendDstAlpha = t.blendDstAlpha,
            this.blendEquationAlpha = t.blendEquationAlpha,
            this.depthFunc = t.depthFunc,
            this.depthTest = t.depthTest,
            this.depthWrite = t.depthWrite,
            this.colorWrite = t.colorWrite,
            this.precision = t.precision,
            this.polygonOffset = t.polygonOffset,
            this.polygonOffsetFactor = t.polygonOffsetFactor,
            this.polygonOffsetUnits = t.polygonOffsetUnits,
            this.dithering = t.dithering,
            this.alphaTest = t.alphaTest,
            this.premultipliedAlpha = t.premultipliedAlpha,
            this.overdraw = t.overdraw,
            this.visible = t.visible,
            this.clipShadows = t.clipShadows,
            this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes,
            n = null;
            if (null !== e) {
                var i = e.length;
                n = new Array(i);
                for (var r = 0; r !== i; ++r) {
                    n[r] = e[r].clone()
                }
            }
            return this.clippingPlanes = n,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose "
            })
        }
    })
},
VHZC: function(t, e, n) {
    "use strict ";
    e.a = "uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n # include < common > \\n # include < packing > \\n # include < clipping_planes_pars_fragment > \\nvoid main() {\\n\\ t # include < clipping_planes_fragment > \\n\\ tgl_FragColor = packDepthToRGBA(length(vWorldPosition.xyz - lightPos.xyz) / 1000.0);\\n}\\n "
},
PopModelBlock: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return i
    });
    var i = function() {
        function t(t, e, n, i) {
            this.index = t,
            this.name = e,
            this.start = n,
            this.count = i,
            this.levelFaceCounts = []
        }
        return t
    } ()
},
VMeh: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_LOGDEPTHBUF\\ n\\ t # ifdef USE_LOGDEPTHBUF_EXT\\ n\\ t\\ tvarying float vFragDepth;\\n\\ t # endif\\ n\\ tuniform float logDepthBufFC;\\n # endif "
},
VOs1: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_LOGDEPTHBUF\\ n\\ tgl_Position.z = log2(max(EPSILON, gl_Position.w + 1.0)) * logDepthBufFC;\\n\\ t # ifdef USE_LOGDEPTHBUF_EXT\\ n\\ t\\ tvFragDepth = 1.0 + gl_Position.w;\\n\\ t #else\\ n\\ t\\ tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\ t # endif\\ n # endif\\ n "
},
Vbxv: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return i
    });
    var i, r = n("RBSo "),
    a = n("4 W4M "),
    o = n("E2bl "),
    s = n("WVM5 "),
    u = n("RR + E ");
    i = {
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: r.L,
        InterpolantFactoryMethodDiscrete: function(t) {
            return new u.a(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodLinear: function(t) {
            return new s.a(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: function(t) {
            return new o.a(this.times, this.values, this.getValueSize(), t)
        },
        setInterpolation: function(t) {
            var e;
            switch (t) {
            case r.K:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
            case r.L:
                e = this.InterpolantFactoryMethodLinear;
                break;
            case r.M:
                e = this.InterpolantFactoryMethodSmooth
            }
            if (undefined === e) {
                var n = "unsupported interpolation for " + this.ValueTypeName + "keyframe track named " + this.name;
                if (undefined === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw new Error(n);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return void console.warn("THREE.KeyframeTrackPrototype: ", n)
            }
            this.createInterpolant = e
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return r.K;
            case this.InterpolantFactoryMethodLinear:
                return r.L;
            case this.InterpolantFactoryMethodSmooth:
                return r.M
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(t) {
            if (0 !== t) {
                for (var e = this.times,
                n = 0,
                i = e.length; n !== i; ++n) {
                    e[n] += t;
                }
            }
            return this
        },
        scale: function(t) {
            if (1 !== t) {
                for (var e = this.times,
                n = 0,
                i = e.length; n !== i; ++n) {
                    e[n] *= t;
                }
            }
            return this
        },
        trim: function(t, e) {
            for (var n = this.times,
            i = n.length,
            r = 0,
            o = i - 1; r !== i && n[r] < t;) {++r;
            }
            for (; - 1 !== o && n[o] > e;) {--o;
            }
            if (++o, 0 !== r || o !== i) {
                r >= o && (o = Math.max(o, 1), r = o - 1);
                var s = this.getValueSize();
                this.times = a.a.arraySlice(n, r, o),
                this.values = a.a.arraySlice(this.values, r * s, o * s)
            }
            return this
        },
        validate: function() {
            var t = true,
            e = this.getValueSize();
            e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrackPrototype: Invalid value size in track.}}}", this), t = false);
            var n = this.times,
            i = this.values,
            r = n.length;
            0 === r && (console.error("THREE.KeyframeTrackPrototype: Track is empty.", this), t = false);
            for (var o = null,
            s = 0; s !== r; s++) {
                var u = n[s];
                if ("number " == typeof u && isNaN(u)) {
                    console.error("THREE.KeyframeTrackPrototype: Time is not a valid number.", this, s, u),
                    t = false;
                    break
                }
                if (null !== o && o > u) {
                    console.error("THREE.KeyframeTrackPrototype: Out of order keys.", this, s, u, o),
                    t = false;
                    break
                }
                o = u
            }
            if (undefined !== i && a.a.isTypedArray(i)) {
                for (var s = 0,
                c = i.length; s !== c; ++s) {
                    var h = i[s];
                    if (isNaN(h)) {
                        console.error("THREE.KeyframeTrackPrototype: Value is not a valid number.", this, s, h),
                        t = false;
                        break
                    }
                }
            }
            return t
        },
        optimize: function() {
            for (var t = this.times,
            e = this.values,
            n = this.getValueSize(), i = this.getInterpolation() === r.M, o = 1, s = t.length - 1, u = 1; u < s; ++u) {
                var c = false,
                h = t[u];
                if (h !== t[u + 1] && (1 !== u || h !== h[0])) if (i) {
                    c = true;
                } else {
                    for (var l = u * n,
                    f = l - n,
                    p = l + n,
                    d = 0; d !== n; ++d) {
                        var m = e[l + d];
                        if (m !== e[f + d] || m !== e[p + d]) {
                            c = true;
                            break
                        }
                    }
                }

                if (c) {
                    if (u !== o) {
                        t[o] = t[u];
                        for (var v = u * n,
                        g = o * n,
                        d = 0; d !== n; ++d) e[g + d] = e[v + d]
                    }++o
                }
            }
            if (s > 0) {
                t[o] = t[s];
                for (var v = s * n,
                g = o * n,
                d = 0; d !== n; ++d) {
                    e[g + d] = e[v + d];
                }++o
            }
            return o !== t.length && (this.times = a.a.arraySlice(t, 0, o), this.values = a.a.arraySlice(e, 0, o * n)),
            this
        }
    }
},
"}W6T / ": function(t, e, n) {
    "use strict ";
    function i(t, e) {
        this.name = "",
        this.color = new r.a(t),
        this.density = undefined !== e ? e: 25e-5
    }
    var r = n("Color ");
    i.prototype.isFogExp2 = true,
    i.prototype.clone = function() {
        return new i(this.color.getHex(), this.density)
    },
    i.prototype.toJSON = function(t) {
        return {
            type: "FogExp2 ",
            color: this.color.getHex(),
            density: this.density
        }
    }
},
PopGeometry: function(t, model, n) {
    "use strict ";
    var i = n("PopModel "),
    r = n("PopModelBlock "),
    a = function(t) {
            function e(model) {
                var n = t.call(this) || this;
                return n.isPopGeometry = true,
                n.setModel(model),
                n
            }
            return r(model, t),
            e.prototype.setModel = function(model) {
                var e = this;
                model && (this.model = model, 
                    this.setIndex(new new BufferAttribute(model.indices, 1, false)), 
                    this.addAttribute("uv", new BufferAttribute(model.textures, 2, false)), 
                    this.addAttribute("normal", new BufferAttribute(model.normals, 3, false)), 
                    this.addAttribute("position", new BufferAttribute(model.vertices, 3, false)), 
                    model.blocks.forEach(function(t) {
                    return e.addGroup(t.start, t.count, t.index)
                    }), 
                    this.computeBoundingBox(), this.computeMetadata())
            },
            e.prototype.computeMetadata = function() {
                var t = this.model.attributes,
                e = (new i.J).copy(t.boxMin),
                n = this.boundingBox.getSize().length(),
                r = t.vertexGridSize,
                a = e.clone().addScalar(.5 * r);
                this.metadata = {
                    boxMin: e,
                    boxSizeMagnitude: n,
                    vertexGridSize: r,
                    vertexConstant: a
                }
            },
            e.prototype.addGroup = function(t, e, n) {
                this.groups.push({
                    start: t,
                    count: e,
                    index: this.groups.length,
                    materialIndex: undefined !== n ? n: 0
                })
            },
            e.prototype.copy = function(e) {
                return t.prototype.copy.call(this, e),
                this.model = e.model,
                this.metadata = e.metadata,
                this
            },
            e.prototype.clone = function() {
                return (new e).copy(this)
            },
            e.prototype.toJSON = function() {
                var t = {
                    metadata: {
                        version: 4.5,
                        type: "PopGeometry",
                        generator: "PopGeometry.toJSON"
                    }
                },
                e = this.model,
                n = {
                    version: e.version,
                    attributes: e.attributes,
                    indices: Uint32Array,
                    vertices: [],
                    normals: [],
                    textures: [],
                    blocks: e.blocks,
                    levelPrecisions: e.levelPrecisions,
                    currentVertexCount: e.currentVertexCount,
                    currentBlockFaceCounts: e.currentBlockFaceCounts
                };
                return n.uuid = this.uuid,
                n.verticesDataLength = this.model.vertices.byteLength,
                n.normalDataLength = this.model.normals.byteLength,
                n.uvDataLength = this.model.textures.byteLength,
                n.indexDataLength = this.model.indices.byteLength,
                this.model.indices.byteLength / this.model.indices.length == 4 
                ? n.indexFormat = "32": n.indexFormat = "16",
                t.model = n,
                t.model
            },
            e
        } (i.e),
    o = n("PopMesh "),
    s = n("PopPhongMaterial ");
    n.d(e, "c ",
    function() {
        return i.a
    }),
    n.d(e, "d ",
    function() {
        return r.a
    }),
    n.d(e, "b ",
    function() {
        return PopMesh()
    }),
    n.d(e, "a ",
    function() {
        return a.a
    }),
    n.d(e, "e ",
    function() {
        //PopPhongMaterial
        return s.a
    })
},
WMvH: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        function n(t) {
            var n = t.skeleton,
            i = n.bones;
            if (e.floatVertexTextures) return 1024;
            var r = e.maxVertexUniforms,
            a = Math.floor((r - 20) / 4),
            o = Math.min(a, i.length);
            return o < i.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + i.length + "bones.This GPU supports " + o + "."), 0) : o
        }
        function i(t, e) {
            var n;
            return t ? t.isTexture ? n = t.encoding: t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don 't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = r.P,
            n === r.P && e && (n = r.F),
            n
        }
        var o = [],
        s = {
            MeshDepthMaterial: "depth",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points"
        },
        u = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];
        this.getParameters = function(a, o, u, c, h, l) {
            var f = s[a.type],
            p = l.isSkinnedMesh ? n(l) : 0,
            d = t.getPrecision();
            null !== a.precision && (d = e.getMaxPrecision(a.precision)) !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", d, "instead.");
            var m = t.getRenderTarget();
            return {
                shaderID: f,
                precision: d,
                supportsVertexTextures: e.vertexTextures,
                outputEncoding: i(m ? m.texture: null, t.gammaOutput),
                map: !!a.map,
                mapEncoding: i(a.map, t.gammaInput),
                envMap: !!a.envMap,
                envMapMode: a.envMap && a.envMap.mapping,
                envMapEncoding: i(a.envMap, t.gammaInput),
                envMapCubeUV: !!a.envMap && (a.envMap.mapping === r.m || a.envMap.mapping === r.n),
                lightMap: !!a.lightMap,
                aoMap: !!a.aoMap,
                emissiveMap: !!a.emissiveMap,
                emissiveMapEncoding: i(a.emissiveMap, t.gammaInput),
                bumpMap: !!a.bumpMap,
                normalMap: !!a.normalMap,
                displacementMap: !!a.displacementMap,
                roughnessMap: !!a.roughnessMap,
                metalnessMap: !!a.metalnessMap,
                specularMap: !!a.specularMap,
                alphaMap: !!a.alphaMap,
                gradientMap: !!a.gradientMap,
                combine: a.combine,
                vertexColors: a.vertexColors,
                fog: !!u,
                useFog: a.fog,
                fogExp: u && u.isFogExp2,
                flatShading: a.shading === r.B,
                sizeAttenuation: a.sizeAttenuation,
                logarithmicDepthBuffer: e.logarithmicDepthBuffer,
                skinning: a.skinning && p > 0,
                maxBones: p,
                useVertexTexture: e.floatVertexTextures,
                morphTargets: a.morphTargets,
                morphNormals: a.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: o.directional.length,
                numPointLights: o.point.length,
                numSpotLights: o.spot.length,
                numRectAreaLights: o.rectArea.length,
                numHemiLights: o.hemi.length,
                numClippingPlanes: c,
                numClipIntersection: h,
                dithering: a.dithering,
                shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && o.shadows.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: t.toneMapping,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: a.premultipliedAlpha,
                alphaTest: a.alphaTest,
                doubleSided: a.side === r.u,
                flipSided: a.side === r.f,
                depthPacking: undefined !== a.depthPacking && a.depthPacking
            }
        },
        this.getProgramCode = function(e, n) {
            var i = [];
            if (n.shaderID ? i.push(n.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), undefined !== e.defines) for (var r in e.defines) i.push(r),
            i.push(e.defines[r]);
            for (var a = 0; a < u.length; a++) {
                i.push(n[u[a]]);
            }
            return i.push(e.onBeforeCompile.toString()),
            i.push(t.gammaOutput),
            i.join()
        },
        this.acquireProgram = function(e, n, i, r) {
            for (var s, u = 0,
            c = o.length; u < c; u++) {
                var h = o[u];
                if (h.code === r) {
                    s = h,
                    ++s.usedTimes;
                    break
                }
            }
            return undefined === s && (s = new a.a(t, r, e, n, i), o.push(s)),
            s
        },
        this.releaseProgram = function(t) {
            if (0 == --t.usedTimes) {
                var e = o.indexOf(t);
                o[e] = o[o.length - 1],
                o.pop(),
                t.destroy()
            }
        },
        this.programs = o
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("RBSo"),
    a = n("opdS")
},
WVM5: function(t, e, n) {
    "use strict";
    function i(t, e, n, i) {
        r.a.call(this, t, e, n, i)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("R+5/");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        interpolate_: function(t, e, n, i) {
            for (var r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            u = s - o,
            c = (n - e) / (i - e), h = 1 - c, l = 0; l !== o; ++l) {
                r[l] = a[u + l] * h + a[s + l] * c;
            }
            return r
        }
    })
},
WkCo: function(t, e, n) {
    "use strict";
    e.a = "varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <skinbase_vertex>\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\tvWorldPosition = worldPosition;\\n}\\n"
},
WqzK: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return ae
    });
    var i = n("2xD/"),
    r = n("bKOQ"),
    a = n("tjQS"),
    o = n("dlbA"),
    s = n("qtbg"),
    u = n("y6cm"),
    c = n("fxIi"),
    h = n("FxUv"),
    l = n("PV76"),
    f = n("TaIP"),
    p = n("RcPT"),
    d = n("Zp2z"),
    m = n("w9Z8"),
    v = n("fURu"),
    g = n("86kX"),
    y = n("7wWY"),
    _ = n("Q3nw"),
    x = n("RciL"),
    b = n("TkQk"),
    w = n("RdND"),
    M = n("xKwM"),
    S = n("4fHl"),
    E = n("9Lg+"),
    T = n("rt/V"),
    A = n("NsZI"),
    C = n("4X5t"),
    P = n("B0Bi"),
    L = n("ne5W"),
    R = n("GGw+"),
    I = n("TSrf"),
    O = n("yx72"),
    N = n("m6X9"),
    D = n("yIBW"),
    U = n("cOAL"),
    B = n("2QWY"),
    z = n("qavu"),
    F = n("lUpZ"),
    j = n("oTdC"),
    k = n("Ylfq"),
    V = n("eW7G"),
    G = n("9F77"),
    H = n("fd64"),
    W = n("Cd7q"),
    X = n("Tn3k"),
    q = n("XlHL"),
    Y = n("hBBe"),
    Z = n("VMeh"),
    J = n("VOs1"),
    Q = n("VAyI"),
    K = n("RUnA"),
    $ = n("L5nJ"),
    tt = n("MfHs"),
    et = n("mdoh"),
    nt = n("Nxbn"),
    it = n("Fs5Y"),
    rt = n("MKtO"),
    at = n("A9tL"),
    ot = n("r1Tu"),
    st = n("d9r+"),
    ut = n("lt3h"),
    ct = n("J08l"),
    ht = n("Fp3w"),
    lt = n("QSwz"),
    ft = n("5f+G"),
    pt = n("v0yF"),
    dt = n("+Czl"),
    mt = n("oYVd"),
    vt = n("yZzt"),
    gt = n("SnSb"),
    yt = n("nxaU"),
    _t = n("BP0C"),
    xt = n("0opt"),
    bt = n("fUup"),
    wt = n("QC0l"),
    Mt = n("+mP+"),
    St = n("cmAo"),
    Et = n("a1qK"),
    Tt = n("dM8i"),
    At = n("MtLI"),
    Ct = n("NfZ/"),
    Pt = n("4idU"),
    Lt = n("ShDi"),
    Rt = n("EfZs"),
    It = n("3O7r"),
    Ot = n("Qlzl"),
    Nt = n("HQOz"),
    Dt = n("8PuR"),
    Ut = n("A/ey"),
    Bt = n("qlS9"),
    zt = n("BmNd"),
    Ft = n("VHZC"),
    jt = n("WkCo"),
    kt = n("qIOK"),
    Vt = n("Lh+4"),
    Gt = n("x5fO"),
    Ht = n("ksn3"),
    Wt = n("hcH7"),
    Xt = n("vrbZ"),
    qt = n("y5LD"),
    Yt = n("DsDr"),
    Zt = n("JLlh"),
    Jt = n("4ywI"),
    Qt = n("OFyc"),
    Kt = n("0CTy"),
    $t = n("I87F"),
    te = n("jv1p"),
    ee = n("9ZQ+"),
    ne = n("UTHa"),
    ie = n("oaXl"),
    re = n("ZRMy"),
    ae = {
        alphamap_fragment: i.a,
        alphamap_pars_fragment: r.a,
        alphatest_fragment: a.a,
        aomap_fragment: o.a,
        aomap_pars_fragment: s.a,
        begin_vertex: u.a,
        beginnormal_vertex: c.a,
        bsdfs: h.a,
        bumpmap_pars_fragment: l.a,
        clipping_planes_fragment: f.a,
        clipping_planes_pars_fragment: p.a,
        clipping_planes_pars_vertex: d.a,
        clipping_planes_vertex: m.a,
        color_fragment: v.a,
        color_pars_fragment: g.a,
        color_pars_vertex: y.a,
        color_vertex: _.a,
        common: x.a,
        cube_uv_reflection_fragment: b.a,
        defaultnormal_vertex: w.a,
        displacementmap_pars_vertex: M.a,
        displacementmap_vertex: S.a,
        emissivemap_fragment: E.a,
        emissivemap_pars_fragment: T.a,
        encodings_fragment: A.a,
        encodings_pars_fragment: C.a,
        envmap_fragment: P.a,
        envmap_pars_fragment: L.a,
        envmap_pars_vertex: R.a,
        envmap_vertex: I.a,
        fog_vertex: O.a,
        fog_pars_vertex: N.a,
        fog_fragment: D.a,
        fog_pars_fragment: U.a,
        gradientmap_pars_fragment: B.a,
        lightmap_fragment: z.a,
        lightmap_pars_fragment: F.a,
        lights_lambert_vertex: j.a,
        lights_pars: k.a,
        lights_phong_fragment: V.a,
        lights_phong_pars_fragment: G.a,
        lights_physical_fragment: H.a,
        lights_physical_pars_fragment: W.a,
        lights_template: X.a,
        logdepthbuf_fragment: q.a,
        logdepthbuf_pars_fragment: Y.a,
        logdepthbuf_pars_vertex: Z.a,
        logdepthbuf_vertex: J.a,
        map_fragment: Q.a,
        map_pars_fragment: K.a,
        map_particle_fragment: $.a,
        map_particle_pars_fragment: tt.a,
        metalnessmap_fragment: et.a,
        metalnessmap_pars_fragment: nt.a,
        morphnormal_vertex: it.a,
        morphtarget_pars_vertex: rt.a,
        morphtarget_vertex: at.a,
        normal_flip: ot.a,
        normal_fragment: st.a,
        normalmap_pars_fragment: ut.a,
        packing: ct.a,
        premultiplied_alpha_fragment: ht.a,
        project_vertex: lt.a,
        dithering_fragment: ft.a,
        dithering_pars_fragment: pt.a,
        roughnessmap_fragment: dt.a,
        roughnessmap_pars_fragment: mt.a,
        shadowmap_pars_fragment: vt.a,
        shadowmap_pars_vertex: gt.a,
        shadowmap_vertex: yt.a,
        shadowmask_pars_fragment: _t.a,
        skinbase_vertex: xt.a,
        skinning_pars_vertex: bt.a,
        skinning_vertex: wt.a,
        skinnormal_vertex: Mt.a,
        specularmap_fragment: St.a,
        specularmap_pars_fragment: Et.a,
        tonemapping_fragment: Tt.a,
        tonemapping_pars_fragment: At.a,
        uv_pars_fragment: Ct.a,
        uv_pars_vertex: Pt.a,
        uv_vertex: Lt.a,
        uv2_pars_fragment: Rt.a,
        uv2_pars_vertex: It.a,
        uv2_vertex: Ot.a,
        worldpos_vertex: Nt.a,
        cube_frag: Dt.a,
        cube_vert: Ut.a,
        depth_frag: Bt.a,
        depth_vert: zt.a,
        distanceRGBA_frag: Ft.a,
        distanceRGBA_vert: jt.a,
        equirect_frag: kt.a,
        equirect_vert: Vt.a,
        linedashed_frag: Gt.a,
        linedashed_vert: Ht.a,
        meshbasic_frag: Wt.a,
        meshbasic_vert: Xt.a,
        meshlambert_frag: qt.a,
        meshlambert_vert: Yt.a,
        meshphong_frag: Zt.a,
        meshphong_vert: Jt.a,
        meshphysical_frag: Qt.a,
        meshphysical_vert: Kt.a,
        normal_frag: $t.a,
        normal_vert: te.a,
        points_frag: ee.a,
        points_vert: ne.a,
        shadow_frag: ie.a,
        shadow_vert: re.a
    }
},
XAHe: function(t, e, n) {
    "use strict";
    function i() {
        r.a.call(this),
        this.curves = [],
        this.autoClose = false
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Lk8y"),
    a = n("Vector3"),
    o = n("Geometry"),
    s = n("+Ro2");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        add: function(t) {
            this.curves.push(t)
        },
        closePath: function() {
            var t = this.curves[0].getPoint(0),
            e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new s.a(e, t))
        },
        getPoint: function(t) {
            for (var e = t * this.getLength(), n = this.getCurveLengths(), i = 0; i < n.length;) {
                if (n[i] >= e) {
                    var r = n[i] - e,
                    a = this.curves[i],
                    o = a.getLength(),
                    s = 0 === o ? 0 : 1 - r / o;
                    return a.getPointAt(s)
                }
                i++
            }
            return null
        },
        getLength: function() {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = true,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var t = [], e = 0, n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(),
            t.push(e);
            return this.cacheLengths = t,
            t
        },
        getSpacedPoints: function(t) {
            undefined === t && (t = 40);
            for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]),
            e
        },
        getPoints: function(t) {
            t = t || 12;
            for (var e, n = [], i = 0, r = this.curves; i < r.length; i++) for (var a = r[i], o = a && a.isEllipseCurve ? 2 * t: a && a.isLineCurve ? 1 : a && a.isSplineCurve ? t * a.points.length: t, s = a.getPoints(o), u = 0; u < s.length; u++) {
                var c = s[u];
                e && e.equals(c) || (n.push(c), e = c)
            }
            return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]),
            n
        },
        createPointsGeometry: function(t) {
            var e = this.getPoints(t);
            return this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(t) {
            var e = this.getSpacedPoints(t);
            return this.createGeometry(e)
        },
        createGeometry: function(t) {
            for (var e = new o.a,
            n = 0,
            i = t.length; n < i; n++) {
                var r = t[n];
                e.vertices.push(new a.a(r.x, r.y, r.z || 0))
            }
            return e
        }
    })
},
XEJx: function(t, e, n) {
    "use strict";
    e.a = "#define NORMAL\\n#if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP)\\nvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\nvarying vec3 vNormal;\\n#endif\\n#include <bumpmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <packing>\\n#include <uv_pars_fragment>\\nuniform vec2 id;\\nvec2 encodeViewNormalStereo(vec3 n) {\\n    float kScale = 1.7777;\\n    vec2 enc;\\n    enc = n.xy / (n.z + 1.0);\\n    enc /= kScale;\\n    enc = enc * 0.5 + 0.5;\\n    return enc;\\n}\\nvoid main() {\\n#include <logdepthbuf_fragment>\\n#include <normal_flip>\\n#include <normal_fragment>\\n    gl_FragColor = vec4(id, encodeViewNormalStereo(normal));\\n}\\n"
},
XG32: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return a
    });
    var i = n("07ZH"),
    r = this && this.__extends ||
    function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array &&
        function(t, e) {
            t.__proto__ = e
        } ||
        function(t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        };
        return function(e, n) {
            function i() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
        }
    } (),
    a = function(t) {
        function e() {
            var e = t.call(this) || this;
            return e.distance = 13e3,
            e.height = 13e3,
            e
        }
        return r(e, t),
        e.prototype.setOriginDistance = function(t) {
            this.distance = t
        },
        e.prototype.setOriginHeight = function(t) {
            this.height = t
        },
        e.prototype.activate = function(e) {
            if (undefined === e && (e = true), t.prototype.activate.call(this), e) {
                var n = this.controller.getState(),
                i = n.clone();
                i.target.copy(n.position),
                i.position.sub(n.target).normalize().multiplyScalar(this.distance).setZ(this.height).add(n.position),
                this.controller.tweenState(n, i)
            }
        },
        e.prototype.leftMouseMove = function(t) {
            this.controller.rotateAround(t)
        },
        e.prototype.RightMouseMove = function(t) {
            this.controller.move(t)
        },
        e.prototype.mouseWheel = function(t) {
            this.controller.zoom(t)
        },
        e
    } (i.a)
},
CircleGeometry||CircleBufferGeometry function(t, e, n) {
    "use strict";
    function i(t, e, n, i) {
        a.a.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        },
        this.fromBufferGeometry(new r(t, e, n, i)),
        this.mergeVertices()
    }
    function r(t, e, n, i) {
        o.a.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: i
        },
        t = t || 50,
        e = undefined !== e ? Math.max(3, e) : 8,
        n = undefined !== n ? n: 0,
        i = undefined !== i ? i: 2 * Math.PI;
        var r, a, h = [],
        l = [],
        f = [],
        p = [],
        d = new u.a,
        m = new Vector2();
        for (l.push(0, 0, 0), f.push(0, 0, 1), p.push(.5, .5), a = 0, r = 3; a <= e; a++, r += 3) {
            var v = n + a / e * i;
            d.x = t * Math.cos(v),
            d.y = t * Math.sin(v),
            l.push(d.x, d.y, d.z),
            f.push(0, 0, 1),
            m.x = (l[r] / t + 1) / 2,
            m.y = (l[r + 1] / t + 1) / 2,
            p.push(m.x, m.y)
        }
        for (r = 1; r <= e; r++) {
            h.push(r, r + 1, 0);
        }
        this.setIndex(h),
        this.addAttribute("position", new s.b(l, 3)),
        this.addAttribute("normal", new s.b(f, 3)),
        this.addAttribute("uv", new s.b(p, 2))
    }
    var a = n("Geometry"),
    o = n("BufferGeometry"),
    s = n("BufferAttribute"),
    u = n("Vector3"),
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
XJ5Z: function(t, e, n) {
    "use strict";
    function i(t) {
        this.manager = undefined !== t ? t: a.a
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("/bYS"),
    a = n("OJZr");
    Object.assign(i.prototype, {
        load: function(t, e, n, i) {
            undefined === t && (t = ""),
            undefined !== this.path && (t = this.path + t);
            var a = this,
            o = r.a.get(t);
            if (undefined !== o) return a.manager.itemStart(t),
            setTimeout(function() {
                e && e(o),
                a.manager.itemEnd(t)
            },
            0),
            o;
            var s = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return s.addEventListener("load",
            function() {
                r.a.add(t, this),
                e && e(this),
                a.manager.itemEnd(t)
            },
            false),
            s.addEventListener("error",
            function(e) {
                i && i(e),
                a.manager.itemEnd(t),
                a.manager.itemError(t)
            },
            false),
            "data:" !== t.substr(0, 5) && undefined !== this.crossOrigin && (s.crossOrigin = this.crossOrigin),
            a.manager.itemStart(t),
            s.src = t,
            s
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    })
},
XPJB: function(t, e, n) {
    "use strict";
    function i(t) {
        for (var e = t.split("\\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
        return e.join("\\n")
    }
    function r(t, e, n) {
        var r = t.createShader(e);
        return t.shaderSource(r, n),
        t.compileShader(r),
        false === t.getShaderParameter(r, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== t.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === t.VERTEX_SHADER ? "vertex ": "fragment ", t.getShaderInfoLog(r), i(n)),
        r
    }
    n.d(e, "a ",
    function() {
        return r
    })
},
BufferAttribute: function(t, e, n) {
    "use strict ";
    function BufferAttribute(t, e, n) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.uuid = g.a.generateUUID(),
        this.name = "",
        this.array = t,
        this.itemSize = e,
        this.count = undefined !== t ? t.length / e: 0,
        this.normalized = true === n,
        this.dynamic = false,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.onUploadCallback = function() {},
        this.version = 0
    }
    function r(t, e) {
        i.call(this, new Int8Array(t), e)
    }
    function a(t, e) {
        i.call(this, new Uint8Array(t), e)
    }
    function o(t, e) {
        i.call(this, new Uint8ClampedArray(t), e)
    }
    function s(t, e) {
        i.call(this, new Int16Array(t), e)
    }
    function u(t, e) {
        i.call(this, new Uint16Array(t), e)
    }
    function c(t, e) {
        i.call(this, new Int32Array(t), e)
    }
    function h(t, e) {
        i.call(this, new Uint32Array(t), e)
    }
    function l(t, e) {
        i.call(this, new Float32Array(t), e)
    }
    function f(t, e) {
        i.call(this, new Float64Array(t), e)
    }
    n.d(e, "b ",
    function() {
        return l
    }),
    n.d(e, "d ",
    function() {
        return h
    }),
    n.d(e, "c ",
    function() {
        return u
    }),
    n.d(e, "a ",
    function() {
        return BufferAttribute
    });
    var p = n("Vector4 "),
    d = n("Vector3 "),
    m = n("Ne + j "),
    v = n("Color "),
    g = n("7 MDU ");
    Object.defineProperty(i.prototype, "needsUpdate ", {
        set: function(t) { ! 0 === t && this.version++
        }
    }),
    Object.assign(i.prototype, {
        isBufferAttribute: true,
        setArray: function(t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = undefined !== t ? t.length / this.itemSize: 0,
            this.array = t
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.itemSize = t.itemSize,
            this.count = t.count,
            this.normalized = t.normalized,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.itemSize,
            n *= e.itemSize;
            for (var i = 0,
            r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        },
        copyArray: function(t) {
            return this.array.set(t),
            this
        },
        copyColorsArray: function(t) {
            for (var e = this.array,
            n = 0,
            i = 0,
            r = t.length; i < r; i++) {
                var a = t[i];
                undefined === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined ", i), a = new v.a),
                e[n++] = a.r,
                e[n++] = a.g,
                e[n++] = a.b
            }
            return this
        },
        copyIndicesArray: function(t) {
            for (var e = this.array,
            n = 0,
            i = 0,
            r = t.length; i < r; i++) {
                var a = t[i];
                e[n++] = a.a,
                e[n++] = a.b,
                e[n++] = a.c
            }
            return this
        },
        copyVector2sArray: function(t) {
            for (var e = this.array,
            n = 0,
            i = 0,
            r = t.length; i < r; i++) {
                var a = t[i];
                undefined === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined ", i), a = new m.a),
                e[n++] = a.x,
                e[n++] = a.y
            }
            return this
        },
        copyVector3sArray: function(t) {
            for (var e = this.array,
            n = 0,
            i = 0,
            r = t.length; i < r; i++) {
                var a = t[i];
                undefined === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined ", i), a = new d.a),
                e[n++] = a.x,
                e[n++] = a.y,
                e[n++] = a.z
            }
            return this
        },
        copyVector4sArray: function(t) {
            for (var e = this.array,
            n = 0,
            i = 0,
            r = t.length; i < r; i++) {
                var a = t[i];
                undefined === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined ", i), a = new p.a),
                e[n++] = a.x,
                e[n++] = a.y,
                e[n++] = a.z,
                e[n++] = a.w
            }
            return this
        },
        set: function(t, e) {
            return undefined === e && (e = 0),
            this.array.set(t, e),
            this
        },
        getX: function(t) {
            return this.array[t * this.itemSize]
        },
        setX: function(t, e) {
            return this.array[t * this.itemSize] = e,
            this
        },
        getY: function(t) {
            return this.array[t * this.itemSize + 1]
        },
        setY: function(t, e) {
            return this.array[t * this.itemSize + 1] = e,
            this
        },
        getZ: function(t) {
            return this.array[t * this.itemSize + 2]
        },
        setZ: function(t, e) {
            return this.array[t * this.itemSize + 2] = e,
            this
        },
        getW: function(t) {
            return this.array[t * this.itemSize + 3]
        },
        setW: function(t, e) {
            return this.array[t * this.itemSize + 3] = e,
            this
        },
        setXY: function(t, e, n) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t *= this.itemSize,
            this.array[t + 0] = e,
            this.array[t + 1] = n,
            this.array[t + 2] = i,
            this.array[t + 3] = r,
            this
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        },
        clone: function() {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }),
    r.prototype = Object.create(i.prototype),
    r.prototype.constructor = r,
    a.prototype = Object.create(i.prototype),
    a.prototype.constructor = a,
    o.prototype = Object.create(i.prototype),
    o.prototype.constructor = o,
    s.prototype = Object.create(i.prototype),
    s.prototype.constructor = s,
    u.prototype = Object.create(i.prototype),
    u.prototype.constructor = u,
    c.prototype = Object.create(i.prototype),
    c.prototype.constructor = c,
    h.prototype = Object.create(i.prototype),
    h.prototype.constructor = h,
    l.prototype = Object.create(i.prototype),
    l.prototype.constructor = l,
    f.prototype = Object.create(i.prototype),
    f.prototype.constructor = f
},
PopModelAttributes: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return i
    });
    var i = function() {
        function t() {}
        return t.prototype.readFromStream = function(t) {
            this.boxMax = t.readFloat3(),
            this.boxMin = t.readFloat3(),
            this.vertexGridSize = t.readSwappedFloat(),
            this.vertexRepresentBit = t.readByte3(),
            this.textureScale = t.readSwappedInt(),
            this.normalScale = t.readSwappedInt(),
            this.groupCount = t.readSwappedShort(),
            this.blockNames = JSON.parse(t.readUTFBytes(t.readSwappedInt()))
        },
        t
    } ()
},
Points: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        s.a.call(this),
        this.type = "Points ";
        var n = undefined !== t ? t: new h.a,
        i = undefined !== e ? e: new c.a({
            color: 16777215 * Math.random()
        });
        Object.defineProperties(this, {
            geometry: {
                get: function() {
                    return n
                },
                set: function(t) {
                    n = t,
                    this.setGeometryChanged()
                }
            },
            material: {
                get: function() {
                    return i
                },
                set: function(t) {
                    i = t,
                    this.setMaterialChanged()
                }
            }
        })
    }
    var r = n("Sphere "),
    a = n("6 YUT "),
    o = n("6 HoM "),
    s = n("87 g3 "),
    u = n("Vector3 "),
    c = n("PointsMaterial "),
    h = n("BufferGeometry ");
    i.prototype = Object.assign(Object.create(s.a.prototype), {
        constructor: i,
        isPoints: true,
        egsRaycast: function(t, e) {
            this.raycast(t, e)
        },
        raycast: function() {
            var t = new o.a,
            e = new a.a,
            n = new r.a;
            return function(i, r) {
                function a(t, n) {
                    var a = e.distanceSqToPoint(t);
                    if (a < f) {
                        var s = e.closestPointToPoint(t);
                        s.applyMatrix4(c);
                        var u = i.ray.origin.distanceTo(s);
                        if (u < i.near || u > i.far) {
                            return;
                        }
                        r.push({
                            distance: u,
                            distanceToRay: Math.sqrt(a),
                            point: s.clone(),
                            index: n,
                            face: null,
                            object: o
                        })
                    }
                }
                var o = this,
                s = this.geometry,
                c = this.matrixWorld,
                h = i.params.Points.threshold;
                if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(c), n.radius += h, false !== i.ray.intersectsSphere(n)) {
                    t.getInverse(c),
                    e.copy(i.ray).applyMatrix4(t);
                    var l = h / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    f = l * l,
                    p = new u.a;
                    if (s.isBufferGeometry) {
                        var d = s.index,
                        m = s.attributes,
                        v = m.position.array;
                        if (null !== d) {
                            for (var g = d.array,
                            y = 0,
                            _ = g.length; y < _; y++) {
                                var x = g[y];
                                p.fromArray(v, 3 * x),
                                a(p, x)
                            }
                        } else {
                            for (var y = 0,
                            b = v.length / 3; y < b; y++) p.fromArray(v, 3 * y),
                            a(p, y)
                        }
                    } else {
                        for (var w = s.vertices,
                        y = 0,
                        b = w.length; y < b; y++) a(w[y], y)
                    }
                }
            }
        } (),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    })
},
XlHL: function(t, e, n) {
    "use strict ";
    e.a = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\ n\\ tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n # endif "
},
XsOC: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return u
    });
    var i = n("3 JDn "),
    r = n("CNFg "),
    a = n("CJFc "),
    o = n("CPX2 "),
    s = n("XG32 "),
    u = function() {
        function t() {
            this.name = i.b.Camera,
            this.enable = true
        }
        return t.prototype.createController = function(t) {
            var e = new r.a;
            return e.setViewer(t),
            e
        },
        t.prototype.createInteractor = function(t, e) {
            var n;
            switch (e) {
            case a.a.Roamer:
                n = new o.a;
                break;
            case a.a.View3D:
                n = new s.a
            }
            return n && n.setCameraController(t),
            n
        },
        t
    } ()
},
Ylfq: function(t, e, n) {
    "use strict ";
    e.a = "uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance(const in vec3 ambientLightColor) {\\n\\ tvec3 irradiance = ambientLightColor;\\n\\ t # ifndef PHYSICALLY_CORRECT_LIGHTS\\ n\\ t\\ tirradiance *= PI;\\n\\ t # endif\\ n\\ treturn irradiance;\\n}\\n #if NUM_DIR_LIGHTS > 0\\ n\\ tstruct DirectionalLight {\\n\\ t\\ tvec3 direction;\\n\\ t\\ tvec3 color;\\n\\ t\\ tint shadow;\\n\\ t\\ tfloat shadowBias;\\n\\ t\\ tfloat shadowRadius;\\n\\ t\\ tvec2 shadowMapSize;\\n\\ t};\\n\\ tuniform DirectionalLight directionalLights[NUM_DIR_LIGHTS];\\n\\ tvoid getDirectionalDirectLightIrradiance(const in DirectionalLight directionalLight,const in GeometricContext geometry, out IncidentLight directLight) {\\n\\ t\\ tdirectLight.color = directionalLight.color;\\n\\ t\\ tdirectLight.direction = directionalLight.direction;\\n\\ t\\ tdirectLight.visible = true;\\n\\ t}\\n # endif\\ n #if NUM_POINT_LIGHTS > 0\\ n\\ tstruct PointLight {\\n\\ t\\ tvec3 position;\\n\\ t\\ tvec3 color;\\n\\ t\\ tfloat distance;\\n\\ t\\ tfloat decay;\\n\\ t\\ tint shadow;\\n\\ t\\ tfloat shadowBias;\\n\\ t\\ tfloat shadowRadius;\\n\\ t\\ tvec2 shadowMapSize;\\n\\ t};\\n\\ tuniform PointLight pointLights[NUM_POINT_LIGHTS];\\n\\ tvoid getPointDirectLightIrradiance(const in PointLight pointLight,const in GeometricContext geometry, out IncidentLight directLight) {\\n\\ t\\ tvec3 lVector = pointLight.position - geometry.position;\\n\\ t\\ tdirectLight.direction = normalize(lVector);\\n\\ t\\ tfloat lightDistance = length(lVector);\\n\\ t\\ tdirectLight.color = pointLight.color;\\n\\ t\\ tdirectLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.distance, pointLight.decay);\\n\\ t\\ tdirectLight.visible = (directLight.color != vec3(0.0));\\n\\ t}\\n # endif\\ n #if NUM_SPOT_LIGHTS > 0\\ n\\ tstruct SpotLight {\\n\\ t\\ tvec3 position;\\n\\ t\\ tvec3 direction;\\n\\ t\\ tvec3 color;\\n\\ t\\ tfloat distance;\\n\\ t\\ tfloat decay;\\n\\ t\\ tfloat coneCos;\\n\\ t\\ tfloat penumbraCos;\\n\\ t\\ tint shadow;\\n\\ t\\ tfloat shadowBias;\\n\\ t\\ tfloat shadowRadius;\\n\\ t\\ tvec2 shadowMapSize;\\n\\ t};\\n\\ tuniform SpotLight spotLights[NUM_SPOT_LIGHTS];\\n\\ tvoid getSpotDirectLightIrradiance(const in SpotLight spotLight,const in GeometricContext geometry, out IncidentLight directLight) {\\n\\ t\\ tvec3 lVector = spotLight.position - geometry.position;\\n\\ t\\ tdirectLight.direction = normalize(lVector);\\n\\ t\\ tfloat lightDistance = length(lVector);\\n\\ t\\ tfloat angleCos = dot(directLight.direction, spotLight.direction);\\n\\ t\\ tif(angleCos > spotLight.coneCos) {\\n\\ t\\ t\\ tfloat spotEffect = smoothstep(spotLight.coneCos, spotLight.penumbraCos, angleCos);\\n\\ t\\ t\\ tdirectLight.color = spotLight.color;\\n\\ t\\ t\\ tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor(lightDistance, spotLight.distance, spotLight.decay);\\n\\ t\\ t\\ tdirectLight.visible = true;\\n\\ t\\ t} else {\\n\\ t\\ t\\ tdirectLight.color = vec3(0.0);\\n\\ t\\ t\\ tdirectLight.visible = false;\\n\\ t\\ t}\\n\\ t}\\n # endif\\ n #if NUM_RECT_AREA_LIGHTS > 0\\ n\\ tstruct RectAreaLight {\\n\\ t\\ tvec3 color;\\n\\ t\\ tvec3 position;\\n\\ t\\ tvec3 halfWidth;\\n\\ t\\ tvec3 halfHeight;\\n\\ t};\\n\\ tuniform sampler2D ltcMat;\\tuniform sampler2D ltcMag;\\n\\ tuniform RectAreaLight rectAreaLights[NUM_RECT_AREA_LIGHTS];\\n # endif\\ n #if NUM_HEMI_LIGHTS > 0\\ n\\ tstruct HemisphereLight {\\n\\ t\\ tvec3 direction;\\n\\ t\\ tvec3 skyColor;\\n\\ t\\ tvec3 groundColor;\\n\\ t};\\n\\ tuniform HemisphereLight hemisphereLights[NUM_HEMI_LIGHTS];\\n\\ tvec3 getHemisphereLightIrradiance(const in HemisphereLight hemiLight,const in GeometricContext geometry) {\\n\\ t\\ tfloat dotNL = dot(geometry.normal, hemiLight.direction);\\n\\ t\\ tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\\ t\\ tvec3 irradiance = mix(hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight);\\n\\ t\\ t # ifndef PHYSICALLY_CORRECT_LIGHTS\\ n\\ t\\ t\\ tirradiance *= PI;\\n\\ t\\ t # endif\\ n\\ t\\ treturn irradiance;\\n\\ t}\\n # endif\\ n #if defined(USE_ENVMAP) && defined(PHYSICAL)\\ n\\ tvec3 getLightProbeIndirectIrradiance(const in GeometricContext geometry,const in int maxMIPLevel) {\\n\\ t\\ tvec3 worldNormal = inverseTransformDirection(geometry.normal, viewMatrix);\\n\\ t\\ t # ifdef ENVMAP_TYPE_CUBE\\ n\\ t\\ t\\ tvec3 queryVec = vec3(flipEnvMap * worldNormal.x, worldNormal.yz);\\n\\ t\\ t\\ t # ifdef TEXTURE_LOD_EXT\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = textureCubeLodEXT(envMap, queryVec, float(maxMIPLevel));\\n\\ t\\ t\\ t #else\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = textureCube(envMap, queryVec, float(maxMIPLevel));\\n\\ t\\ t\\ t # endif\\ n\\ t\\ t\\ tenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\\n\\ t\\ t # elif defined(ENVMAP_TYPE_CUBE_UV)\\ n\\ t\\ t\\ tvec3 queryVec = vec3(flipEnvMap * worldNormal.x, worldNormal.yz);\\n\\ t\\ t\\ tvec4 envMapColor = textureCubeUV(queryVec, 1.0);\\n\\ t\\ t #else\\ n\\ t\\ t\\ tvec4 envMapColor = vec4(0.0);\\n\\ t\\ t # endif\\ n\\ t\\ treturn PI * envMapColor.rgb * envMapIntensity;\\n\\ t}\\n\\ tfloat getSpecularMIPLevel(const in float blinnShininessExponent,const in int maxMIPLevel) {\\n\\ t\\ tfloat maxMIPLevelScalar = float(maxMIPLevel);\\n\\ t\\ tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2(pow2(blinnShininessExponent) + 1.0);\\n\\ t\\ treturn clamp(desiredMIPLevel, 0.0, maxMIPLevelScalar);\\n\\ t}\\n\\ tvec3 getLightProbeIndirectRadiance(const in GeometricContext geometry,const in float blinnShininessExponent,const in int maxMIPLevel) {\\n\\ t\\ t # ifdef ENVMAP_MODE_REFLECTION\\ n\\ t\\ t\\ tvec3 reflectVec = reflect(-geometry.viewDir, geometry.normal);\\n\\ t\\ t #else\\ n\\ t\\ t\\ tvec3 reflectVec = refract(-geometry.viewDir, geometry.normal, refractionRatio);\\n\\ t\\ t # endif\\ n\\ t\\ treflectVec = inverseTransformDirection(reflectVec, viewMatrix);\\n\\ t\\ tfloat specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, maxMIPLevel);\\n\\ t\\ t # ifdef ENVMAP_TYPE_CUBE\\ n\\ t\\ t\\ tvec3 queryReflectVec = vec3(flipEnvMap * reflectVec.x, reflectVec.yz);\\n\\ t\\ t\\ t # ifdef TEXTURE_LOD_EXT\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = textureCubeLodEXT(envMap, queryReflectVec, specularMIPLevel);\\n\\ t\\ t\\ t #else\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = textureCube(envMap, queryReflectVec, specularMIPLevel);\\n\\ t\\ t\\ t # endif\\ n\\ t\\ t\\ tenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\\n\\ t\\ t # elif defined(ENVMAP_TYPE_CUBE_UV)\\ n\\ t\\ t\\ tvec3 queryReflectVec = vec3(flipEnvMap * reflectVec.x, reflectVec.yz);\\n\\ t\\ t\\ tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\\ t\\ t # elif defined(ENVMAP_TYPE_EQUIREC)\\ n\\ t\\ t\\ tvec2 sampleUV;\\n\\ t\\ t\\ tsampleUV.y = saturate(reflectVec.y * 0.5 + 0.5);\\n\\ t\\ t\\ tsampleUV.x = atan(reflectVec.z, reflectVec.x) * RECIPROCAL_PI2 + 0.5;\\n\\ t\\ t\\ t # ifdef TEXTURE_LOD_EXT\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = texture2DLodEXT(envMap, sampleUV, specularMIPLevel);\\n\\ t\\ t\\ t #else\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = texture2D(envMap, sampleUV, specularMIPLevel);\\n\\ t\\ t\\ t # endif\\ n\\ t\\ t\\ tenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\\n\\ t\\ t # elif defined(ENVMAP_TYPE_SPHERE)\\ n\\ t\\ t\\ tvec3 reflectView = normalize((viewMatrix * vec4(reflectVec, 0.0)).xyz + vec3(0.0, 0.0, 1.0));\\n\\ t\\ t\\ t # ifdef TEXTURE_LOD_EXT\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = texture2DLodEXT(envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel);\\n\\ t\\ t\\ t #else\\ n\\ t\\ t\\ t\\ tvec4 envMapColor = texture2D(envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel);\\n\\ t\\ t\\ t # endif\\ n\\ t\\ t\\ tenvMapColor.rgb = envMapTexelToLinear(envMapColor).rgb;\\n\\ t\\ t # endif\\ n\\ t\\ treturn envMapColor.rgb * envMapIntensity;\\n\\ t}\\n # endif\\ n "
},
ZRMy: function(t, e, n) {
    "use strict ";
    e.a = "# include < shadowmap_pars_vertex > \\nvoid main() {\\n\\ t # include < begin_vertex > \\n\\ t # include < project_vertex > \\n\\ t # include < worldpos_vertex > \\n\\ t # include < shadowmap_vertex > \\n}\\n "
},
Zp2z: function(t, e, n) {
    "use strict ";
    e.a = "#if NUM_CLIPPING_PLANES > 0 && !defined(PHYSICAL) && !defined(PHONG)\\ n\\ tvarying vec3 vViewPosition;\\n # endif\\ n "
},
WireframeGeometry: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.type = "WireframeGeometry ";
        var e, n, i, s, u, c, h, l, f, p, d = [],
        m = [0, 0],
        v = {},
        g = ["a ", "b ", "c "];
        if (t && t.isGeometry) {
            var y = t.faces;
            for (e = 0, i = y.length; e < i; e++) {
                var _ = y[e];
                for (n = 0; n < 3; n++) h = _[g[n]],
                l = _[g[(n + 1) % 3]],
                m[0] = Math.min(h, l),
                m[1] = Math.max(h, l),
                f = m[0] + ", " + m[1],
                undefined === v[f] && (v[f] = {
                    index1: m[0],
                    index2: m[1]
                })
            }
            for (f in v) c = v[f],
            p = t.vertices[c.index1],
            d.push(p.x, p.y, p.z),
            p = t.vertices[c.index2],
            d.push(p.x, p.y, p.z)
        } else if (t && t.isBufferGeometry) {
            var x, b, w, M, S, E, T, A;
            if (p = new o.a, null !== t.index) {
                for (x = t.attributes.position, b = t.index, w = t.groups, 0 === w.length && (w = [{
                    start: 0,
                    count: b.count,
                    materialIndex: 0
                }]), s = 0, u = w.length; s < u; ++s) for (M = w[s], S = M.start, E = M.count, e = S, i = S + E; e < i; e += 3) for (n = 0; n < 3; n++) h = b.getX(e + n),
                l = b.getX(e + (n + 1) % 3),
                m[0] = Math.min(h, l),
                m[1] = Math.max(h, l),
                f = m[0] + ", " + m[1],
                undefined === v[f] && (v[f] = {
                    index1: m[0],
                    index2: m[1]
                });
                for (f in v) c = v[f],
                p.fromBufferAttribute(x, c.index1),
                d.push(p.x, p.y, p.z),
                p.fromBufferAttribute(x, c.index2),
                d.push(p.x, p.y, p.z)
            } else {
                for (x = t.attributes.position, e = 0, i = x.count / 3; e < i; e++) {
                    for (n = 0; n < 3; n++) {
                        T = 3 * e + n,
                        p.fromBufferAttribute(x, T),
                        d.push(p.x, p.y, p.z),
                        A = 3 * e + (n + 1) % 3,
                        p.fromBufferAttribute(x, A),
                        d.push(p.x, p.y, p.z)
                    }
                }
            }

        }
        this.addAttribute("position ", new a.b(d, 3))
    }
    var r = n("BufferGeometry "),
    a = n("BufferAttribute "),
    o = n("Vector3 ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
a1qK: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_SPECULARMAP\\ n\\ tuniform sampler2D specularMap;\\n # endif "
},
a1st: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return h
    });
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = n("a4Iq "),
    a = n("5 + RW "),
    o = n("8 CDu "),
    s = n("4 k0s "),
    u = n("UCtH "),
    c = n("fHG + "),
    h = function() {
        function t() {
            this.frustum = new Frustum(),
            this.projScreenMatrix = new i.p,
            this.fragments = new r.a(t.DEFAULT_CAPACITY),
            this.geometries = new a.a(t.DEFAULT_CAPACITY),
            this.materials = new s.a(t.DEFAULT_CAPACITY),
            this.objects = new u.a(t.DEFAULT_CAPACITY),
            this.lights = new o.a,
            this.sprites = new c.a
        }
        return t.prototype.dispose = function() {
            this.geometries.dispose(),
            this.materials.dispose(),
            this.objects.dispose(),
            this.lights.dispose(),
            this.sprites.dispose()
        },
        t.prototype.updateFrustrum = function() {
            undefined !== this.camera && (null === this.camera.parent && this.camera.updateMatrixWorld(false), this.projScreenMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), this.frustum.setFromMatrix(this.projScreenMatrix))
        },
        t.prototype.resetModel = function() {
            this.objects.reset(),
            this.fragments.reset(),
            this.geometries.reset(),
            this.materials.reset(),
            this.lights.reset(),
            this.sprites.reset()
        },
        t.prototype.getObject = function(t) {
            var e = this.fragments.objects[t];
            return this.objects.objects.data[e]
        },
        t.prototype.getSubMeshGroup = function(t) {
            var e = this.getObject(t),
            n = this.fragments.materialIndexs[t];
            if (e.geometry.isBufferGeometry) return e.geometry.groups[n]
        },
        t.DEFAULT_CAPACITY = 5e3,
        t
    } ()
},
a4Iq: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return r
    });
    var i = n("CustomerDefine3 "),
    r = function() {
        function t(t) {
            this.capacity = 0,
            this.numFragments = 0,
            this.tombList = [],
            this.reallocate(t)
        }
        return t.prototype.reallocate = function(t) {
            var e = new Int32Array(t),
            n = new Int32Array(t),
            r = new Int32Array(t),
            a = new Float32Array(t * i.a),
            o = new Uint8Array(t),
            s = new Int32Array(t),
            u = new Uint8Array(t);
            this.numFragments > 0 && 
            (e.set(this.geometries), n.set(this.materials), 
                r.set(this.materialIndexs), a.set(this.boxes), 
                o.set(this.visibilities), s.set(this.objects), u.set(this.tombs)),
            this.geometries = e,
            this.materials = n,
            this.materialIndexs = r,
            this.boxes = a,
            this.capacity = t,
            this.visibilities = o,
            this.objects = s,
            this.tombs = u
        },
        t.prototype.reset = function() {
            this.numFragments = 0
        },
        t.prototype.forEach = function(t) {
            for (var e = 0; e < this.numFragments; e++) 1 !== this.tombs[e] && t(this, e)
        },
        t.prototype.setFragObject = function(t, e) {
            this.objects[t] = e
        },
        t.prototype.setFragGeometry = function(t, e) {
            this.geometries[t] = e
        },
        t.prototype.setFragMaterial = function(t, e) {
            this.materials[t] = e
        },
        t.prototype.setFragMaterialIndex = function(t, e) {
            this.materialIndexs[t] = e
        },
        t.prototype.setFragVisible = function(t, e) {
            this.visibilities[t] = e ? 1 : 0
        },
        t.prototype.setFragsVisible = function(t, e) {
            for (var n = 0; n < t.length; n++) this.setFragVisible(t[n], e)
        },
        t.prototype.getObjectFragmentIds = function(t) {
            return t._egsFragIds
        },
        t.prototype.addFragment = function(t) {
            var e;
            return this.tombList.length > 0 ? (e = this.tombList.pop(), this.tombs[e] = 0) : this.capacity === this.numFragments ? (this.reallocate(Math.ceil(1.8 * this.capacity)), e = this.numFragments, this.numFragments++) : (e = this.numFragments, this.numFragments++),
            t._egsFragId = e,
            e
        },
        t.prototype.removeFragments = function(t) {
            var e = t._egsFragIds;
            if (undefined !== e) {
                for (var n = 0; n < e.length; n++) this.removeFragmentByFragId(e[n]);
                t._egsFragIds = undefined
            }
        },
        t.prototype.removeFragmentByFragId = function(t) {
            this.tombList.push(t),
            this.tombs[t] = 1
        },
        t
    } ()
},
aB5d: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        function d(e, i, l) {
            var d = e.background;
            null === d ? m(x, b) : d && d.isColor && (m(d, 1), l = true),
            (t.autoClear || l) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            d && d.isCubeTexture ? (undefined === y && (y = new o.a, _ = new f.a(new s.a(5, 5, 5), new h.a({
                uniforms: p.a.cube.uniforms,
                vertexShader: p.a.cube.vertexShader,
                fragmentShader: p.a.cube.fragmentShader,
                side: r.f,
                depthTest: false,
                depthWrite: false,
                fog: false
            }))), y.projectionMatrix.copy(i.projectionMatrix), y.matrixWorld.extractRotation(i.matrixWorld), y.matrixWorldInverse.getInverse(y.matrixWorld), _.material.uniforms.tCube.value = d, _.modelViewMatrix.multiplyMatrices(y.matrixWorldInverse, _.matrixWorld), n.update(_), t.renderBufferDirect(y, null, _.geometry, _.material, _, null)) : d && d.isTexture && (undefined === v && (v = new a.a( - 1, 1, 1, -1, 0, 1), g = new f.a(new u.a(2, 2), new c.a({
                depthTest: false,
                depthWrite: false,
                fog: false
            }))), g.material.map = d, n.update(g), t.renderBufferDirect(v, null, g.geometry, g.material, g, null))
        }
        function m(t, n) {
            e.buffers.color.setClear(t.r, t.g, t.b, n, i)
        }
        var v, g, y, _, x = new l.a(0),
        b = 0;
        return {
            getClearColor: function() {
                return x
            },
            setClearColor: function(t, e) {
                x.set(t),
                b = undefined !== e ? e: 1,
                m(x, b)
            },
            getClearAlpha: function() {
                return b
            },
            setClearAlpha: function(t) {
                b = t,
                m(x, b)
            },
            render: d
        }
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("RBSo "),
    a = n("OrthographicCamera "),
    o = n("PerspectiveCamera "),
    s = n("BoxGeometry||BoxBufferGeometry "),
    u = n("PlaneGeometry||PlaneBufferGeometry "),
    c = n("MeshBasicMaterial "),
    h = n("ShaderMaterial "),
    l = n("Color "),
    f = n("Mesh "),
    p = n("ShaderLib ")
},
Scene: function(t, e, n) {
    "use strict ";
    function Scene() {
        r.a.call(this),
        this.type = "Scene ",
        this.background = null,
        this.fog = null,
        this.overrideMaterial = null,
        this.autoUpdate = true
    }
    n.d(e, "a ",
    function() {
        return Scene
    });
    var r = n("87 g3 ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        copy: function(t, e) {
            return r.a.prototype.copy.call(this, t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()),
            this.autoUpdate = t.autoUpdate,
            this.matrixAutoUpdate = t.matrixAutoUpdate,
            this
        },
        toJSON: function(t) {
            var e = r.a.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)),
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            e
        }
    })
},
aEZq: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, h, l) {
        t = t || 10,
        e = e || 16,
        n = n || 8,
        i = i || 64,
        h = new c.a(undefined !== h ? h: 4473924),
        l = new c.a(undefined !== l ? l: 8947848);
        var f, p, d, m, v, g, y, _ = [],
        x = [];
        for (m = 0; m <= e; m++) d = m / e * (2 * Math.PI),
        f = Math.sin(d) * t,
        p = Math.cos(d) * t,
        _.push(0, 0, 0),
        _.push(f, 0, p),
        y = 1 & m ? h: l,
        x.push(y.r, y.g, y.b),
        x.push(y.r, y.g, y.b);
        for (m = 0; m <= n; m++) for (y = 1 & m ? h: l, g = t - t / n * m, v = 0; v < i; v++) d = v / i * (2 * Math.PI),
        f = Math.sin(d) * g,
        p = Math.cos(d) * g,
        _.push(f, 0, p),
        x.push(y.r, y.g, y.b),
        d = (v + 1) / i * (2 * Math.PI),
        f = Math.sin(d) * g,
        p = Math.cos(d) * g,
        _.push(f, 0, p),
        x.push(y.r, y.g, y.b);
        var b = new u.a;
        b.addAttribute("position ", new s.b(_, 3)),
        b.addAttribute("color ", new s.b(x, 3));
        var w = new o.a({
            vertexColors: a._60
        });
        r.a.call(this, b, w)
    }
    var r = n("LineSegments "),
    a = n("RBSo "),
    o = n("LineBasicMaterial"),
    s = n("BufferAttribute "),
    u = n("BufferGeometry "),
    c = n("Color ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
aPws: function(t, e, n) {
    "use strict ";
    function i(t) {
        for (var e = t * t,
        n = new Uint8Array(3 * e), i = 0; i < e; ++i) {
            var a = 3 * i,
            o = Math.floor(255 * Math.random());
            n[a] = o,
            n[a + 1] = o,
            n[a + 2] = o
        }
        var s = new r.h(n, t, t, r.A, r.H, r.F, r.B, r.B, r.u, r.u);
        return s.needsUpdate = true,
        s
    }
    e.a = i;
    var r = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.)
},
InstancedBufferGeometry: function(t, e, n) {
    "use strict ";
    function i() {
        r.a.call(this),
        this.type = "InstancedBufferGeometry ",
        this.maxInstancedCount = undefined
    }
    var r = n("BufferGeometry ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isInstancedBufferGeometry: true,
        addGroup: function(t, e, n) {
            this.groups.push({
                start: t,
                count: e,
                materialIndex: n
            })
        },
        copy: function(t) {
            var e = t.index;
            null !== e && this.setIndex(e.clone());
            var n = t.attributes;
            for (var i in n) {
                var r = n[i];
                this.addAttribute(i, r.clone())
            }
            for (var a = t.groups,
            o = 0,
            s = a.length; o < s; o++) {
                var u = a[o];
                this.addGroup(u.start, u.count, u.materialIndex)
            }
            return this
        }
    })
},
auUc: function(t, e) {

},
ayiu: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        a.a.call(this),
        this.v1 = t,
        this.v2 = e
    }
    var r = n("Vector3 "),
    a = n("Lk8y ");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    i.prototype.getPoint = function(t) {
        if (1 === t) return this.v2.clone();
        var e = new r.a;
        return e.subVectors(this.v2, this.v1),
        e.multiplyScalar(t),
        e.add(this.v1),
        e
    }
},
"b + DU ": function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return o
    });
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = n("TTgl "),
    a = n(" + 5 Cw "),
    o = {
        defines: {
            NUM_SAMPLES: 8,
            NUM_SPIRAL_TURNS: 7,
            MAX_SS_RADIUS: 64
        },
        uniforms: {
            depthMap: {
                value: null
            },
            normalMap: {
                value: null
            },
            noiseMap: {
                value: null
            },
            bias: {
                value: .01
            },
            radius: {
                value: .5
            },
            intensityDivR6: {
                value: .5 / Math.pow(.5, 6)
            },
            projectionScale: {
                value: 1
            },
            cameraNear: {
                value: 1
            },
            cameraFar: {
                value: 1e3
            },
            cameraProjectionMatrix: {
                value: new i.p
            },
            cameraInverseProjectionMatrix: {
                value: new i.p
            },
            noiseScale: {
                value: new i.I(1, 1)
            },
            texelSize: {
                value: new i.I(1, 1)
            }
        },
        vertexShader: a.a,
        fragmentShader: r.a
    }
},
bA0i: function(t, e, n) {
    "use strict ";
    function i(t) {
        t = t || 1;
        var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
        n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
        i = new u.a;
        i.addAttribute("position ", new s.b(e, 3)),
        i.addAttribute("color ", new s.b(n, 3));
        var c = new o.a({
            vertexColors: a._60
        });
        r.a.call(this, i, c)
    }
    var r = n("LineSegments "),
    a = n("RBSo "),
    o = n("LineBasicMaterial"),
    s = n("BufferAttribute "),
    u = n("BufferGeometry ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
bKOQ: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_ALPHAMAP\\ n\\ tuniform sampler2D alphaMap;\\n # endif\\ n "
},
bMBl: function(t, e, n) {
    "use strict ";
    e.a = "varying vec2 vUv;\\nvoid main() {\\n vUv = uv;\\n gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n "
},
"bO / F ": function(t, e, n) {
    "use strict ";
    function i() {
        r.a.call(this, new o.a(50, 1, .5, 500))
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("6 f23 "),
    a = n("7 MDU "),
    o = n("PerspectiveCamera ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isSpotLightShadow: true,
        update: function(t) {
            var e = this.camera,
            n = 2 * a.a.RAD2DEG * t.angle,
            i = this.mapSize.width / this.mapSize.height,
            r = t.distance || e.far;
            n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix())
        }
    })
},
Mesh: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, r, a, o) {
        return p.a.barycoordFromPoint(t, e, n, i, L),
        r.multiplyScalar(L.x),
        a.multiplyScalar(L.y),
        o.multiplyScalar(L.z),
        r.add(a).add(o),
        r.clone()
    }
    function r(t, e, n, i, r, a, o) {
        var s = t.material;
        if (null === (s.side === m.f ? n.intersectTriangle(a, r, i, true, o) : n.intersectTriangle(i, r, a, s.side !== m.u, o))) return null;
        I.copy(o),
        I.applyMatrix4(t.matrixWorld);
        var u = e.ray.origin.distanceTo(I);
        return u < e.near || u > e.far ? null: {
            distance: u,
            point: I.clone(),
            object: t
        }
    }
    function a(t, e, n, a, o, s, u, c) {
        b.fromBufferAttribute(a, s),
        w.fromBufferAttribute(a, u),
        M.fromBufferAttribute(a, c);
        var h = r(t, e, n, b, w, M, R);
        return h && (o && (A.fromBufferAttribute(o, s), C.fromBufferAttribute(o, u), P.fromBufferAttribute(o, c), h.uv = i(R, b, w, M, A, C, P)), h.face = new d.a(s, u, c, p.a.normal(b, w, M)), h.faceIndex = s),
        h
    }
    function Mesh(t, e) {
        f.a.call(this),
        this.type = "Mesh ";
        var n = undefined !== t ? t: new g.a,
        i = undefined !== e ? e: new v.a({
            color: 16777215 * Math.random()
        });
        Object.defineProperties(this, {
            geometry: {
                get: function() {
                    return n
                },
                set: function(t) {
                    n = t,
                    this.setGeometryChanged()
                }
            },
            material: {
                get: function() {
                    return i
                },
                set: function(t) {
                    i = t,
                    this.setMaterialChanged()
                }
            }
        }),
        this.drawMode = m._50,
        this.updateMorphTargets()
    }
    n.d(e, "a ",
    function() {
        return Mesh
    });
    var s = n("Vector3 "),
    u = n("Ne + j "),
    c = n("Sphere "),
    h = n("6 YUT "),
    l = n("6 HoM "),
    f = n("87 g3 "),
    p = n("Ee7l "),
    d = n("HiwY "),
    m = n("RBSo "),
    v = n("MeshBasicMaterial "),
    g = n("BufferGeometry "),
    y = new l.a,
    _ = new h.a,
    x = new c.a,
    b = new s.a,
    w = new s.a,
    M = new s.a,
    S = new s.a,
    E = new s.a,
    T = new s.a,
    A = new u.a,
    C = new u.a,
    P = new u.a,
    L = new s.a,
    R = new s.a,
    I = new s.a;
    o.prototype = Object.assign(Object.create(f.a.prototype), {
        constructor: o,
        isMesh: true,
        setDrawMode: function(t) {
            this.drawMode = t
        },
        copy: function(t) {
            return f.a.prototype.copy.call(this, t),
            this.drawMode = t.drawMode,
            this
        },
        updateMorphTargets: function() {
            var t, e, n, i = this.geometry;
            if (i.isBufferGeometry) {
                var r = i.morphAttributes,
                a = Object.keys(r);
                if (a.length > 0) {
                    var o = r[a[0]];
                    if (undefined !== o) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {},
                    t = 0, e = o.length; t < e; t++) n = o[t].name || String(t),
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[n] = t
                }
            } else {
                var s = i.morphTargets;
                if (undefined !== s && s.length > 0) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {},
                t = 0, e = s.length; t < e; t++) n = s[t].name || String(t),
                this.morphTargetInfluences.push(0),
                this.morphTargetDictionary[n] = t
            }
        },
        egsRaycast: function() {
            return function(t, e, n) {
                var o = this.geometry,
                s = this.material,
                u = this.matrixWorld;
                if (undefined !== s) {
                    y.getInverse(u),
                    _.copy(t.ray).applyMatrix4(y);
                    var c;
                    if (o.isBufferGeometry) {
                        var h, l, f, p, d = o.index,
                        m = o.attributes.position,
                        v = o.attributes.uv,
                        g = 0,
                        x = d.count;
                        if (n && (g = n.start, x = n.start + n.count), null !== d) for (p = g; p < x; p += 3) {
                            h = d.getX(p),
                            l = d.getX(p + 1),
                            f = d.getX(p + 2),
                            (c = a(this, t, _, m, v, h, l, f)) && (c.faceIndex = Math.floor(p / 3), e.push(c));
                        } else {
                            for (p = g; p < x; p += 3) h = p,
                            l = p + 1,
                            f = p + 2,
                            (c = a(this, t, _, m, v, h, l, f)) && (c.index = h, e.push(c))
                        }
                    } else if (o.isGeometry) {
                        var L, I, O, N, D = Array.isArray(s),
                        U = o.vertices,
                        B = o.faces,
                        z = o.faceVertexUvs[0];
                        z.length > 0 && (N = z);
                        for (var F = 0,
                        j = B.length; F < j; F++) {
                            var k = B[F],
                            V = D ? s[k.materialIndex] : s;
                            if (undefined !== V) {
                                if (L = U[k.a], I = U[k.b], O = U[k.c], true === V.morphTargets) {
                                    var G = o.morphTargets,
                                    H = this.morphTargetInfluences;
                                    b.set(0, 0, 0),
                                    w.set(0, 0, 0),
                                    M.set(0, 0, 0);
                                    for (var W = 0,
                                    X = G.length; W < X; W++) {
                                        var q = H[W];
                                        if (0 !== q) {
                                            var Y = G[W].vertices;
                                            b.addScaledVector(S.subVectors(Y[k.a], L), q),
                                            w.addScaledVector(E.subVectors(Y[k.b], I), q),
                                            M.addScaledVector(T.subVectors(Y[k.c], O), q)
                                        }
                                    }
                                    b.add(L),
                                    w.add(I),
                                    M.add(O),
                                    L = b,
                                    I = w,
                                    O = M
                                }
                                if (c = r(this, t, _, L, I, O, R)) {
                                    if (N && N[F]) {
                                        var Z = N[F];
                                        A.copy(Z[0]),
                                        C.copy(Z[1]),
                                        P.copy(Z[2]),
                                        c.uv = i(R, L, I, O, A, C, P)
                                    }
                                    c.face = k,
                                    c.faceIndex = F,
                                    e.push(c)
                                }
                            }
                        }
                    }
                }
            }
        } (),
        raycast: function() {
            return function(t, e) {
                var n = this.geometry,
                o = this.material,
                s = this.matrixWorld;
                if (undefined !== o && (null === n.boundingSphere && n.computeBoundingSphere(), x.copy(n.boundingSphere), x.applyMatrix4(s), false !== t.ray.intersectsSphere(x) && (y.getInverse(s), _.copy(t.ray).applyMatrix4(y), null === n.boundingBox || false !== _.intersectsBox(n.boundingBox)))) {
                    var u;
                    if (n.isBufferGeometry) {
                        var c, h, l, f, p, d = n.index,
                        m = n.attributes.position,
                        v = n.attributes.uv;
                        if (null !== d) for (f = 0, p = d.count; f < p; f += 3) c = d.getX(f),
                        h = d.getX(f + 1),
                        l = d.getX(f + 2),
                        (u = a(this, t, _, m, v, c, h, l)) && (u.faceIndex = Math.floor(f / 3), e.push(u));
                        else for (f = 0, p = m.count; f < p; f += 3) c = f,
                        h = f + 1,
                        l = f + 2,
                        (u = a(this, t, _, m, v, c, h, l)) && (u.index = c, e.push(u))
                    } else if (n.isGeometry) {
                        var g, L, I, O, N = Array.isArray(o),
                        D = n.vertices,
                        U = n.faces,
                        B = n.faceVertexUvs[0];
                        B.length > 0 && (O = B);
                        for (var z = 0,
                        F = U.length; z < F; z++) {
                            var j = U[z],
                            k = N ? o[j.materialIndex] : o;
                            if (undefined !== k) {
                                if (g = D[j.a], L = D[j.b], I = D[j.c], true === k.morphTargets) {
                                    var V = n.morphTargets,
                                    G = this.morphTargetInfluences;
                                    b.set(0, 0, 0),
                                    w.set(0, 0, 0),
                                    M.set(0, 0, 0);
                                    for (var H = 0,
                                    W = V.length; H < W; H++) {
                                        var X = G[H];
                                        if (0 !== X) {
                                            var q = V[H].vertices;
                                            b.addScaledVector(S.subVectors(q[j.a], g), X),
                                            w.addScaledVector(E.subVectors(q[j.b], L), X),
                                            M.addScaledVector(T.subVectors(q[j.c], I), X)
                                        }
                                    }
                                    b.add(g),
                                    w.add(L),
                                    M.add(I),
                                    g = b,
                                    L = w,
                                    I = M
                                }
                                if (u = r(this, t, _, g, L, I, R)) {
                                    if (O && O[z]) {
                                        var Y = O[z];
                                        A.copy(Y[0]),
                                        C.copy(Y[1]),
                                        P.copy(Y[2]),
                                        u.uv = i(R, g, L, I, A, C, P)
                                    }
                                    u.face = j,
                                    u.faceIndex = z,
                                    e.push(u)
                                }
                            }
                        }
                    }
                }
            }
        } (),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    })
}
},
bv29: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        o.a.call(this, t, e, n, i)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("RBSo "),
    a = n("Vbxv "),
    o = n("9 DcM ");
    i.prototype = Object.assign(Object.create(a.a), {
        constructor: i,
        ValueTypeName: "string ",
        ValueBufferType: Array,
        DefaultInterpolation: r.K,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    })
},
cHSn: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return o
    });
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = n("XEJx "),
    a = n("PpZm "),
    o = {
        uniforms: {
            id: {
                value: new i.I(0, 0)
            }
        },
        vertexShader: a.a,
        fragmentShader: r.a
    }
},
EdgesGeometry: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        r.a.call(this),
        this.type = "EdgesGeometry ",
        this.parameters = {
            thresholdAngle: e
        },
        e = undefined !== e ? e: 1;
        var n, i, u, c, h = [],
        l = Math.cos(s.a.DEG2RAD * e),
        f = [0, 0],
        p = {},
        d = ["a ", "b ", "c "];
        t.isBufferGeometry ? (c = new o.a, c.fromBufferGeometry(t)) : c = t.clone(),
        c.mergeVertices(),
        c.computeFaceNormals();
        for (var m = c.vertices,
        v = c.faces,
        g = 0,
        y = v.length; g < y; g++) for (var _ = v[g], x = 0; x < 3; x++) n = _[d[x]],
        i = _[d[(x + 1) % 3]],
        f[0] = Math.min(n, i),
        f[1] = Math.max(n, i),
        u = f[0] + ", " + f[1],
        undefined === p[u] ? p[u] = {
            index1: f[0],
            index2: f[1],
            face1: g,
            face2: undefined
        }: p[u].face2 = g;
        for (u in p) {
            var b = p[u];
            if (undefined === b.face2 || v[b.face1].normal.dot(v[b.face2].normal) <= l) {
                var w = m[b.index1];
                h.push(w.x, w.y, w.z),
                w = m[b.index2],
                h.push(w.x, w.y, w.z)
            }
        }
        this.addAttribute("position ", new a.b(h, 3))
    }
    var r = n("BufferGeometry "),
    a = n("BufferAttribute "),
    o = n("Geometry "),
    s = n("7 MDU ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
cOAL: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_FOG\\ n\\ tuniform vec3 fogColor;\\n\\ tvarying float fogDepth;\\n\\ t # ifdef FOG_EXP2\\ n\\ t\\ tuniform float fogDensity;\\n\\ t #else\\ n\\ t\\ tuniform float fogNear;\\n\\ t\\ tuniform float fogFar;\\n\\ t # endif\\ n # endif\\ n "
},
cRRw: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        function i(t) {
            s = t
        }
        function r(t) {
            u = t.type,
            c = t.bytesPerElement
        }
        function a(e, i) {
            t.drawElements(s, i, u, e * c),
            n.calls++,
            n.vertices += i,
            s === t.TRIANGLES && (n.faces += i / 3)
        }
        function o(i, r, a) {
            var o = e.get("ANGLE_instanced_arrays ");
            if (null === o) {
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            }
            o.drawElementsInstancedANGLE(s, a, u, r * c, i.maxInstancedCount),
            n.calls++,
            n.vertices += a * i.maxInstancedCount,
            s === t.TRIANGLES && (n.faces += i.maxInstancedCount * a / 3)
        }
        var s, u, c;
        this.setMode = i,
        this.setIndex = r,
        this.render = a,
        this.renderInstances = o
    }
    n.d(e, "a ",
    function() {
        return i
    })
},
Sprite: function(t, e, n) {
    "use strict ";
    function i(t) {
        a.a.call(this),
        this.type = "Sprite ";
        var e = undefined !== t ? t: new o.a;
        Object.defineProperties(this, {
            material: {
                get: function() {
                    return e
                },
                set: function(t) {
                    e = t,
                    this.setMaterialChanged()
                }
            }
        })
    }
    var r = n("Vector3 "),
    a = n("87 g3 "),
    o = n("SpriteMaterial ");
    i.prototype = Object.assign(Object.create(a.a.prototype), {
        constructor: i,
        isSprite: true,
        raycast: function() {
            var t = new r.a,
            e = new r.a,
            n = new r.a;
            return function(i, r) {
                e.setFromMatrixPosition(this.matrixWorld),
                i.ray.closestPointToPoint(e, t),
                n.setFromMatrixScale(this.matrixWorld);
                var a = n.x * n.y / 4;
                if (! (e.distanceToSquared(t) > a)) {
                    var o = i.ray.origin.distanceTo(t);
                    o < i.near || o > i.far || r.push({
                        distance: o,
                        point: t.clone(),
                        face: null,
                        object: this
                    })
                }
            }
        } (),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        }
    })
},
cfk7: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.cameras = t || []
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("PerspectiveCamera ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isArrayCamera: true
    })
},
cmAo: function(t, e, n) {
    "use strict ";
    e.a = "float specularStrength;\\n # ifdef USE_SPECULARMAP\\ n\\ tvec4 texelSpecular = texture2D(specularMap, vUv);\\n\\ tspecularStrength = texelSpecular.r;\\n #else\\ n\\ tspecularStrength = 1.0;\\n # endif "
},
coYL: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return i
    });
    var i = function() {
        function t(t) {
            undefined === t && (t = ""),
            this.description = t,
            this.symbol = Symbol()
        }
        return t
    } ()
},
"d / hv ": function(t, e, n) {
    "use strict ";
    function i(t) {
        var e = {};
        return {
            get: function(n) {
                if (undefined !== e[n]) return e[n];
                var i;
                switch (n) {
                case "WEBGL_depth_texture ":
                    i = t.getExtension("WEBGL_depth_texture ") || t.getExtension("MOZ_WEBGL_depth_texture ") || t.getExtension("WEBKIT_WEBGL_depth_texture ");
                    break;
                case "EXT_texture_filter_anisotropic ":
                    i = t.getExtension("EXT_texture_filter_anisotropic ") || t.getExtension("MOZ_EXT_texture_filter_anisotropic ") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic ");
                    break;
                case "WEBGL_compressed_texture_s3tc ":
                    i = t.getExtension("WEBGL_compressed_texture_s3tc ") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc ") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc ");
                    break;
                case "WEBGL_compressed_texture_pvrtc ":
                    i = t.getExtension("WEBGL_compressed_texture_pvrtc ") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc ");
                    break;
                case "WEBGL_compressed_texture_etc1 ":
                    i = t.getExtension("WEBGL_compressed_texture_etc1 ");
                    break;
                default:
                    i = t.getExtension(n)
                }
                return null === i && console.warn("THREE.WebGLRenderer: " + n + "extension not supported."),
                e[n] = i,
                i
            }
        }
    }
    n.d(e, "a ",
    function() {
        return i
    })
},
"d9r + ": function(t, e, n) {
    "use strict ";
    e.a = "# ifdef FLAT_SHADED\\ n\\ tvec3 fdx = vec3(dFdx(vViewPosition.x), dFdx(vViewPosition.y), dFdx(vViewPosition.z));\\n\\ tvec3 fdy = vec3(dFdy(vViewPosition.x), dFdy(vViewPosition.y), dFdy(vViewPosition.z));\\n\\ tvec3 normal = normalize(cross(fdx, fdy));\\n #else\\ n\\ tvec3 normal = normalize(vNormal) * flipNormal;\\n # endif\\ n # ifdef USE_NORMALMAP\\ n\\ tnormal = perturbNormal2Arb(-vViewPosition, normal);\\n # elif defined(USE_BUMPMAP)\\ n\\ tnormal = perturbNormalArb(-vViewPosition, normal, dHdxy_fwd());\\n # endif\\ n "
},
dM8i: function(t, e, n) {
    "use strict ";
    e.a = "#if defined(TONE_MAPPING)\\ n gl_FragColor.rgb = toneMapping(gl_FragColor.rgb);\\n # endif\\ n "
},
dlbA: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_AOMAP\\ n\\ tfloat ambientOcclusion = (texture2D(aoMap, vUv2).r - 1.0) * aoMapIntensity + 1.0;\\n\\ treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\\ t #if defined(USE_ENVMAP) && defined(PHYSICAL)\\ n\\ t\\ tfloat dotNV = saturate(dot(geometry.normal, geometry.viewDir));\\n\\ t\\ treflectedLight.indirectSpecular *= computeSpecularOcclusion(dotNV, ambientOcclusion, material.specularRoughness);\\n\\ t # endif\\ n # endif\\ n "
},
AmbientLight: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        r.a.call(this, t, e),
        this.type = "AmbientLight ",
        this.castShadow = undefined
    }
    var r = n("7 rj8 ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isAmbientLight: true
    })
},
TorusKnotGeometry||TorusKnotBufferGeometry: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, o, s, u) {
        a.a.call(this),
        this.type = "TorusKnotGeometry ",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: o,
            q: s
        },
        undefined !== u && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated.Use.scale(x, y, z) instead."),
        this.fromBufferGeometry(new r(t, e, n, i, o, s)),
        this.mergeVertices()
    }
    function r(t, e, n, i, r, a) {
        function c(t, e, n, i, r) {
            var a = Math.cos(t),
            o = Math.sin(t),
            s = n / e * t,
            u = Math.cos(s);
            r.x = i * (2 + u) * .5 * a,
            r.y = i * (2 + u) * o * .5,
            r.z = i * Math.sin(s) * .5
        }
        o.a.call(this),
        this.type = "TorusKnotBufferGeometry ",
        this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: n,
            radialSegments: i,
            p: r,
            q: a
        },
        t = t || 100,
        e = e || 40,
        n = Math.floor(n) || 64,
        i = Math.floor(i) || 8,
        r = r || 2,
        a = a || 3;
        var h, l, f = [],
        p = [],
        d = [],
        m = [],
        v = new u.a,
        g = new u.a,
        y = new u.a,
        _ = new u.a,
        x = new u.a,
        b = new u.a,
        w = new u.a;
        for (h = 0; h <= n; ++h) {
            var M = h / n * r * Math.PI * 2;
            for (c(M, r, a, t, y), c(M + .01, r, a, t, _), b.subVectors(_, y), w.addVectors(_, y), x.crossVectors(b, w), w.crossVectors(x, b), x.normalize(), w.normalize(), l = 0; l <= i; ++l) {
                var S = l / i * Math.PI * 2,
                E = -e * Math.cos(S),
                T = e * Math.sin(S);
                v.x = y.x + (E * w.x + T * x.x),
                v.y = y.y + (E * w.y + T * x.y),
                v.z = y.z + (E * w.z + T * x.z),
                p.push(v.x, v.y, v.z),
                g.subVectors(v, y).normalize(),
                d.push(g.x, g.y, g.z),
                m.push(h / n),
                m.push(l / i)
            }
        }
        for (l = 1; l <= n; l++) for (h = 1; h <= i; h++) {
            var A = (i + 1) * (l - 1) + (h - 1),
            C = (i + 1) * l + (h - 1),
            P = (i + 1) * l + h,
            L = (i + 1) * (l - 1) + h;
            f.push(A, C, L),
            f.push(C, P, L)
        }
        this.setIndex(f),
        this.addAttribute("position ", new s.b(p, 3)),
        this.addAttribute("normal ", new s.b(d, 3)),
        this.addAttribute("uv ", new s.b(m, 2))
    }
    var a = n("Geometry "),
    o = n("BufferGeometry "),
    s = n("BufferAttribute "),
    u = n("Vector3 ");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
dw8z: function(t, e, n) {
    "use strict ";
    function i(t) {
        return t / 255
    }
    function r(t) {
        return t.dot(u)
    }
    function a(t, e, n, a) {
        for (var o = [], u = 0; u < n; u++) for (var c = 0; c < e; c++) {
            var h = 4 * (u * e + c);
            a ? (s.fromArray(t, h), o.push(r(s))) : o.push(i(t[h]))
        }
        return o
    }
    var o = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    s = new o.K,
    u = new o.K(1 / Math.pow(256, 4), 1 / Math.pow(256, 3), 1 / Math.pow(256, 2), 1 / 256);
    e.a = a
},
"e / Dv ": function(t, e, n) {
    "use strict ";
    function i(t) {
        this.autoStart = undefined === t || t,
        this.startTime = 0,
        this.oldTime = 0,
        this.elapsedTime = 0,
        this.running = false
    }
    Object.assign(i.prototype, {
        start: function() {
            this.startTime = ("undefined " == typeof performance ? Date: performance).now(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = true
        },
        stop: function() {
            this.getElapsedTime(),
            this.running = false,
            this.autoStart = false
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var t = 0;
            if (this.autoStart && !this.running) return this.start(),
            0;
            if (this.running) {
                var e = ("undefined " == typeof performance ? Date: performance).now();
                t = (e - this.oldTime) / 1e3,
                this.oldTime = e,
                this.elapsedTime += t
            }
            return t
        }
    })
},
DataTexture: function(t, e, n) {
    "use strict ";
    function DataTexture(t, e, n, i, o, s, u, c, h, l, f, p) {
        r.a.call(this, null, s, u, c, h, l, i, o, f, p),
        this.image = {
            data: t,
            width: e,
            height: n
        },
        this.magFilter = undefined !== h ? h: a._5,
        this.minFilter = undefined !== l ? l: a._5,
        this.generateMipmaps = false,
        this.flipY = false,
        this.unpackAlignment = 1
    }
    n.d(e, "a ",
    function() {
        return DataTexture
    });
    var r = n("vh + C "),
    a = n("RBSo ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isDataTexture = true
},
SkinnedMesh: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        r.a.call(this, t, e),
        this.type = "SkinnedMesh ",
        this.bindMode = "attached ",
        this.bindMatrix = new u.a,
        this.bindMatrixInverse = new u.a;
        var n = this.initBones(),
        i = new o.a(n);
        this.bind(i, this.matrixWorld),
        this.normalizeSkinWeights()
    }
    var r = n("Mesh "),
    a = n("Vector4 "),
    o = n("S81n "),
    s = n("Bone "),
    u = n("6 HoM ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isSkinnedMesh: true,
        initBones: function() {
            var t, e, n, i, r = [];
            if (this.geometry && undefined !== this.geometry.bones) {
                for (n = 0, i = this.geometry.bones.length; n < i; n++) e = this.geometry.bones[n],
                t = new s.a,
                r.push(t),
                t.name = e.name,
                t.position.fromArray(e.pos),
                t.quaternion.fromArray(e.rotq),
                undefined !== e.scl && t.scale.fromArray(e.scl);
                for (n = 0, i = this.geometry.bones.length; n < i; n++) e = this.geometry.bones[n],
                -1 !== e.parent && null !== e.parent && undefined !== r[e.parent] ? r[e.parent].add(r[n]) : this.add(r[n])
            }
            return this.updateMatrixWorld(true),
            r
        },
        bind: function(t, e) {
            this.skeleton = t,
            undefined === e && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e = this.matrixWorld),
            this.bindMatrix.copy(e),
            this.bindMatrixInverse.getInverse(e)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            var t, e;
            if (this.geometry && this.geometry.isGeometry) for (e = 0; e < this.geometry.skinWeights.length; e++) {
                var n = this.geometry.skinWeights[e];
                t = 1 / n.lengthManhattan(),
                t !== 1 / 0 ? n.multiplyScalar(t) : n.set(1, 0, 0, 0)
            } else if (this.geometry && this.geometry.isBufferGeometry) {
                var i = new a.a,
                r = this.geometry.attributes.skinWeight;
                for (e = 0; e < r.count; e++) i.x = r.getX(e),
                i.y = r.getY(e),
                i.z = r.getZ(e),
                i.w = r.getW(e),
                t = 1 / i.lengthManhattan(),
                t !== 1 / 0 ? i.multiplyScalar(t) : i.set(1, 0, 0, 0),
                r.setXYZW(e, i.x, i.y, i.z, i.w)
            }
        },
        updateMatrixWorld: function(t) {
            r.a.prototype.updateMatrixWorld.call(this, t),
            "attached " === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached " === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    })
},
eLnu: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        function i() {
            var e = false,
            n = new a.a,
            i = null,
            r = new a.a;
            return {
                setMask: function(n) {
                    i === n || e || (t.colorMask(n, n, n, n), i = n)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e, i, a, o, s) { ! 0 === s && (e *= o, i *= o, a *= o),
                    n.set(e, i, a, o),
                    false === r.equals(n) && (t.clearColor(e, i, a, o), r.copy(n))
                },
                reset: function() {
                    e = false,
                    i = null,
                    r.set(0, 0, 0, 1)
                }
            }
        }
        function o() {
            var e = false,
            n = null,
            i = null,
            a = null;
            return {
                setTest: function(e) {
                    e ? d(t.DEPTH_TEST) : m(t.DEPTH_TEST)
                },
                setMask: function(i) {
                    n === i || e || (t.depthMask(i), n = i)
                },
                setFunc: function(e) {
                    if (i !== e) {
                        if (e) switch (e) {
                        case r._8:
                            t.depthFunc(t.NEVER);
                            break;
                        case r.e:
                            t.depthFunc(t.ALWAYS);
                            break;
                        case r.N:
                            t.depthFunc(t.LESS);
                            break;
                        case r.O:
                            t.depthFunc(t.LEQUAL);
                            break;
                        case r.x:
                            t.depthFunc(t.EQUAL);
                            break;
                        case r.H:
                            t.depthFunc(t.GEQUAL);
                            break;
                        case r.G:
                            t.depthFunc(t.GREATER);
                            break;
                        case r._13:
                            t.depthFunc(t.NOTEQUAL);
                            break;
                        default:
                            t.depthFunc(t.LEQUAL)
                        } else t.depthFunc(t.LEQUAL);
                        i = e
                    }
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    a !== e && (t.clearDepth(e), a = e)
                },
                reset: function() {
                    e = false,
                    n = null,
                    i = null,
                    a = null
                }
            }
        }
        function s() {
            var e = false,
            n = null,
            i = null,
            r = null,
            a = null,
            o = null,
            s = null,
            u = null,
            c = null;
            return {
                setTest: function(e) {
                    e ? d(t.STENCIL_TEST) : m(t.STENCIL_TEST)
                },
                setMask: function(i) {
                    n === i || e || (t.stencilMask(i), n = i)
                },
                setFunc: function(e, n, o) {
                    i === e && r === n && a === o || (t.stencilFunc(e, n, o), i = e, r = n, a = o)
                },
                setOp: function(e, n, i) {
                    o === e && s === n && u === i || (t.stencilOp(e, n, i), o = e, s = n, u = i)
                },
                setLocked: function(t) {
                    e = t
                },
                setClear: function(e) {
                    c !== e && (t.clearStencil(e), c = e)
                },
                reset: function() {
                    e = false,
                    n = null,
                    i = null,
                    r = null,
                    a = null,
                    o = null,
                    s = null,
                    u = null,
                    c = null
                }
            }
        }
        function u(e, n, i) {
            var r = new Uint8Array(4),
            a = t.createTexture();
            t.bindTexture(e, a),
            t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
            t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
            for (var o = 0; o < i; o++) t.texImage2D(n + o, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, r);
            return a
        }
        function c() {
            I.setClear(0, 0, 0, 1),
            O.setClear(1),
            N.setClear(0),
            d(t.DEPTH_TEST),
            O.setFunc(r.O),
            _(false),
            x(r.o),
            d(t.CULL_FACE),
            d(t.BLEND),
            g(r._12)
        }
        function h() {
            for (var t = 0,
            e = U.length; t < e; t++) U[t] = 0
        }
        function l(n) {
            if (U[n] = 1, 0 === B[n] && (t.enableVertexAttribArray(n), B[n] = 1), 0 !== z[n]) {
                e.get("ANGLE_instanced_arrays ").vertexAttribDivisorANGLE(n, 0),
                z[n] = 0
            }
        }
        function f(n, i) {
            if (U[n] = 1, 0 === B[n] && (t.enableVertexAttribArray(n), B[n] = 1), z[n] !== i) {
                e.get("ANGLE_instanced_arrays ").vertexAttribDivisorANGLE(n, i),
                z[n] = i
            }
        }
        function p() {
            for (var e = 0,
            n = B.length; e !== n; ++e) B[e] !== U[e] && (t.disableVertexAttribArray(e), B[e] = 0)
        }
        function d(e) { ! 0 !== F[e] && (t.enable(e), F[e] = true)
        }
        function m(e) { ! 1 !== F[e] && (t.disable(e), F[e] = false)
        }
        function v() {
            if (null === j && (j = [], e.get("WEBGL_compressed_texture_pvrtc ") || e.get("WEBGL_compressed_texture_s3tc ") || e.get("WEBGL_compressed_texture_etc1 "))) {
                for (var n = t.getParameter(t.COMPRESSED_TEXTURE_FORMATS), i = 0; i < n.length; i++) {
                    j.push(n[i]);
                    return j
                }
            }
        }
        function g(e, i, a, o, s, u, c, h) {
            e !== r._9 ? d(t.BLEND) : m(t.BLEND),
            e === r.r || e === k && h === Y || (e === r.c ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE, t.ONE, t.ONE)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.SRC_ALPHA, t.ONE)) : e === r._47 ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.ONE_MINUS_SRC_COLOR)) : e === r._3 ? h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA)) : (t.blendEquation(t.FUNC_ADD), t.blendFunc(t.ZERO, t.SRC_COLOR)) : h ? (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.ONE, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)) : (t.blendEquationSeparate(t.FUNC_ADD, t.FUNC_ADD), t.blendFuncSeparate(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA)), k = e, Y = h),
            e === r.r ? (s = s || i, u = u || a, c = c || o, i === V && s === W || (t.blendEquationSeparate(n(i), n(s)), V = i, W = s), a === G && o === H && u === X && c === q || (t.blendFuncSeparate(n(a), n(o), n(u), n(c)), G = a, H = o, X = u, q = c)) : (V = null, G = null, H = null, W = null, X = null, q = null)
        }
        function y(e) {
            e.side === r.u ? m(t.CULL_FACE) : d(t.CULL_FACE),
            _(e.side === r.f),
            true === e.transparent ? g(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : g(r._9),
            O.setFunc(e.depthFunc),
            O.setTest(e.depthTest),
            O.setMask(e.depthWrite),
            I.setMask(e.colorWrite),
            w(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
        }
        function _(e) {
            Z !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), Z = e)
        }
        function x(e) {
            e !== r.q ? (d(t.CULL_FACE), e !== J && (e === r.o ? t.cullFace(t.BACK) : e === r.p ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : m(t.CULL_FACE),
            J = e
        }
        function b(e) {
            e !== Q && (it && t.lineWidth(e), Q = e)
        }
        function w(e, n, i) {
            e ? (d(t.POLYGON_OFFSET_FILL), K === n && $ === i || (t.polygonOffset(n, i), K = n, $ = i)) : m(t.POLYGON_OFFSET_FILL)
        }
        function M() {
            return tt
        }
        function S(e) {
            tt = e,
            e ? d(t.SCISSOR_TEST) : m(t.SCISSOR_TEST)
        }
        function E(e) {
            undefined === e && (e = t.TEXTURE0 + et - 1),
            rt !== e && (t.activeTexture(e), rt = e)
        }
        function T(e, n) {
            null === rt && E();
            var i = at[rt];
            undefined === i && (i = {
                type: undefined,
                texture: undefined
            },
            at[rt] = i),
            i.type === e && i.texture === n || (t.bindTexture(e, n || ut[e]), i.type = e, i.texture = n)
        }
        function A() {
            try {
                t.compressedTexImage2D.apply(t, arguments)
            } catch(t) {
                console.error("THREE.WebGLState: ", t)
            }
        }
        function C() {
            try {
                t.texImage2D.apply(t, arguments)
            } catch(t) {
                console.error("THREE.WebGLState: ", t)
            }
        }
        function P(e) { ! 1 === ot.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), ot.copy(e))
        }
        function L(e) { ! 1 === st.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), st.copy(e))
        }
        function R() {
            for (var e = 0; e < B.length; e++) 1 === B[e] && (t.disableVertexAttribArray(e), B[e] = 0);
            F = {},
            j = null,
            rt = null,
            at = {},
            k = null,
            Z = null,
            J = null,
            I.reset(),
            O.reset(),
            N.reset()
        }
        var I = new i,
        O = new o,
        N = new s,
        D = t.getParameter(t.MAX_VERTEX_ATTRIBS),
        U = new Uint8Array(D),
        B = new Uint8Array(D),
        z = new Uint8Array(D),
        F = {},
        j = null,
        k = null,
        V = null,
        G = null,
        H = null,
        W = null,
        X = null,
        q = null,
        Y = false,
        Z = null,
        J = null,
        Q = null,
        K = null,
        $ = null,
        tt = null,
        et = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
        nt = parseFloat(/^WebGL\\ ([0-9])/.exec(t.getParameter(t.VERSION))[1]),
        it = parseFloat(nt) >= 1,
        rt = null,
        at = {},
        ot = new a.a,
        st = new a.a,
        ut = {};
        return ut[t.TEXTURE_2D] = u(t.TEXTURE_2D, t.TEXTURE_2D, 1),
        ut[t.TEXTURE_CUBE_MAP] = u(t.TEXTURE_CUBE_MAP, t.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
        {
            buffers: {
                color: I,
                depth: O,
                stencil: N
            },
            init: c,
            initAttributes: h,
            enableAttribute: l,
            enableAttributeAndDivisor: f,
            disableUnusedAttributes: p,
            enable: d,
            disable: m,
            getCompressedTextureFormats: v,
            setBlending: g,
            setMaterial: y,
            setFlipSided: _,
            setCullFace: x,
            setLineWidth: b,
            setPolygonOffset: w,
            getScissorTest: M,
            setScissorTest: S,
            activeTexture: E,
            bindTexture: T,
            compressedTexImage2D: A,
            texImage2D: C,
            scissor: P,
            viewport: L,
            reset: R
        }
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("RBSo "),
    a = n("Vector4 ")
},
eW7G: function(t, e, n) {
    "use strict ";
    e.a = "BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n "
},
ea3E: function(t, e, n) {
    "use strict ";
    function i(t) {
        function e() {
            if (i.isPresenting) {
                var e = i.getEyeParameters("left "),
                r = e.renderWidth,
                a = e.renderHeight;
                v = t.getPixelRatio(),
                m = t.getSize(),
                t.setDrawingBufferSize(2 * r, a, 1)
            } else {
                n.enabled && t.setDrawingBufferSize(m.width, m.height, v)
            }
        }
        var n = this,
        i = null,
        u = null;
        "VRFrameData " in window && (u = new window.VRFrameData);
        var c = new r.a,
        h = new r.a,
        l = new r.a,
        f = new s.a;
        f.bounds = new a.a(0, 0, .5, 1),
        f.layers.enable(1);
        var p = new s.a;
        p.bounds = new a.a(.5, 0, .5, 1),
        p.layers.enable(2);
        var d = new o.a([f, p]);
        d.layers.enable(1),
        d.layers.enable(2);
        var m, v;
        window.addEventListener("vrdisplaypresentchange ", e, false),
        this.enabled = false,
        this.standing = false,
        this.getDevice = function() {
            return i
        },
        this.setDevice = function(t) {
            undefined !== t && (i = t)
        },
        this.getCamera = function(t) {
            if (null === i) return t;
            i.depthNear = t.near,
            i.depthFar = t.far,
            i.getFrameData(u);
            var e = u.pose;
            null !== e.position ? t.position.fromArray(e.position) : t.position.set(0, 0, 0),
            null !== e.orientation && t.quaternion.fromArray(e.orientation),
            t.updateMatrixWorld();
            var n = i.stageParameters;
            if (this.standing && n && (h.fromArray(n.sittingToStandingTransform), l.getInverse(h), t.matrixWorld.multiply(h), t.matrixWorldInverse.multiply(l)), false === i.isPresenting) return t;
            d.matrixWorld.copy(t.matrixWorld),
            d.matrixWorldInverse.copy(t.matrixWorldInverse),
            f.matrixWorldInverse.fromArray(u.leftViewMatrix),
            p.matrixWorldInverse.fromArray(u.rightViewMatrix),
            this.standing && n && (f.matrixWorldInverse.multiply(l), p.matrixWorldInverse.multiply(l));
            var r = t.parent;
            null !== r && (c.getInverse(r.matrixWorld), f.matrixWorldInverse.multiply(c), p.matrixWorldInverse.multiply(c)),
            f.matrixWorld.getInverse(f.matrixWorldInverse),
            p.matrixWorld.getInverse(p.matrixWorldInverse),
            f.projectionMatrix.fromArray(u.leftProjectionMatrix),
            p.projectionMatrix.fromArray(u.rightProjectionMatrix),
            d.projectionMatrix.copy(f.projectionMatrix);
            var a = i.getLayers();
            if (a.length) {
                var o = a[0];
                null !== o.leftBounds && 4 === o.leftBounds.length && f.bounds.fromArray(o.leftBounds),
                null !== o.rightBounds && 4 === o.rightBounds.length && p.bounds.fromArray(o.rightBounds)
            }
            return d
        },
        this.getStandingMatrix = function() {
            return h
        },
        this.submitFrame = function() {
            i && i.isPresenting && i.submitFrame()
        }
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("6 HoM "),
    a = n("Vector4 "),
    o = n("cfk7 "),
    s = n("PerspectiveCamera ")
},
eekH: function(t, e, n) {
    "use strict ";
    Object.defineProperty(e, "__esModule ", {
        value: true
    });
    var i = n("ShadowMaterial ");
    n.d(e, "ShadowMaterial ",
    function() {
        return i.a
    });
    var r = n("SpriteMaterial ");
    n.d(e, "SpriteMaterial ",
    function() {
        return r.a
    });
    var a = n("RawShaderMaterial ");
    n.d(e, "RawShaderMaterial ",
    function() {
        return a.a
    });
    var o = n("ShaderMaterial ");
    n.d(e, "ShaderMaterial ",
    function() {
        return o.a
    });
    var s = n("PointsMaterial ");
    n.d(e, "PointsMaterial ",
    function() {
        return s.a
    });
    var u = n("MeshPhysicalMaterial ");
    n.d(e, "MeshPhysicalMaterial ",
    function() {
        return u.a
    });
    var c = n("MeshStandardMaterial ");
    n.d(e, "MeshStandardMaterial ",
    function() {
        return c.a
    });
    var h = n("MeshPhongMaterial ");
    n.d(e, "MeshPhongMaterial ",
    function() {
        return h.a
    });
    var l = n("MeshToonMaterial ");
    n.d(e, "MeshToonMaterial ",
    function() {
        return l.a
    });
    var f = n("MeshNormalMaterial ");
    n.d(e, "MeshNormalMaterial ",
    function() {
        return f.a
    });
    var p = n("MeshLambertMaterial ");
    n.d(e, "MeshLambertMaterial ",
    function() {
        return p.a
    });
    var d = n("MeshDepthMaterial");
    n.d(e, "MeshDepthMaterial ",
    function() {
        return d.a
    });
    var m = n("MeshBasicMaterial ");
    n.d(e, "MeshBasicMaterial ",
    function() {
        return m.a
    });
    var v = n("LineDashedMaterial ");
    n.d(e, "LineDashedMaterial ",
    function() {
        return v.a
    });
    var g = n("LineBasicMaterial");
    n.d(e, "LineBasicMaterial ",
    function() {
        return g.a
    });
    var y = n("Material ");
    n.d(e, "Material ",
    function() {
        return y.a
    })
},
"f / n6 ": function(t, e, n) {
    "use strict ";
    function i(t) {
        var e = r(t),
        n = t.toJSON(),
        i = new Blob(e),
        s = new ArrayBuffer(4);
        new DataView(s).setUint32(0, i.size, true),
        o(new Blob([s].concat(e, [a(JSON.stringify(n))])))
    }
    function r(t) {
        var e = {},
        n = [];
        return t.traverse(function(t) {
            if (t.isPopMesh) {
                var i = t.geometry;
                if (undefined === e[i.uuid]) {
                    var r = {};
                    r.uuid = i.uuid,
                    n.push(i.model.indices.buffer),
                    n.push(i.model.vertices.buffer),
                    n.push(i.model.normals.buffer),
                    n.push(i.model.textures.buffer),
                    e[i.uuid] = r
                }
            }
        }),
        n
    }
    function a(t) {
        if (undefined !== window.TextEncoder) return (new window.TextEncoder).encode(t).buffer;
        for (var e = new ArrayBuffer(t.length), 
            n = new Uint8Array(e), i = 0; i < t.length; ++i) n[i] = 
            t.charCodeAt(i);
        return e
    }
    function o(t, e) {
        undefined === e && (e = "scene.bin ");
        var n = document.createElement("a ");
        n.download = e,
        n.href = URL.createObjectURL(t),
        n.click()
    }
    e.a = i
},
f7ra: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return i
    });
    var i = {
        area: function(t) {
            for (var e = t.length,
            n = 0,
            i = e - 1,
            r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
            return.5 * n
        },
        triangulate: function() {
            function t(t, e, n, i, r, a) {
                var o, s, u, c, h, l, f, p, d;
                if (s = t[a[e]].x, u = t[a[e]].y, c = t[a[n]].x, h = t[a[n]].y, l = t[a[i]].x, f = t[a[i]].y, (c - s) * (f - u) - (h - u) * (l - s) <= 0) return ! 1;
                var m, v, g, y, _, x, b, w, M, S, E, T, A, C, P;
                for (m = l - c, v = f - h, g = s - l, y = u - f, _ = c - s, x = h - u, o = 0; o < r; o++) if (p = t[a[o]].x, d = t[a[o]].y, !(p === s && d === u || p === c && d === h || p === l && d === f) && (b = p - s, w = d - u, M = p - c, S = d - h, E = p - l, T = d - f, P = m * S - v * M, A = _ * w - x * b, C = g * T - y * E, P >= -Number.EPSILON && C >= -Number.EPSILON && A >= -Number.EPSILON)) return ! 1;
                return ! 0
            }
            return function(e, n) {
                var r = e.length;
                if (r < 3) return null;
                var a, o, s, u = [],
                c = [],
                h = [];
                if (i.area(e) > 0) for (o = 0; o < r; o++) c[o] = o;
                else for (o = 0; o < r; o++) c[o] = r - 1 - o;
                var l = r,
                f = 2 * l;
                for (o = l - 1; l > 2;) {
                    if (f--<=0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"),
                    n ? h: u;
                    if (a = o, l <= a && (a = 0), o = a + 1, l <= o && (o = 0), s = o + 1, l <= s && (s = 0), t(e, a, o, s, l, c)) {
                        var p, d, m, v, g;
                        for (p = c[a], d = c[o], m = c[s], u.push([e[p], e[d], e[m]]), h.push([c[a], c[o], c[s]]), v = o, g = o + 1; g < l; v++, g++) c[v] = c[g];
                        l--,
                        f = 2 * l
                    }
                }
                return n ? h: u
            }
        } (),
        triangulateShape: function(t, e) {
            function n(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }
            function r(t, e, n) {
                return t.x !== e.x ? t.x < e.x ? t.x <= n.x && n.x <= e.x: e.x <= n.x && n.x <= t.x: t.y < e.y ? t.y <= n.y && n.y <= e.y: e.y <= n.y && n.y <= t.y
            }
            function a(t, e, n, i, a) {
                var o = e.x - t.x,
                s = e.y - t.y,
                u = i.x - n.x,
                c = i.y - n.y,
                h = t.x - n.x,
                l = t.y - n.y,
                f = s * u - o * c,
                p = s * h - o * l;
                if (Math.abs(f) > Number.EPSILON) {
                    var d;
                    if (f > 0) {
                        if (p < 0 || p > f) return [];
                        if ((d = c * h - u * l) < 0 || d > f) return []
                    } else {
                        if (p > 0 || p < f) return [];
                        if ((d = c * h - u * l) > 0 || d < f) return []
                    }
                    if (0 === d) return ! a || 0 !== p && p !== f ? [t] : [];
                    if (d === f) return ! a || 0 !== p && p !== f ? [e] : [];
                    if (0 === p) return [n];
                    if (p === f) return [i];
                    var m = d / f;
                    return [{
                        x: t.x + m * o,
                        y: t.y + m * s
                    }]
                }
                if (0 !== p || c * h != u * l) return [];
                var v = 0 === o && 0 === s,
                g = 0 === u && 0 === c;
                if (v && g) return t.x !== n.x || t.y !== n.y ? [] : [t];
                if (v) return r(n, i, t) ? [t] : [];
                if (g) return r(t, e, n) ? [n] : [];
                var y, _, x, b, w, M, S, E;
                return 0 !== o ? (t.x < e.x ? (y = t, x = t.x, _ = e, b = e.x) : (y = e, x = e.x, _ = t, b = t.x), n.x < i.x ? (w = n, S = n.x, M = i, E = i.x) : (w = i, S = i.x, M = n, E = n.x)) : (t.y < e.y ? (y = t, x = t.y, _ = e, b = e.y) : (y = e, x = e.y, _ = t, b = t.y), n.y < i.y ? (w = n, S = n.y, M = i, E = i.y) : (w = i, S = i.y, M = n, E = n.y)),
                x <= S ? b < S ? [] : b === S ? a ? [] : [w] : b <= E ? [w, _] : [w, M] : x > E ? [] : x === E ? a ? [] : [y] : b <= E ? [y, _] : [y, M]
            }
            function o(t, e, n, i) {
                var r = e.x - t.x,
                a = e.y - t.y,
                o = n.x - t.x,
                s = n.y - t.y,
                u = i.x - t.x,
                c = i.y - t.y,
                h = r * s - a * o,
                l = r * c - a * u;
                if (Math.abs(h) > Number.EPSILON) {
                    var f = u * s - c * o;
                    return h > 0 ? l >= 0 && f >= 0 : l >= 0 || f >= 0
                }
                return l > 0
            }
            n(t),
            e.forEach(n);
            for (var s, u, c, h, l, f, p = {},
            d = t.concat(), m = 0, v = e.length; m < v; m++) Array.prototype.push.apply(d, e[m]);
            for (s = 0, u = d.length; s < u; s++) l = d[s].x + ": " + d[s].y,
            undefined !== p[l] && console.warn("THREE.ShapeUtils: Duplicate point ", l, s),
            p[l] = s;
            var g = function(t, e) {
                for (var n, i, r, s, u, c, h, l, f, p, d, m = t.concat(), v = [], g = [], y = 0, _ = e.length; y < _; y++) v.push(y);
                for (var x = 0,
                b = 2 * v.length; v.length > 0;) {
                    if (--b < 0) {
                        console.log("Infinite Loop!Holes left: " + v.length + ", Probably Hole outside Shape!");
                        break
                    }
                    for (r = x; r < m.length; r++) {
                        s = m[r],
                        i = -1;
                        for (var y = 0; y < v.length; y++) if (c = v[y], h = s.x + ": " + s.y + ": " + c, undefined === g[h]) {
                            n = e[c];
                            for (var w = 0; w < n.length; w++) if (u = n[w],
                            function(t, e) {
                                var i = m.length - 1,
                                r = t - 1;
                                r < 0 && (r = i);
                                var a = t + 1;
                                a > i && (a = 0);
                                var s = o(m[t], m[r], m[a], n[e]);
                                if (!s) return ! 1;
                                var u = n.length - 1,
                                c = e - 1;
                                c < 0 && (c = u);
                                var h = e + 1;
                                return h > u && (h = 0),
                                !!(s = o(n[e], n[c], n[h], m[t]))
                            } (r, w) && !
                            function(t, e) {
                                var n, i, r;
                                for (n = 0; n < m.length; n++) if (i = n + 1, i %= m.length, r = a(t, e, m[n], m[i], true), r.length > 0) return ! 0;
                                return ! 1
                            } (s, u) && !
                            function(t, n) {
                                var i, r, o, s, u;
                                for (i = 0; i < v.length; i++) for (r = e[v[i]], o = 0; o < r.length; o++) if (s = o + 1, s %= r.length, u = a(t, n, r[o], r[s], true), u.length > 0) return ! 0;
                                return ! 1
                            } (s, u)) {
                                i = w,
                                v.splice(y, 1),
                                l = m.slice(0, r + 1),
                                f = m.slice(r),
                                p = n.slice(i),
                                d = n.slice(0, i + 1),
                                m = l.concat(p).concat(d).concat(f),
                                x = r;
                                break
                            }
                            if (i >= 0) break;
                            g[h] = true
                        }
                        if (i >= 0) break
                    }
                }
                return m
            } (t, e),
            y = i.triangulate(g, false);
            for (s = 0, u = y.length; s < u; s++) for (h = y[s], c = 0; c < 3; c++) l = h[c].x + ": " + h[c].y,
            undefined !== (f = p[l]) && (h[c] = f);
            return y.concat()
        },
        isClockWise: function(t) {
            return i.area(t) < 0
        }
    }
},
"fHG + ": function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return r
    });
    var i = n("F0 + n "),
    r = function() {
        function t() {
            this.sprites = new i.a(50)
        }
        return t.prototype.dispose = function() {
            this.sprites.forEach(function(t) {
                t._egsSpriteId = undefined
            })
        },
        t.prototype.reset = function() {
            this.sprites.reset()
        },
        t.prototype.addSprite = function(t) {
            var e = this.sprites.addItemNoduplicate(t);
            return - 1 !== e && (t._egsSpriteId = e),
            t._egsSpriteId
        },
        t.prototype.removeSprite = function(t) {
            this.sprites.removeItem(t, t._egsSpriteId),
            t._egsSpriteId = undefined
        },
        t
    } ()
},
fURu: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_COLOR\\ n\\ tdiffuseColor.rgb *= vColor;\\n # endif "
},
fUup: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_SKINNING\\ n\\ tuniform mat4 bindMatrix;\\n\\ tuniform mat4 bindMatrixInverse;\\n\\ t # ifdef BONE_TEXTURE\\ n\\ t\\ tuniform sampler2D boneTexture;\\n\\ t\\ tuniform int boneTextureSize;\\n\\ t\\ tmat4 getBoneMatrix(const in float i) {\\n\\ t\\ t\\ tfloat j = i * 4.0;\\n\\ t\\ t\\ tfloat x = mod(j, float(boneTextureSize));\\n\\ t\\ t\\ tfloat y = floor(j / float(boneTextureSize));\\n\\ t\\ t\\ tfloat dx = 1.0 / float(boneTextureSize);\\n\\ t\\ t\\ tfloat dy = 1.0 / float(boneTextureSize);\\n\\ t\\ t\\ ty = dy * (y + 0.5);\\n\\ t\\ t\\ tvec4 v1 = texture2D(boneTexture, vec2(dx * (x + 0.5), y));\\n\\ t\\ t\\ tvec4 v2 = texture2D(boneTexture, vec2(dx * (x + 1.5), y));\\n\\ t\\ t\\ tvec4 v3 = texture2D(boneTexture, vec2(dx * (x + 2.5), y));\\n\\ t\\ t\\ tvec4 v4 = texture2D(boneTexture, vec2(dx * (x + 3.5), y));\\n\\ t\\ t\\ tmat4 bone = mat4(v1, v2, v3, v4);\\n\\ t\\ t\\ treturn bone;\\n\\ t\\ t}\\n\\ t #else\\ n\\ t\\ tuniform mat4 boneMatrices[MAX_BONES];\\n\\ t\\ tmat4 getBoneMatrix(const in float i) {\\n\\ t\\ t\\ tmat4 bone = boneMatrices[int(i)];\\n\\ t\\ t\\ treturn bone;\\n\\ t\\ t }\\n\\ t # endif\\ n # endif\\ n "
},
fVU3: function(t, e, n) {
    "use strict ";
    function i() {
        function t(t) {
            var e = t.uuid,
            n = i[e];
            return undefined === n && (n = {},
            i[e] = n),
            n
        }
        function e(t) {
            delete i[t.uuid]
        }
        function n() {
            i = {}
        }
        var i = {};
        return {
            get: t,
            remove: e,
            clear: n
        }
    }
    n.d(e, "a ",
    function() {
        return i
    })
},
fd64: function(t, e, n) {
    "use strict ";
    e.a = "PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * (1.0 - metalnessFactor);\\nmaterial.specularRoughness = clamp(roughnessFactor, 0.04, 1.0);\\n # ifdef STANDARD\\ n\\ tmaterial.specularColor = mix(vec3(DEFAULT_SPECULAR_COEFFICIENT), diffuseColor.rgb, metalnessFactor);\\n #else\\ n\\ tmaterial.specularColor = mix(vec3(MAXIMUM_SPECULAR_COEFFICIENT * pow2(reflectivity)), diffuseColor.rgb, metalnessFactor);\\n\\ tmaterial.clearCoat = saturate(clearCoat);\\tmaterial.clearCoatRoughness = clamp(clearCoatRoughness, 0.04, 1.0);\\n # endif\\ n "
},
PerspectiveCamera: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        r.a.call(this),
        this.type = "PerspectiveCamera ",
        this.fov = undefined !== t ? t: 50,
        this.zoom = 1,
        this.near = undefined !== n ? n: .1,
        this.far = undefined !== i ? i: 2e3,
        this.focus = 10,
        this.aspect = undefined !== e ? e: 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Camera "),
    a = n("87 g3 "),
    o = n("7 MDU ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isPerspectiveCamera: true,
        copy: function(t, e) {
            return r.a.prototype.copy.call(this, t, e),
            this.fov = t.fov,
            this.zoom = t.zoom,
            this.near = t.near,
            this.far = t.far,
            this.focus = t.focus,
            this.aspect = t.aspect,
            this.view = null === t.view ? null: Object.assign({},
            t.view),
            this.filmGauge = t.filmGauge,
            this.filmOffset = t.filmOffset,
            this
        },
        setFocalLength: function(t) {
            var e = .5 * this.getFilmHeight() / t;
            this.fov = 2 * o.a.RAD2DEG * Math.atan(e),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var t = Math.tan(.5 * o.a.DEG2RAD * this.fov);
            return.5 * this.getFilmHeight() / t
        },
        getEffectiveFOV: function() {
            return 2 * o.a.RAD2DEG * Math.atan(Math.tan(.5 * o.a.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(t, e, n, i, r, a) {
            this.aspect = t / e,
            this.view = {
                fullWidth: t,
                fullHeight: e,
                offsetX: n,
                offsetY: i,
                width: r,
                height: a
            },
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            this.view = null,
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var t = this.near,
            e = t * Math.tan(.5 * o.a.DEG2RAD * this.fov) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            r = -.5 * i,
            a = this.view;
            if (null !== a) {
                var s = a.fullWidth,
                u = a.fullHeight;
                r += a.offsetX * i / s,
                e -= a.offsetY * n / u,
                i *= a.width / s,
                n *= a.height / u
            }
            var c = this.filmOffset;
            0 !== c && (r += t * c / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far)
        },
        toJSON: function(t) {
            var e = a.a.prototype.toJSON.call(this, t);
            return e.object.fov = this.fov,
            e.object.zoom = this.zoom,
            e.object.near = this.near,
            e.object.far = this.far,
            e.object.focus = this.focus,
            e.object.aspect = this.aspect,
            null !== this.view && (e.object.view = Object.assign({},
            this.view)),
            e.object.filmGauge = this.filmGauge,
            e.object.filmOffset = this.filmOffset,
            e
        }
    })
},
fxIi: function(t, e, n) {
    "use strict ";
    e.a = "\\nvec3 objectNormal = vec3(normal);\\n "
},
g1lb: function(t, e, n) {
    "use strict ";
    Object.defineProperty(e, "__esModule ", {
        value: true
    });
    var i = n(" / E3y ");
    n.d(e, "EventBus ",
    function() {
        return i.f
    }),
    n.d(e, "Configuration ",
    function() {
        return i.e
    }),
    n.d(e, "RenderMode ",
    function() {
        return i.o
    }),
    n.d(e, "RenderStatistics ",
    function() {
        return i.p
    }),
    n.d(e, "BasePhongMaterial ",
    function() {
        return i.b
    }),
    n.d(e, "ShaderMaterialUtils ",
    function() {
        return i.q
    }),
    n.d(e, "PopModel ",
    function() {
        return i.l
    }),
    n.d(e, "PopModelBlock ",
    function() {
        return i.m
    }),
    n.d(e, "PopMesh ",
    function() {
        return i.k
    }),
    n.d(e, "PopGeometry ",
    function() {
        return i.j
    }),
    n.d(e, "PopPhongMaterial ",
    function() {
        return i.n
    }),
    n.d(e, "PluginManager ",
    function() {
        return i.h
    }),
    n.d(e, "PluginName ",
    function() {
        return i.i
    }),
    n.d(e, "Application ",
    function() {
        return i.a
    }),
    n.d(e, "projectName ",
    function() {
        return i.t
    }),
    n.d(e, "StackingPlugin ",
    function() {
        return i.s
    }),
    n.d(e, "Stacking ",
    function() {
        return i.r
    }),
    n.d(e, "CameraPlugin ",
    function() {
        return i.c
    }),
    n.d(e, "CameraState ",
    function() {
        return i.d
    }),
    n.d(e, "InteractorType ",
    function() {
        return i.g
    })
},
g2ae: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        r.a.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    var r = n("yKmP ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isInstancedInterleavedBuffer: true,
        copy: function(t) {
            return r.a.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    })
},
gIE0: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return y
    });
    var i = n("mUrr "),
    r = n("Fa8a "),
    a = n("ytBM "),
    o = n("coYL "),
    s = n("Ov69 "),
    u = n("qjPn "),
    c = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    h = n("CustomerDefine3 "),
    l = n("TJTO "),
    f = n("PO9Y "),
    p = n("4 wub "),
    d = n("UJyc "),
    m = n("Ioe4 "),
    v = new c.c,
    g = new o.a("before_render "),
    y = function() {
        function t(t, e, n) {
            var a = this;
            this.renderer = null,
            this.width = 100,
            this.height = 100,
            this.renderModelUpdateTime = 0,
            this.config = null,
            this.enableProgressiveRendering = true,
            this.canvas = null,
            this.antialiasing = true,
            this.enableAlpha = false,
            this.premultipliedAlpha = true,
            this._doc = null,
            this.renderBatchIterator = null,
            this.frameTimeBudget = 1e3 / 30,
            this.resumeFrame = false,
            this.detailCullingEnabled = true,
            this._detailCullingSize = 1e-5,
            this._needsRender = false,
            this.dynamicOptimizerEnabled = false,
            this.onRequestRender = function() {},
            this.onConfigurationUpdated = function() {
                a.detailCullingEnabled = a.config.getValue("engine / detailCulling / enabled ", false),
                a.detailCullingEnabled && a.setDetailCullingSizeInPixels(a.config.getValue("engine / detailCulling / cullingSize ", 100)),
                a.enableProgressiveRendering = a.config.getValue("engine / progressive / enabled ", false),
                a.enableProgressiveRendering && (s.a.BATCH_SIZE = a.config.getValue("engine / progressive / batchSize ", s.a.BATCH_SIZE), a.frameTimeBudget = 1e3 / a.config.getValue("engine / progressive / minFPS ", 30));
                var t = a.config.getValue("engine / useThree ", false);
                a.doRender = t ? a.threeRender: a.egsRender,
                a.dynamicOptimizerEnabled = a.config.getValue("engine / dynamicOptimizer / enabled ", false),
                a.dynamicOptimizerEnabled && (a.dynamicOptimizer.detailCullingSize = a.config.getValue("engine / dynamicOptimizer / detailCullingMaxSize ", 250)),
                a._needsRender = true
            },
            this.updateEffectRenderer = function() {
                var t = a.config.getValue("engine / ao / enabled ", false),
                e = a.config.getValue("engine / outline / enabled ", false);
                if (a.effectRenderer && a.effectRenderer.dispose(), a.effectRenderer = e ? new i.a(a.renderer, a.config) : t ? new r.a(a.renderer, a.config) : undefined, a.effectRenderer) {
                    var n = a.renderer.getSize(),
                    o = n.width,
                    s = n.height;
                    a.effectRenderer.initialize(),
                    a.effectRenderer.setSize(o, s)
                }
                a.dynamicOptimizer.ssaoEnabled = t,
                a.dynamicOptimizer.outlineModeEnabled = e
            },
            this.doRender = this.egsRender,
            this.canvas = t,
            this.config = n,
            this._doc = e,
            this.renderBatchIterator = new s.a(this),
            this.performanceMonitor = new m.a,
            this.dynamicOptimizer = new d.a(this, this.performanceMonitor, this.config)
        }
        return Object.defineProperty(t.prototype, "doc ", {
            get: function() {
                return this._doc
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(t.prototype, "scene ", {
            get: function() {
                return this.doc.scene
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(t.prototype, "camera ", {
            get: function() {
                return this.doc.camera
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(t.prototype, "model ", {
            get: function() {
                return this.doc.model
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(t.prototype, "needsContinueRender ", {
            get: function() {
                return this._needsRender
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(t.prototype, "detailCullingSize ", {
            get: function() {
                return this._detailCullingSize
            },
            set: function(t) {
                this._detailCullingSize = t
            },
            enumerable: true,
            configurable: true
        }),
        t.prototype.initialize = function() {
            this.antialiasing = this.config.getValue("canvas / antialiasing ", this.antialiasing),
            this.enableAlpha = this.config.getValue("canvas / alpha ", this.enableAlpha),
            this.premultipliedAlpha = this.config.getValue("canvas / premultipliedAlpha ", this.premultipliedAlpha),
            this.renderer = new u.a({
                canvas: this.canvas,
                preserveDrawingBuffer: true,
                antialias: this.antialiasing,
                alpha: this.enableAlpha,
                premultipliedAlpha: this.premultipliedAlpha
            }),
            this.renderer.setPixelRatio(window.devicePixelRatio),
            this.renderer.setSize(window.innerWidth, window.innerHeight),
            this.renderer.setClearColor(15856373),
            this.width = window.innerWidth,
            this.height = window.innerHeight,
            this.config.addValueListener("engine ", this.onConfigurationUpdated),
            this.onConfigurationUpdated(),
            this.config.addValueListener("engine / ao / enabled ", this.updateEffectRenderer),
            this.config.addValueListener("engine / outline / enabled ", this.updateEffectRenderer),
            this.updateEffectRenderer(),
            this.dynamicOptimizer.onRequestRender = this.onRequestRender,
            this.dynamicOptimizer.initialize()
        },
        t.prototype.uninitialize = function() {
            this.model.dispose(),
            this.onRequestRender = undefined,
            this.dynamicOptimizer.uninitialize(),
            this.renderer.forceContextLoss(),
            this.renderer = null,
            this.effectRenderer && (this.effectRenderer.dispose(), this.effectRenderer = undefined),
            this.config.removeValueListener("engine ", this.onConfigurationUpdated),
            this.config.removeValueListener("engine / ao / enabled ", this.updateEffectRenderer),
            this.config.removeValueListener("engine / outline / enabled ", this.updateEffectRenderer)
        },
        t.prototype.setCamera = function(t) {
            this.dynamicOptimizer.setCamera(t)
        },
        t.prototype.setBackgroundColor = function(t) {
            this.renderer.setClearColor(t)
        },
        t.prototype.resize = function(t) {
            undefined !== t ? (this.width = t.width, this.height = t.height) : (this.width = this.canvas.parentElement ? this.canvas.parentElement.clientWidth: window.innerWidth, this.height = this.canvas.parentElement ? this.canvas.parentElement.clientHeight: window.innerHeight),
            this.onResized()
        },
        t.prototype.onResized = function() {
            this.renderer.setSize(this.width, this.height),
            this.effectRenderer && this.effectRenderer.setSize(this.width, this.height),
            this.onConfigurationUpdated()
        },
        t.prototype.setDetailCullingSizeInPixels = function(t) {
            this.detailCullingSize = t / (this.width * this.height) * 4
        },
        t.prototype.getDetailCullingSizeInPixel = function() {
            return this.width * this.height * 4 * this.detailCullingSize
        },
        Object.defineProperty(t.prototype, "sceneDoc ", {
            get: function() {
                return this.doc
            },
            enumerable: true,
            configurable: true
        }),
        t.prototype.render = function() {
            if (this.camera && this.scene) {
                if (f.a.isArrayCamera(this.camera)) {
                    for (var t = this.camera.cameras,
                    e = 0,
                    n = t; e < n.length; e++) {
                        var i = n[e],
                        r = i.bounds,
                        a = r.x,
                        o = r.y,
                        s = r.z,
                        u = r.w,
                        c = a * this.width,
                        h = o * this.height,
                        l = s * this.width,
                        p = u * this.height;
                        this.renderer.setViewport(c, h, l, p),
                        this.renderer.setScissor(c, h, l, p),
                        this.renderer.setScissorTest(true),
                        this.doRender(this.doc.scene, i)
                    }
                } else {
                    this.doRender(this.doc.scene, this.camera)
                }
            }
        },
        t.prototype.threeRender = function(t, e) {
            this.renderer.render(t, e)
        },
        t.prototype.egsRender = function(t, e) {
            if (this.doc.scene && (!this.enableProgressiveRendering || this.doc.sceneChanged || this.doc.cameraChanged || this.resumeFrame)) { (!this.enableProgressiveRendering || this.doc.cameraChanged || this.doc.sceneChanged) && (this.resumeFrame = false),
                this.performanceMonitor.beginFrame(),
                this.dynamicOptimizerEnabled && this.dynamicOptimizer.optimizeUpdate();
                var n = this.effectRenderer && this.effectRenderer.active;
                this.renderBatchIterator.singleBatch = n || !this.enableProgressiveRendering;
                var i = this.frameTimeBudget;
                this.renderModelUpdateTime = 0,
                this.resumeFrame || (this.doc.updateScene(), this.renderBatchIterator.reset(), this.renderModelUpdateTime = this.performanceMonitor.framePastTime);
                var o = null;
                a.a.getInstance().emit(g);
                do {
                    o = this.renderBatchIterator.nextBatch(), n ? this.effectRenderer.render(o.renderList, e) : this.renderer.render(o.renderList, this.doc.camera), i = this.frameTimeBudget - this.performanceMonitor.framePastTime
                } while ( i > 0 && ! o . lastBatch );
                this.resumeFrame = !o.lastBatch;
                var s = n && this.effectRenderer instanceof r.a && this.effectRenderer.animationInProgress;
                this._needsRender = this.resumeFrame || s,
                this.performanceMonitor.endFrame()
            }
        },
        t.prototype.getRenderStatistics = function(t) {
            this.renderer.info.egsinfo.renderModelUpdate = this.renderModelUpdateTime,
            this.resumeFrame || (this.renderer.info.egsinfo.threeWebGLPrepare = 0),
            Object(p.b)(t, this.renderer.info)
        },
        t.prototype.getCanvasElement = function() {
            return this.renderer.domElement
        },
        t.prototype.shouldSkipByDetailCulling = function(t) {
            return !! this.detailCullingEnabled && t < this.detailCullingSize
        },
        t.prototype.shouldSkipByDetailCullingWithBoxArray = function(t, e) {
            if (!this.detailCullingEnabled) return ! 1;
            h.b.setToThree(t, e, v);
            var n = Object(l.a)(v, this.camera.position, this.model.projScreenMatrix);
            return this.shouldSkipByDetailCulling(n)
        },
        t.prototype.shouldSkipByDetailCullingWithBox = function(t) {
            if (!this.detailCullingEnabled) return ! 1;
            var e = Object(l.a)(t, this.camera.position, this.model.projScreenMatrix);
            return this.shouldSkipByDetailCulling(e)
        },
        t.prototype.customObjectFilter = function(t) {},
        t.prototype.testFragmentVisibility = function(t) {
            return 0 !== this.doc.model.fragments.visibilities[t] && (h.b.setToThree(this.doc.model.fragments.boxes, t, v), !!this.doc.model.frustum.intersectsBox(v))
        },
        t.prototype.testLightVisibility = function(t) {
            var e = t.sceneNode;
            return !! e && e.netVisiblity
        },
        t.prototype.testSpriteVisibility = function(t) {
            var e = t.sceneNode;
            return !! e && e.netVisiblity && this.doc.model.frustum.intersectsSprite(t)
        },
        t
    } ()
},
gRRI: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        function r(t, n, i) {
            for (var r = n + 1; r < i; r++) {
                for (var a = t[r], o = r - 1; o >= n; o--) {
                    var s = t[o];
                    if (! (e(s, a) > 0)) break;
                    t[o + 1] = s
                }
                t[o + 1] = a
            }
        }
        function a(t, n, i) {
            for (var o = 0;;) {
                if (i - n <= 10) return void r(t, n, i);
                o = n + (i - n >> 1);
                var s = t[n],
                u = t[i - 1],
                c = t[o];
                if (e(s, u) > 0) {
                    var h = s;
                    s = u,
                    u = h
                }
                if (e(s, c) >= 0) {
                    var h = s;
                    s = c,
                    c = u,
                    u = h
                } else {
                    if (e(u, c) > 0) {
                        var h = u;
                        u = c,
                        c = h
                    }
                }
                t[n] = s,
                t[i - 1] = c;
                var l = u,
                f = n + 1,
                p = i - 1;
                t[o] = t[f],
                t[f] = l;
                t: for (var d = f + 1; d < p; d++) {
                    var m = t[d],
                    v = e(m, l);
                    if (v < 0) t[d] = t[f],
                    t[f] = m,
                    f++;
                    else if (v > 0) {
                        do {
                            if (--p === d) break t;
                            var g = t[p];
                            v = e(g, l)
                        } while ( v > 0 );
                        t[d] = t[p],
                        t[p] = m,
                        v < 0 && (m = t[d], t[d] = t[f], t[f] = m, f++)
                    }
                }
                i - p < f - n ? (a(t, p, i), i = f) : (a(t, n, f), n = p)
            }
        }
        return i - n < 2 ? t: (a(t, n, i), t)
    }
    e.a = i
},
CubeCamera: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        r.a.call(this),
        this.type = "CubeCamera ";
        var i = new u.a(90, 1, t, e);
        i.up.set(0, -1, 0),
        i.lookAt(new s.a(1, 0, 0)),
        this.add(i);
        var c = new u.a(90, 1, t, e);
        c.up.set(0, -1, 0),
        c.lookAt(new s.a( - 1, 0, 0)),
        this.add(c);
        var h = new u.a(90, 1, t, e);
        h.up.set(0, 0, 1),
        h.lookAt(new s.a(0, 1, 0)),
        this.add(h);
        var l = new u.a(90, 1, t, e);
        l.up.set(0, 0, -1),
        l.lookAt(new s.a(0, -1, 0)),
        this.add(l);
        var f = new u.a(90, 1, t, e);
        f.up.set(0, -1, 0),
        f.lookAt(new s.a(0, 0, 1)),
        this.add(f);
        var p = new u.a(90, 1, t, e);
        p.up.set(0, -1, 0),
        p.lookAt(new s.a(0, 0, -1)),
        this.add(p);
        var d = {
            format: o._30,
            magFilter: o.Q,
            minFilter: o.Q
        };
        this.renderTarget = new a.a(n, n, d),
        this.renderTarget.texture.name = "CubeCamera ",
        this.updateCubeMap = function(t, e) {
            null === this.parent && this.updateMatrixWorld();
            var n = this.renderTarget,
            r = n.texture.generateMipmaps;
            n.texture.generateMipmaps = false,
            n.activeCubeFace = 0,
            t.render(e, i, n),
            n.activeCubeFace = 1,
            t.render(e, c, n),
            n.activeCubeFace = 2,
            t.render(e, h, n),
            n.activeCubeFace = 3,
            t.render(e, l, n),
            n.activeCubeFace = 4,
            t.render(e, f, n),
            n.texture.generateMipmaps = r,
            n.activeCubeFace = 5,
            t.render(e, p, n),
            t.setRenderTarget(null)
        }
    }
    var r = n("87 g3 "),
    a = n("rc98 "),
    o = n("RBSo "),
    s = n("Vector3 "),
    u = n("PerspectiveCamera ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
gukr: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return s
    });
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = n("POlw "),
    a = this && this.__extends ||
    function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array &&
        function(t, e) {
            t.__proto__ = e
        } ||
        function(t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        };
        return function(e, n) {
            function i() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
        }
    } (),
    o = this && this.__assign || Object.assign ||
    function(t) {
        for (var e, n = 1,
        i = arguments.length; n < i; n++) {
            e = arguments[n];
            for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r])
        }
        return t
    },
    s = function(t) {
        function e(e) {
            var n = t.call(this, {
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader,
                lights: true
            }) || this;
            return n.isMeshPhongMaterial = true,
            n.uniforms = i.G.merge([i.D.phong.uniforms, e.uniforms || {}]),
            n.color = new i.f(16777215),
            n.specular = new i.f(1118481),
            n.shininess = 30,
            n.map = null,
            n.lightMap = null,
            n.lightMapIntensity = 1,
            n.aoMap = null,
            n.aoMapIntensity = 1,
            n.emissive = new i.f(0),
            n.emissiveIntensity = 1,
            n.emissiveMap = null,
            n.bumpMap = null,
            n.bumpScale = 1,
            n.normalMap = null,
            n.normalScale = new i.I(1, 1),
            n.displacementMap = null,
            n.displacementScale = 1,
            n.displacementBias = 0,
            n.specularMap = null,
            n.alphaMap = null,
            n.envMap = null,
            n.combine = i.t,
            n.reflectivity = 1,
            n.refractionRatio = .98,
            n.wireframe = false,
            n.wireframeLinewidth = 1,
            n.wireframeLinecap = "round ",
            n.wireframeLinejoin = "round ",
            n.skinning = false,
            n.morphTargets = false,
            n.morphNormals = false,
            n
        }
        return a(e, t),
        e.prototype.setValues = function(e) {
            t.prototype.setValues.call(this, e)
        },
        e.prototype.copy = function(e) {
            return t.prototype.copy.call(this, e),
            this.uniforms = r.a.cloneUniforms(e.uniforms),
            this.defines = o({},
            this.defines),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            this.shininess = e.shininess,
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.bumpMap = e.bumpMap,
            this.bumpScale = e.bumpScale,
            this.normalMap = e.normalMap,
            this.normalScale.copy(e.normalScale),
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.skinning = e.skinning,
            this.morphTargets = e.morphTargets,
            this.morphNormals = e.morphNormals,
            this
        },
        e
    } (i.E)
},
"h + KY ": function(t, e, n) {
    "use strict ";
    function i(t) {
        var e = [];
        t && t.isBone && e.push(t);
        for (var n = 0; n < t.children.length; n++) e.push.apply(e, i(t.children[n]));
        return e
    }
    function r(t) {
        for (var e = i(t), n = new l.a, r = [], o = [], h = new c.a(0, 0, 1), p = new c.a(0, 1, 0), d = 0; d < e.length; d++) {
            var m = e[d];
            m.parent && m.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), o.push(h.r, h.g, h.b), o.push(p.r, p.g, p.b))
        }
        n.addAttribute("position ", new f.b(r, 3)),
        n.addAttribute("color ", new f.b(o, 3));
        var v = new u.a({
            vertexColors: s._60,
            depthTest: false,
            depthWrite: false,
            transparent: true
        });
        a.a.call(this, n, v),
        this.root = t,
        this.bones = e,
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = false,
        this.onBeforeRender()
    }
    var a = n("LineSegments "),
    o = n("6 HoM "),
    s = n("RBSo "),
    u = n("LineBasicMaterial"),
    c = n("Color "),
    h = n("Vector3 "),
    l = n("BufferGeometry "),
    f = n("BufferAttribute ");
    r.prototype = Object.create(a.a.prototype),
    r.prototype.constructor = r,
    r.prototype.onBeforeRender = function() {
        var t = new h.a,
        e = new o.a,
        n = new o.a;
        return function() {
            var i = this.bones,
            r = this.geometry,
            a = r.getAttribute("position ");
            n.getInverse(this.root.matrixWorld);
            for (var o = 0,
            s = 0; o < i.length; o++) {
                var u = i[o];
                u.parent && u.parent.isBone && (e.multiplyMatrices(n, u.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(s, t.x, t.y, t.z), e.multiplyMatrices(n, u.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(s + 1, t.x, t.y, t.z), s += 2)
            }
            r.getAttribute("position ").needsUpdate = true
        }
    } ()
},
h6VZ: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        a.a.call(this, t, e, n, i)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Vbxv "),
    a = n("9 DcM ");
    i.prototype = Object.assign(Object.create(r.a), {
        constructor: i,
        ValueTypeName: "color "
    })
},
hBBe: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_LOGDEPTHBUF\\ n\\ tuniform float logDepthBufFC;\\n\\ t # ifdef USE_LOGDEPTHBUF_EXT\\ n\\ t\\ tvarying float vFragDepth;\\n\\ t # endif\\ n # endif\\ n "
},
Vector4: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0,
        this.w = undefined !== i ? i: 1
    }
    n.d(e, "a ",
    function() {
        return i
    }),
    Object.assign(i.prototype, {
        isVector4: true,
        set: function(t, e, n, i) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this.w = i,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this.w = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setW: function(t) {
            return this.w = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            case 3:
                this.w = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z, this.w)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this.w = undefined !== t.w ? t.w: 1,
            this
        },
        add: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument.Use.addVectors(a, b) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this.w += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this.w = t.w + e.w,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this.w += t.w * e,
            this
        },
        sub: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument.Use.subVectors(a, b) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this.w -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this.w = t.w - e.w,
            this
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this.w *= t,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            a = t.elements;
            return this.x = a[0] * e + a[4] * n + a[8] * i + a[12] * r,
            this.y = a[1] * e + a[5] * n + a[9] * i + a[13] * r,
            this.z = a[2] * e + a[6] * n + a[10] * i + a[14] * r,
            this.w = a[3] * e + a[7] * n + a[11] * i + a[15] * r,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        setAxisAngleFromQuaternion: function(t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e),
            this
        },
        setAxisAngleFromRotationMatrix: function(t) {
            var e, n, i, r, a = t.elements,
            o = a[0],
            s = a[4],
            u = a[8],
            c = a[1],
            h = a[5],
            l = a[9],
            f = a[2],
            p = a[6],
            d = a[10];
            if (Math.abs(s - c) < .01 && Math.abs(u - f) < .01 && Math.abs(l - p) < .01) {
                if (Math.abs(s + c) < .1 && Math.abs(u + f) < .1 && Math.abs(l + p) < .1 && Math.abs(o + h + d - 3) < .1) return this.set(1, 0, 0, 0),
                this;
                e = Math.PI;
                var m = (o + 1) / 2,
                v = (h + 1) / 2,
                g = (d + 1) / 2,
                y = (s + c) / 4,
                _ = (u + f) / 4,
                x = (l + p) / 4;
                return m > v && m > g ? m < .01 ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(m), i = y / n, r = _ / n) : v > g ? v < .01 ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(v), n = y / i, r = x / i) : g < .01 ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(g), n = _ / r, i = x / r),
                this.set(n, i, r, e),
                this
            }
            var b = Math.sqrt((p - l) * (p - l) + (u - f) * (u - f) + (c - s) * (c - s));
            return Math.abs(b) < .001 && (b = 1),
            this.x = (p - l) / b,
            this.y = (u - f) / b,
            this.z = (c - s) / b,
            this.w = Math.acos((o + h + d - 1) / 2),
            this
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this.w = Math.min(this.w, t.w),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this.w = Math.max(this.w, t.w),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this.w = Math.max(t.w, Math.min(e.w, this.w)),
            this
        },
        clampScalar: function() {
            var t, e;
            return function(n, r) {
                return undefined === t && (t = new i, e = new i),
                t.set(n, n, n, n),
                e.set(r, r, r, r),
                this.clamp(t, e)
            }
        } (),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this.w += (t.w - this.w) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        },
        fromArray: function(t, e) {
            return undefined === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this.w = t[e + 3],
            this
        },
        toArray: function(t, e) {
            return undefined === t && (t = []),
            undefined === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t[e + 3] = this.w,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return undefined !== n && console.warn("THREE.Vector4: offset has been removed from.fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this.w = t.getW(e),
            this
        }
    })
},
hLA2: function(t, e, n) {
    "use strict ";
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = new i.J,
    a = function() {
        function t(t, e, n, r, a, o) {
            this.data = t,
            this.width = e,
            this.height = n,
            this.matrix = r,
            this.boxSize = a,
            this.dataUrl = o,
            this.matrixInverse = (new i.p).getInverse(r)
        }
        return t.prototype.getDepth = function(t, e, n) {
            r.set(t, -e, n).applyMatrix4(this.matrix);
            var i = Math.floor((1 - r.y) * this.height / 2),
            a = Math.floor((r.x + 1) * this.width / 2);
            return i < 0 || i >= this.height || a < 0 || a >= this.width ? 1 / 0 : this.data[i * this.width + a]
        },
        t.prototype.forEachDepth = function(t) {
            for (var e = 0; e < this.height; e++) for (var n = 0; n < this.width; n++) {
                var i = e * this.width + n,
                a = this.data[i],
                o = n / this.width * 2 - 1,
                s = -e / this.height * 2 + 1;
                r.set(o, s, 0).applyMatrix4(this.matrixInverse),
                t(a, r.x, -r.y, r.z)
            }
        },
        t
    } ();
    e.a = a
},
hcH7: function(t, e, n) {
    "use strict ";
    e.a = "uniform vec3 diffuse;\\nuniform float opacity;\\n # ifndef FLAT_SHADED\\ n\\ tvarying vec3 vNormal;\\n # endif\\ n # include < common > \\n # include < color_pars_fragment > \\n # include < uv_pars_fragment > \\n # include < uv2_pars_fragment > \\n # include < map_pars_fragment > \\n # include < alphamap_pars_fragment > \\n # include < aomap_pars_fragment > \\n # include < lightmap_pars_fragment > \\n # include < envmap_pars_fragment > \\n # include < fog_pars_fragment > \\n # include < specularmap_pars_fragment > \\n # include < logdepthbuf_pars_fragment > \\n # include < clipping_planes_pars_fragment > \\nvoid main() {\\n\\ t # include < clipping_planes_fragment > \\n\\ tvec4 diffuseColor = vec4(diffuse, opacity);\\n\\ t # include < logdepthbuf_fragment > \\n\\ t # include < map_fragment > \\n\\ t # include < color_fragment > \\n\\ t # include < alphamap_fragment > \\n\\ t # include < alphatest_fragment > \\n\\ t # include < specularmap_fragment > \\n\\ tReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\\n\\ t # ifdef USE_LIGHTMAP\\ n\\ t\\ treflectedLight.indirectDiffuse += texture2D(lightMap, vUv2).xyz * lightMapIntensity;\\n\\ t #else\\ n\\ t\\ treflectedLight.indirectDiffuse += vec3(1.0);\\n\\ t # endif\\ n\\ t # include < aomap_fragment > \\n\\ treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\\ tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\\ t # include < normal_flip > \\n\\ t # include < envmap_fragment > \\n\\ tgl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n\\ t # include < premultiplied_alpha_fragment > \\n\\ t # include < tonemapping_fragment > \\n\\ t # include < encodings_fragment > \\n\\ t # include < fog_fragment > \\n}\\n "
},
CustomerDefine3: function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return r
    }),
    n.d(e, "b ",
    function() {
        return o
    });
    var i = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    r = 6,
    a = new i.c,
    o = function() {
        function t() {}
        return t.minX = function(t, e) {
            return t[6 * e]
        },
        t.minY = function(t, e) {
            return t[6 * e + 1]
        },
        t.minZ = function(t, e) {
            return t[6 * e + 2]
        },
        t.maxX = function(t, e) {
            return t[6 * e + 3]
        },
        t.maxY = function(t, e) {
            return t[6 * e + 4]
        },
        t.maxZ = function(t, e) {
            return t[6 * e + 5]
        },
        t.setFromThree = function(t, e, n) {
            t[6 * e] = n.min.x,
            t[6 * e + 1] = n.min.y,
            t[6 * e + 2] = n.min.z,
            t[6 * e + 3] = n.max.x,
            t[6 * e + 4] = n.max.y,
            t[6 * e + 5] = n.max.z
        },
        t.setToThree = function(t, e, n) {
            n.min.set(t[6 * e], t[6 * e + 1], t[6 * e + 2]),
            n.max.set(t[6 * e + 3], t[6 * e + 4], t[6 * e + 5])
        },
        t.copy = function(t, e, n) {
            e[6 * n] = t[6 * n],
            e[6 * n + 1] = t[6 * n + 1],
            e[6 * n + 2] = t[6 * n + 2],
            e[6 * n + 3] = t[6 * n + 3],
            e[6 * n + 4] = t[6 * n + 4],
            e[6 * n + 5] = t[6 * n + 5]
        },
        t.applyTransformationFromBox = function(t, e, n, i) {
            var r = i.elements,
            a = r[0] * t.min.x,
            o = r[1] * t.min.x,
            s = r[2] * t.min.x,
            u = r[0] * t.max.x,
            c = r[1] * t.max.x,
            h = r[2] * t.max.x,
            l = r[4] * t.min.y,
            f = r[5] * t.min.y,
            p = r[6] * t.min.y,
            d = r[4] * t.max.y,
            m = r[5] * t.max.y,
            v = r[6] * t.max.y,
            g = r[8] * t.min.z,
            y = r[9] * t.min.z,
            _ = r[10] * t.min.z,
            x = r[8] * t.max.z,
            b = r[9] * t.max.z,
            w = r[10] * t.max.z,
            M = Math.min(a, u) + Math.min(l, d) + Math.min(g, x) + r[12],
            S = Math.min(o, c) + Math.min(f, m) + Math.min(y, b) + r[13],
            E = Math.min(s, h) + Math.min(p, v) + Math.min(_, w) + r[14],
            T = Math.max(a, u) + Math.max(l, d) + Math.max(g, x) + r[12],
            A = Math.max(o, c) + Math.max(f, m) + Math.max(y, b) + r[13],
            C = Math.max(s, h) + Math.max(p, v) + Math.max(_, w) + r[14];
            e[6 * n] = M,
            e[6 * n + 1] = S,
            e[6 * n + 2] = E,
            e[6 * n + 3] = T,
            e[6 * n + 4] = A,
            e[6 * n + 5] = C
        },
        t.applyTransformation = function(t, e, n, i, r) {
            var a = r.elements,
            o = a[0] * t[6 * e],
            s = a[1] * t[6 * e],
            u = a[2] * t[6 * e],
            c = a[0] * t[6 * e + 3],
            h = a[1] * t[6 * e + 3],
            l = a[2] * t[6 * e + 3],
            f = a[4] * t[6 * e + 1],
            p = a[5] * t[6 * e + 1],
            d = a[6] * t[6 * e + 1],
            m = a[4] * t[6 * e + 4],
            v = a[5] * t[6 * e + 4],
            g = a[6] * t[6 * e + 4],
            y = a[8] * t[6 * e + 2],
            _ = a[9] * t[6 * e + 2],
            x = a[10] * t[6 * e + 2],
            b = a[8] * t[6 * e + 5],
            w = a[9] * t[6 * e + 5],
            M = a[10] * t[6 * e + 5],
            S = Math.min(o, c) + Math.min(f, m) + Math.min(y, b) + a[12],
            E = Math.min(s, h) + Math.min(p, v) + Math.min(_, w) + a[13],
            T = Math.min(u, l) + Math.min(d, g) + Math.min(x, M) + a[14],
            A = Math.max(o, c) + Math.max(f, m) + Math.max(y, b) + a[12],
            C = Math.max(s, h) + Math.max(p, v) + Math.max(_, w) + a[13],
            P = Math.max(u, l) + Math.max(d, g) + Math.max(x, M) + a[14];
            n[6 * i] = S,
            n[6 * i + 1] = E,
            n[6 * i + 2] = T,
            n[6 * i + 3] = A,
            n[6 * i + 4] = C,
            n[6 * i + 5] = P
        },
        t.applyTransformationTHREE = function(t, e, n, i, r) {
            a.min.set(t[6 * e], t[6 * e + 1], t[6 * e + 2]),
            a.max.set(t[6 * e + 3], t[6 * e + 4], t[6 * e + 5]),
            a.applyMatrix4(r),
            n[6 * i] = a.min.x,
            n[6 * i + 1] = a.min.y,
            n[6 * i + 2] = a.min.z,
            n[6 * i + 3] = a.max.x,
            n[6 * i + 4] = a.max.y,
            n[6 * i + 5] = a.max.z
        },
        t
    } ()
},
LatheGeometry: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        a.a.call(this),
        this.type = "LatheGeometry ",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        },
        this.fromBufferGeometry(new r(t, e, n, i)),
        this.mergeVertices()
    }
    function r(t, e, n, i) {
        s.a.call(this),
        this.type = "LatheBufferGeometry ",
        this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: i
        },
        e = Math.floor(e) || 12,
        n = n || 0,
        i = i || 2 * Math.PI,
        i = h.a.clamp(i, 0, 2 * Math.PI);
        var r, a, l, f = [],
        p = [],
        d = [],
        m = 1 / e,
        v = new u.a,
        g = new c.a;
        for (a = 0; a <= e; a++) {
            var y = n + a * m * i,
            _ = Math.sin(y),
            x = Math.cos(y);
            for (l = 0; l <= t.length - 1; l++) v.x = t[l].x * _,
            v.y = t[l].y,
            v.z = t[l].x * x,
            p.push(v.x, v.y, v.z),
            g.x = a / e,
            g.y = l / (t.length - 1),
            d.push(g.x, g.y)
        }
        for (a = 0; a < e; a++) for (l = 0; l < t.length - 1; l++) {
            r = l + a * t.length;
            var b = r,
            w = r + t.length,
            M = r + t.length + 1,
            S = r + 1;
            f.push(b, w, S),
            f.push(w, M, S)
        }
        if (this.setIndex(f), this.addAttribute("position ", new o.b(p, 3)), this.addAttribute("uv ", new o.b(d, 2)), this.computeVertexNormals(), i === 2 * Math.PI) {
            var E = this.attributes.normal.array,
            T = new u.a,
            A = new u.a,
            C = new u.a;
            for (r = e * t.length * 3, a = 0, l = 0; a < t.length; a++, l += 3) T.x = E[l + 0],
            T.y = E[l + 1],
            T.z = E[l + 2],
            A.x = E[r + l + 0],
            A.y = E[r + l + 1],
            A.z = E[r + l + 2],
            C.addVectors(T, A).normalize(),
            E[l + 0] = E[r + l + 0] = C.x,
            E[l + 1] = E[r + l + 1] = C.y,
            E[l + 2] = E[r + l + 2] = C.z
        }
    }
    var a = n("Geometry "),
    o = n("BufferAttribute "),
    s = n("BufferGeometry "),
    u = n("Vector3 "),
    c = n("Ne + j "),
    h = n("7 MDU ");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(s.a.prototype),
    r.prototype.constructor = r
},
i9Nn: function(t, e, n) {
    "use strict ";
    e.a = "varying vec2 vUv;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\n #if HIGH_QUALITY == 1\\ nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\n # endif\\ nuniform sampler2D indexNormalMap;\\nvec3 decodeViewNormalStereo(vec2 enc2) {\\n float kScale = 1.7777;\\n vec3 nn = vec3(enc2, 0.0) * vec3(2.0 * kScale, 2.0 * kScale, 0.0) + vec3(-kScale, -kScale, 1.0);\\n float g = 2.0 / dot(nn.xyz, nn.xyz);\\n vec3 n = vec3(nn.xy * g, g - 1.0);\\nreturn n;\\n}\\nfloat decodeIndex(vec2 enc) {return floor(dot(enc, vec2(65025.0, 255.0)));}\\nvec4 getIndexNormal(vec2 uv) {\\n vec4 enc = texture2D(indexNormalMap, uv);\\n float index = decodeIndex(enc.xy);\\n vec3 normal = decodeViewNormalStereo(enc.zw);\\nreturn vec4(index, normal);\\n}\\nvoid main() {\\n vec4 indexNormal = getIndexNormal(vUv);\\n float index = indexNormal.x;\\n vec3 normal = indexNormal.yzw;\\n\\ n vec4 indexNormalS = getIndexNormal(sampleCoordS);\\n vec4 indexNormalE = getIndexNormal(sampleCoordE);\\n #if HIGH_QUALITY == 1\\ n vec4 indexNormalN = getIndexNormal(sampleCoordN);\\n vec4 indexNormalW = getIndexNormal(sampleCoordW);\\n vec4 indexDiff = abs(vec4(index - indexNormalS.x, index - indexNormalE.x, \\n index - indexNormalN.x, index - indexNormalW.x));\\n vec4 normalDot = vec4(dot(normal, indexNormalS.yzw), dot(normal, indexNormalE.yzw), \\n dot(normal, indexNormalN.yzw), dot(normal, indexNormalW.yzw));\\nconst vec4 one = vec4(1.0);\\n #else\\ n vec2 indexDiff = abs(vec2(index - indexNormalS.x, index - indexNormalE.x));\\n vec2 normalDot = vec2(dot(normal, indexNormalS.yzw), dot(normal, indexNormalE.yzw));\\nconst vec2 one = vec2(1.0);\\n # endif\\ n float indexEdge = clamp(dot(indexDiff, one), 0.0, 1.0);\\n float normalEdge = clamp(dot(1.0 - normalDot, one) - float(NORMAL_BIAS), 0.0, 1.0);\\n float edge = max(indexEdge, normalEdge);\\n gl_FragColor = vec4(vec3(1.0 - edge), 1.0);\\n}\\n "
},
iFCb: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        r.a.call(this, t, e),
        this.meshPerAttribute = n || 1
    }
    var r = n("BufferAttribute ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isInstancedBufferAttribute: true,
        copy: function(t) {
            return r.a.prototype.copy.call(this, t),
            this.meshPerAttribute = t.meshPerAttribute,
            this
        }
    })
},
RectAreaLight: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        r.a.call(this, t, e),
        this.type = "RectAreaLight ",
        this.position.set(0, 1, 0),
        this.updateMatrix(),
        this.width = undefined !== n ? n: 10,
        this.height = undefined !== i ? i: 10
    }
    var r = n("7 rj8 ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isRectAreaLight: true,
        copy: function(t) {
            return r.a.prototype.copy.call(this, t),
            this.width = t.width,
            this.height = t.height,
            this
        },
        toJSON: function(t) {
            var e = r.a.prototype.toJSON.call(this, t);
            return e.object.width = this.width,
            e.object.height = this.height,
            e
        }
    })
},
iQTO: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, a, o, s, u, c, h, l, f) {
        r.a.call(this, null, o, s, u, c, h, i, a, l, f),
        this.image = {
            width: e,
            height: n
        },
        this.mipmaps = t,
        this.flipY = false,
        this.generateMipmaps = false
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("vh + C ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isCompressedTexture = true
},
iYmo: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        return this.radius = undefined !== t ? t: 1,
        this.phi = undefined !== e ? e: 0,
        this.theta = undefined !== n ? n: 0,
        this
    }
    var r = n("7 MDU ");
    Object.assign(i.prototype, {
        set: function(t, e, n) {
            return this.radius = t,
            this.phi = e,
            this.theta = n,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.radius = t.radius,
            this.phi = t.phi,
            this.theta = t.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(t) {
            return this.radius = t.length(),
            0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t.x, t.z), this.phi = Math.acos(r.a.clamp(t.y / this.radius, -1, 1))),
            this
        }
    })
},
j125: function(t, e, n) {
    "use strict ";
    function i(t) {
        var e = new r.a,
        t = t;
        Object.defineProperties(this, {
            elements: {
                get: function() {
                    return e.elements
                },
                set: function(e) {
                    t.setMatrixUpdated()
                }
            },
            obj: {
                get: function() {
                    return t
                }
            },
            mat: {
                get: function() {
                    return e
                }
            }
        })
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("6 HoM ");
    Object.assign(i.prototype, {
        isMatrix4: true,
        emitChange: function() {
            this.obj.setMatrixUpdated()
        },
        set: function(t, e, n, i, r, a, o, s, u, c, h, l, f, p, d, m) {
            return this.mat.set(t, e, n, i, r, a, o, s, u, c, h, l, f, p, d, m),
            this.emitChange(),
            this
        },
        identity: function() {
            return this.mat.identity(),
            this.emitChange(),
            this
        },
        clone: function() {
            return (new r.a).fromArray(this.elements)
        },
        copy: function(t) {
            return this.mat.copy(t),
            this.emitChange(),
            this
        },
        copyPosition: function(t) {
            return this.mat.copyPosition(t),
            this.emitChange(),
            this
        },
        extractBasis: function(t, e, n) {
            return this.mat.extractBasis(t, e, n),
            this.emitChange(),
            this
        },
        makeBasis: function(t, e, n) {
            return this.mat.makeBasis(t, e, n),
            this.emitChange(),
            this
        },
        extractRotation: function() {
            return this.mat.extractRotation(m),
            this.emitChange(),
            this
        },
        makeRotationFromEuler: function(t) {
            return this.mat.makeRotationFromEuler(t),
            this.emitChange(),
            this
        },
        makeRotationFromQuaternion: function(t) {
            return this.mat.makeRotationFromQuaternion(t),
            this.emitChange(),
            this
        },
        lookAt: function() {
            return this.mat.lookAt(eye, target, up),
            this.emitChange(),
            this
        },
        multiply: function(t, e) {
            return this.mat.multiply(t, e),
            this.emitChange(),
            this
        },
        premultiply: function(t) {
            return this.mat.multiplyMatrices(t),
            this.emitChange(),
            this
        },
        multiplyMatrices: function(t, e) {
            return this.mat.multiplyMatrices(t, e),
            this.emitChange(),
            this
        },
        multiplyScalar: function(t) {
            return this.mat.multiplyScalar(t),
            this.emitChange(),
            this
        },
        applyToBufferAttribute: function(t) {
            return this.mat.applyToBufferAttribute(t)
        },
        determinant: function() {
            return this.mat.determinant()
        },
        transpose: function() {
            return this.mat.transpose(),
            this.emitChange(),
            this
        },
        setPosition: function(t) {
            return this.mat.setPosition(),
            this.emitChange(),
            this
        },
        getInverse: function(t, e) {
            return this.mat.getInverse(t, e),
            this.emitChange(),
            this
        },
        scale: function(t) {
            return this.mat.scale(t),
            this.emitChange(),
            this
        },
        getMaxScaleOnAxis: function() {
            return this.mat.getMaxScaleOnAxis()
        },
        makeTranslation: function(t, e, n) {
            return this.mat.makeTranslation(t, e, n),
            this.emitChange(),
            this
        },
        makeRotationX: function(t) {
            return this.mat.makeRotationX(t),
            this.emitChange(),
            this
        },
        makeRotationY: function(t) {
            return this.mat.makeRotationY(t),
            this.emitChange(),
            this
        },
        makeRotationZ: function(t) {
            return this.mat.makeRotationZ(t),
            this.emitChange(),
            this
        },
        makeRotationAxis: function(t, e) {
            return this.mat.makeRotationAxis(t, e),
            this.emitChange(),
            this
        },
        makeScale: function(t, e, n) {
            return this.mat.makeScale(t, e, n),
            this.emitChange(),
            this
        },
        makeShear: function(t, e, n) {
            return this.mat.makeShear(t, e, n),
            this.emitChange(),
            this
        },
        compose: function(t, e, n) {
            return this.mat.compose(t, e, n),
            this.emitChange(),
            this
        },
        decompose: function(t, e, n) {
            return this.mat.decompose(t, e, n),
            this.emitChange(),
            this
        },
        makePerspective: function(t, e, n, i, r, a) {
            return this.mat.makeOrthographic(t, e, n, i, r, a),
            this.emitChange(),
            this
        },
        makeOrthographic: function(t, e, n, i, r, a) {
            return this.mat.makeOrthographic(t, e, n, i, r, a),
            this.emitChange(),
            this
        },
        equals: function(t) {
            return this.mat.equals(t)
        },
        fromArray: function(t, e) {
            return this.mat.fromArray(t, e),
            this.emitChange(),
            this
        },
        toArray: function(t, e) {
            return this.mat.toArray(t, e)
        }
    })
},
"j6 + M ": function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        a.a.call(this, t, e, n, i)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Vbxv "),
    a = n("9 DcM ");
    i.prototype = Object.assign(Object.create(r.a), {
        constructor: i,
        ValueTypeName: "vector "
    })
},
jv1p: function(t, e, n) {
    "use strict ";
    e.a = "# define NORMAL\\ n #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP)\\ n\\ tvarying vec3 vViewPosition;\\n # endif\\ n # ifndef FLAT_SHADED\\ n\\ tvarying vec3 vNormal;\\n # endif\\ n # include < uv_pars_vertex > \\n # include < displacementmap_pars_vertex > \\n # include < morphtarget_pars_vertex > \\n # include < skinning_pars_vertex > \\n # include < logdepthbuf_pars_vertex > \\nvoid main() {\\n\\ t # include < uv_vertex > \\n\\ t # include < beginnormal_vertex > \\n\\ t # include < morphnormal_vertex > \\n\\ t # include < skinbase_vertex > \\n\\ t # include < skinnormal_vertex > \\n\\ t # include < defaultnormal_vertex > \\n # ifndef FLAT_SHADED\\ n\\ tvNormal = normalize(transformedNormal);\\n # endif\\ n\\ t # include < begin_vertex > \\n\\ t # include < morphtarget_vertex > \\n\\ t # include < skinning_vertex > \\n\\ t # include < displacementmap_vertex > \\n\\ t # include < project_vertex > \\n\\ t # include < logdepthbuf_vertex > \\n #if defined(FLAT_SHADED) || defined(USE_BUMPMAP) || defined(USE_NORMALMAP)\\ n\\ tvViewPosition = -mvPosition.xyz;\\n # endif\\ n}\\n "
},
"k / v9 ": function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        r.a.call(this),
        this.v0 = t,
        this.v1 = e,
        this.v2 = n
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Lk8y "),
    a = n("JJh5 "),
    o = n("Ne + j ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.getPoint = function(t) {
        var e = this.v0,
        n = this.v1,
        i = this.v2;
        return new o.a(Object(a.c)(t, e.x, n.x, i.x), Object(a.c)(t, e.y, n.y, i.y))
    }
},
k1O5: function(t, e, n) {
    "use strict ";
    e.a = "varying vec2 vUv;\\nvarying vec2 sampleCoordS;\\nvarying vec2 sampleCoordE;\\n #if HIGH_QUALITY == 1\\ nvarying vec2 sampleCoordN;\\nvarying vec2 sampleCoordW;\\n # endif\\ nuniform vec2 texelSize;\\nvoid main() {\\n vUv = uv;\\n sampleCoordS = vUv + vec2(0.0, 1.0) * texelSize;\\n sampleCoordE = vUv + vec2(1.0, 0.0) * texelSize;\\n #if HIGH_QUALITY == 1\\ n sampleCoordN = vUv + vec2(0.0, -1.0) * texelSize;\\n sampleCoordW = vUv + vec2(-1.0, 0.0) * texelSize;\\n # endif\\ n gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n "
},
MeshToonMaterial: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial ",
        this.gradientMap = null,
        this.setValues(t)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("MeshPhongMaterial ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isMeshToonMaterial = true,
    i.prototype.copy = function(t) {
        return r.a.prototype.copy.call(this, t),
        this.gradientMap = t.gradientMap,
        this
    }
},
ksn3: function(t, e, n) {
    "use strict ";
    e.a = "uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n # include < common > \\n # include < color_pars_vertex > \\n # include < fog_pars_vertex > \\n # include < logdepthbuf_pars_vertex > \\n # include < clipping_planes_pars_vertex > \\nvoid main() {\\n\\ t # include < color_vertex > \\n\\ tvLineDistance = scale * lineDistance;\\n\\ tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n\\ tgl_Position = projectionMatrix * mvPosition;\\n\\ t # include < logdepthbuf_vertex > \\n\\ t # include < clipping_planes_vertex > \\n\\ t # include < fog_vertex > \\n}\\n "
},
lUBy: function(t, e, n) {
    "use strict ";
    function i(t) {
        for (var e = "",
        n = 0; n < t.length; n++) {
            var i = t[n];
            if (i < 128) e += String.fromCharCode(i);
            else if (i > 191 && i < 224) e += String.fromCharCode((31 & i) << 6 | 63 & t[n + 1]),
            n += 1;
            else if (i > 223 && i < 240) e += String.fromCharCode((15 & i) << 12 | (63 & t[n + 1]) << 6 | 63 & t[n + 2]),
            n += 2;
            else {
                var r = ((7 & i) << 18 | (63 & t[n + 1]) << 12 | (63 & t[n + 2]) << 6 | 63 & t[n + 3]) - 65536;
                e += String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320),
                n += 3
            }
        }
        return e
    }
    e.a = i
},
lUpZ: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_LIGHTMAP\\ n\\ tuniform sampler2D lightMap;\\n\\ tuniform float lightMapIntensity;\\n # endif "
},
CylinderGeometry||CylinderBufferGeometry: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, o, s, u, c) {
        a.a.call(this),
        this.type = "CylinderGeometry ",
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: o,
            openEnded: s,
            thetaStart: u,
            thetaLength: c
        },
        this.fromBufferGeometry(new r(t, e, n, i, o, s, u, c)),
        this.mergeVertices()
    }
    function r(t, e, n, i, r, a, h, l) {
        function f(n) {
            var r, a, o, s = new c.a,
            f = new u.a,
            _ = 0,
            w = true === n ? t: e,
            M = true === n ? 1 : -1;
            for (a = y, r = 1; r <= i; r++) m.push(0, x * M, 0),
            v.push(0, M, 0),
            g.push(.5, .5),
            y++;
            for (o = y, r = 0; r <= i; r++) {
                var S = r / i,
                E = S * l + h,
                T = Math.cos(E),
                A = Math.sin(E);
                f.x = w * A,
                f.y = x * M,
                f.z = w * T,
                m.push(f.x, f.y, f.z),
                v.push(0, M, 0),
                s.x = .5 * T + .5,
                s.y = .5 * A * M + .5,
                g.push(s.x, s.y),
                y++
            }
            for (r = 0; r < i; r++) {
                var C = a + r,
                P = o + r; ! 0 === n ? d.push(P, P + 1, C) : d.push(P + 1, P, C),
                _ += 3
            }
            p.addGroup(b, _, true === n ? 1 : 2),
            b += _
        }
        o.a.call(this),
        this.type = "CylinderBufferGeometry ",
        this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: i,
            heightSegments: r,
            openEnded: a,
            thetaStart: h,
            thetaLength: l
        };
        var p = this;
        t = undefined !== t ? t: 20,
        e = undefined !== e ? e: 20,
        n = undefined !== n ? n: 100,
        i = Math.floor(i) || 8,
        r = Math.floor(r) || 1,
        a = undefined !== a && a,
        h = undefined !== h ? h: 0,
        l = undefined !== l ? l: 2 * Math.PI;
        var d = [],
        m = [],
        v = [],
        g = [],
        y = 0,
        _ = [],
        x = n / 2,
        b = 0; !
        function() {
            var a, o, s = new u.a,
            c = new u.a,
            f = 0,
            w = (e - t) / n;
            for (o = 0; o <= r; o++) {
                var M = [],
                S = o / r,
                E = S * (e - t) + t;
                for (a = 0; a <= i; a++) {
                    var T = a / i,
                    A = T * l + h,
                    C = Math.sin(A),
                    P = Math.cos(A);
                    c.x = E * C,
                    c.y = -S * n + x,
                    c.z = E * P,
                    m.push(c.x, c.y, c.z),
                    s.set(C, w, P).normalize(),
                    v.push(s.x, s.y, s.z),
                    g.push(T, 1 - S),
                    M.push(y++)
                }
                _.push(M)
            }
            for (a = 0; a < i; a++) for (o = 0; o < r; o++) {
                var L = _[o][a],
                R = _[o + 1][a],
                I = _[o + 1][a + 1],
                O = _[o][a + 1];
                d.push(L, R, O),
                d.push(R, I, O),
                f += 6
            }
            p.addGroup(b, f, 0),
            b += f
        } (),
        false === a && (t > 0 && f(true), e > 0 && f(false)),
        this.setIndex(d),
        this.addAttribute("position ", new s.b(m, 3)),
        this.addAttribute("normal ", new s.b(v, 3)),
        this.addAttribute("uv ", new s.b(g, 2))
    }
    n.d(e, "b ",
    function() {
        return i
    }),
    n.d(e, "a ",
    function() {
        return r
    });
    var a = n("Geometry "),
    o = n("BufferGeometry "),
    s = n("BufferAttribute "),
    u = n("Vector3 "),
    c = n("Ne + j ");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
lt3h: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_NORMALMAP\\ n\\ tuniform sampler2D normalMap;\\n\\ tuniform vec2 normalScale;\\n\\ tvec3 perturbNormal2Arb(vec3 eye_pos, vec3 surf_norm) {\\n\\ t\\ tvec3 q0 = vec3(dFdx(eye_pos.x), dFdx(eye_pos.y), dFdx(eye_pos.z));\\n\\ t\\ tvec3 q1 = vec3(dFdy(eye_pos.x), dFdy(eye_pos.y), dFdy(eye_pos.z));\\n\\ t\\ tvec2 st0 = dFdx(vUv.st);\\n\\ t\\ tvec2 st1 = dFdy(vUv.st);\\n\\ t\\ tvec3 S = normalize(q0 * st1.t - q1 * st0.t);\\n\\ t\\ tvec3 T = normalize(-q0 * st1.s + q1 * st0.s);\\n\\ t\\ tvec3 N = normalize(surf_norm);\\n\\ t\\ tvec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;\\n\\ t\\ tmapN.xy = normalScale * mapN.xy;\\n\\ t\\ tmat3 tsn = mat3(S, T, N);\\n\\ t\\ treturn normalize(tsn * mapN);\\n\\ t}\\n # endif\\ n "
},
m6X9: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_FOG\\ n varying float fogDepth;\\n # endif\\ n "
},
SpotLight: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, s, u) {
        r.a.call(this, t, e),
        this.type = "SpotLight ",
        this.position.copy(o.a.DefaultUp),
        this.updateMatrix(),
        this.target = new o.a,
        Object.defineProperty(this, "power ", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(t) {
                this.intensity = t / Math.PI
            }
        }),
        this.distance = undefined !== n ? n: 0,
        this.angle = undefined !== i ? i: Math.PI / 3,
        this.penumbra = undefined !== s ? s: 0,
        this.decay = undefined !== u ? u: 1,
        this.shadow = new a.a
    }
    var r = n("7 rj8 "),
    a = n("bO / F "),
    o = n("87 g3 ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isSpotLight: true,
        copy: function(t) {
            return r.a.prototype.copy.call(this, t),
            this.distance = t.distance,
            this.angle = t.angle,
            this.penumbra = t.penumbra,
            this.decay = t.decay,
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    })
},
ShapeGeometry||ShapeBufferGeometry: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        a.a.call(this),
        this.type = "ShapeGeometry ",
        "object " === (undefined === e ? "undefined ": c(e)) && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments),
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        this.fromBufferGeometry(new r(t, e)),
        this.mergeVertices()
    }
    function r(t, e) {
        function n(t) {
            var n, o, s, h = r.length / 3,
            f = t.extractPoints(e),
            p = f.shape,
            d = f.holes;
            if (false === u.a.isClockWise(p)) for (p = p.reverse(), n = 0, o = d.length; n < o; n++) s = d[n],
            true === u.a.isClockWise(s) && (d[n] = s.reverse());
            var m = u.a.triangulateShape(p, d);
            for (n = 0, o = d.length; n < o; n++) s = d[n],
            p = p.concat(s);
            for (n = 0, o = p.length; n < o; n++) {
                var v = p[n];
                r.push(v.x, v.y, 0),
                a.push(0, 0, 1),
                c.push(v.x, v.y)
            }
            for (n = 0, o = m.length; n < o; n++) {
                var g = m[n],
                y = g[0] + h,
                _ = g[1] + h,
                x = g[2] + h;
                i.push(y, _, x),
                l += 3
            }
        }
        o.a.call(this),
        this.type = "ShapeBufferGeometry ",
        this.parameters = {
            shapes: t,
            curveSegments: e
        },
        e = e || 12;
        var i = [],
        r = [],
        a = [],
        c = [],
        h = 0,
        l = 0;
        if (false === Array.isArray(t)) n(t);
        else for (var f = 0; f < t.length; f++) n(t[f]),
        this.addGroup(h, l, f),
        h += l,
        l = 0;

        this.setIndex(i),
        this.addAttribute("position ", new s.b(r, 3)),
        this.addAttribute("normal ", new s.b(a, 3)),
        this.addAttribute("uv ", new s.b(c, 2))
    }
    var a = n("Geometry "),
    o = n("BufferGeometry "),
    s = n("BufferAttribute "),
    u = n("f7ra "),
    c = "function " == typeof Symbol && "symbol " == typeof Symbol.iterator ?
    function(t) {
        return typeof t
    }: function(t) {
        return t && "function " == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol ": typeof t
    };
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
mUPD: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, o, s, u, c, h, l) {
        t = undefined !== t ? t: [],
        e = undefined !== e ? e: a.k,
        r.a.call(this, t, e, n, i, o, s, u, c, h, l),
        this.flipY = false
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("vh + C "),
    a = n("RBSo ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isCubeTexture = true,
    Object.defineProperty(i.prototype, "images ", {
        get: function() {
            return this.image
        },
        set: function(t) {
            this.image = t
        }
    })
},
mUrr: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        var r = e.overrideMaterial;
        e.overrideMaterial = i,
        t.render(e, n),
        e.overrideMaterial = r
    }
    n.d(e, "b ",
    function() {
        return r
    }),
    n.d(e, "a ",
    function() {
        return h
    });
    var r, a = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    o = n("52 ZB "),
    s = n("CustomerDefine1 "),
    u = n("Oc0e "),
    c = this && this.__extends ||
    function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array &&
        function(t, e) {
            t.__proto__ = e
        } ||
        function(t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        };
        return function(e, n) {
            function i() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
        }
    } (); !
    function(t) {
        t[t.OUTLINE_ONLY = 0] = "OUTLINE_ONLY ",
        t[t.OUTLINE_WITH_SHADING = 1] = "OUTLINE_WITH_SHADING "
    } (r || (r = {}));

    var h = function(t) {
        function e() {
            var e = null !== t && t.apply(this, arguments) || this;
            return e.onModeChange = function(t) {
                e.mode = t
            },
            e.onHighQualityChange = function(t) {
                e.outlinePass.highQuality = t
            },
            e
        }
        return c(e, t),
        e.prototype.initialize = function() {
            t.prototype.initialize.call(this),
            this.renderListOutlineEnabled = new s.a,
            this.renderListOutlineDisabled = new s.a,
            this.outlinePass = new o.a,
            this.outlinePass.renderToScreen = true,
            this.blankMaterial = new a.r({
                color: 16777215
            }),
            this.config.addValueListener("engine / outline / mode ", this.onModeChange),
            this.config.addValueListener("engine / outline / highQuality ", this.onHighQualityChange),
            this.mode = this.config.getValue("engine / outline / mode ", r.OUTLINE_WITH_SHADING),
            this.outlinePass.highQuality = this.config.getValue("engine / outline / highQuality ", true)
        },
        e.prototype.updateRenderList = function(t) {
            var e = this.renderListOutlineEnabled,
            n = this.renderListOutlineDisabled;
            e.scene = t.scene,
            e.lights = t.lights,
            e.firstBatch = t.firstBatch,
            e.lastBatch = t.lastBatch,
            e.opaque.length = 0,
            e.transparent.length = 0,
            n.scene = t.scene,
            n.lights = t.lights,
            n.firstBatch = t.firstBatch,
            n.lastBatch = t.lastBatch,
            n.opaque.length = 0,
            n.transparent.length = 0;
            for (var i = 0,
            r = t.opaque; i < r.length; i++) {
                var a = r[i]; ! 1 === a.object.getNetAttribute("outline ") ? n.opaque.push(a) : e.opaque.push(a)
            }
            for (var o = 0,
            s = t.transparent; o < s.length; o++) {
                var a = s[o]; ! 1 === a.object.getNetAttribute("outline ") ? n.transparent.push(a) : e.transparent.push(a)
            }
        },
        e.prototype.render = function(t, e) {
            var n = this.renderer.autoClear;
            switch (this.renderer.autoClear = false, this.renderer.clear(), this.updateRenderList(t), this.mode) {
            case r.OUTLINE_ONLY:
                i(this.renderer, this.renderListOutlineEnabled, e, this.blankMaterial);
                break;
            case r.OUTLINE_WITH_SHADING:
                this.renderer.render(this.renderListOutlineEnabled, e)
            }
            this.outlinePass.setup(this.renderListOutlineEnabled, e),
            this.outlinePass.render(this.renderer),
            this.renderer.render(this.renderListOutlineDisabled, e),
            this.renderer.autoClear = n
        },
        e.prototype.setSize = function(t, e) {
            this.renderer.setSize(t, e);
            var n = this.renderer.getDrawingBufferSize(),
            i = n.width,
            r = n.height;
            this.outlinePass.setSize(i, r)
        },
        e.prototype.dispose = function() {
            t.prototype.dispose.call(this),
            this.outlinePass.dispose(),
            this.blankMaterial.dispose(),
            this.config.removeValueListener("engine / outline / mode ", this.onModeChange),
            this.config.removeValueListener("engine / outline / highQuality ", this.onHighQualityChange)
        },
        e
    } (u.a)
},
mdoh: function(t, e, n) {
    "use strict ";
    e.a = "float metalnessFactor = metalness;\\n # ifdef USE_METALNESSMAP\\ n\\ tvec4 texelMetalness = texture2D(metalnessMap, vUv);\\n\\ tmetalnessFactor *= texelMetalness.b;\\n # endif\\ n "
},
mrYs: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, a, o, s, u, c) {
        function h() {
            requestAnimationFrame(h),
            t.readyState >= t.HAVE_CURRENT_DATA && (l.needsUpdate = true)
        }
        r.a.call(this, t, e, n, i, a, o, s, u, c),
        this.generateMipmaps = false;
        var l = this;
        h()
    }
    var r = n("vh + C ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i
},
nBLQ: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        this.ray = new o.a(t, e),
        this.near = n || 0,
        this.far = i || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function r(t, e) {
        return t.distance - e.distance
    }
    function a(t, e, n, i) {
        if (false !== t.visible && (t.raycast(e, n), true === i)) for (var r = t.children,
        o = 0,
        s = r.length; o < s; o++) a(r[o], e, n, true)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var o = n("6 YUT ");
    Object.assign(i.prototype, {
        linePrecision: 1,
        set: function(t, e) {
            this.ray.set(t, e)
        },
        setFromCamera: function(t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(t, e) {
            var n = [];
            return a(t, this, n, e),
            n.sort(r),
            n
        },
        intersectObjects: function(t, e) {
            var n = [];
            if (false === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
            n;
            for (var i = 0,
            o = t.length; i < o; i++) a(t[i], this, n, e);
            return n.sort(r),
            n
        }
    })
},
nGOy: function(t, e, n) {
    "use strict ";
    function i(t) {
        this.manager = undefined !== t ? t: o.a
    }
    var r = n("IASN "),
    a = n("w2Sq "),
    o = n("OJZr ");
    Object.assign(i.prototype, {
        load: function(t, e, n, i) {
            var o = new a.a(this.manager);
            o.setResponseType("arraybuffer "),
            o.load(t,
            function(t) {
                r.a.getContext().decodeAudioData(t,
                function(t) {
                    e(t)
                })
            },
            n, i)
        }
    })
},
DirectGeometry: function(t, e, n) {
    "use strict ";
    function i() {
        this.indices = [],
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.verticesNeedUpdate = false,
        this.normalsNeedUpdate = false,
        this.colorsNeedUpdate = false,
        this.uvsNeedUpdate = false,
        this.groupsNeedUpdate = false
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Ne + j ");
    Object.assign(i.prototype, {
        computeGroups: function(geometry) {
            for (var e, n = [], i = undefined, r = geometry.faces, a = 0; a < r.length; a++) {
                var o = r[a];
                o.materialIndex !== i && (i = o.materialIndex, undefined !== e && (e.count = 3 * a - e.start, n.push(e)), e = {
                    start: 3 * a,
                    materialIndex: i
                })
            }
            undefined !== e && (e.count = 3 * a - e.start, n.push(e)),
            this.groups = n
        },
        fromGeometry: function(geometry) {
            var e, n = geometry.faces,
            i = geometry.vertices,
            a = geometry.faceVertexUvs,
            o = a[0] && a[0].length > 0,
            s = a[1] && a[1].length > 0,
            u = geometry.morphTargets,
            c = u.length;
            if (c > 0) {
                e = [];
                for (var h = 0; h < c; h++) e[h] = [];
                this.morphTargets.position = e
            }
            var l, f = geometry.morphNormals,
            p = f.length;
            if (p > 0) {
                l = [];
                for (var h = 0; h < p; h++) l[h] = [];
                this.morphTargets.normal = l
            }
            for (var d = geometry.skinIndices,
            m = geometry.skinWeights,
            v = d.length === i.length,
            g = m.length === i.length,
            h = 0; h < n.length; h++) {
                var y = n[h];
                this.vertices.push(i[y.a], i[y.b], i[y.c]);
                var _ = y.vertexNormals;
                if (3 === _.length) this.normals.push(_[0], _[1], _[2]);
                else {
                    var x = y.normal;
                    this.normals.push(x, x, x)
                }
                var b = y.vertexColors;
                if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                else {
                    var w = y.color;
                    this.colors.push(w, w, w)
                }
                if (true === o) {
                    var M = a[0][h];
                    undefined !== M ? this.uvs.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new r.a, new r.a, new r.a))
                }
                if (true === s) {
                    var M = a[1][h];
                    undefined !== M ? this.uvs2.push(M[0], M[1], M[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new r.a, new r.a, new r.a))
                }
                for (var S = 0; S < c; S++) {
                    var E = u[S].vertices;
                    e[S].push(E[y.a], E[y.b], E[y.c])
                }
                for (var S = 0; S < p; S++) {
                    var T = f[S].vertexNormals[h];
                    l[S].push(T.a, T.b, T.c)
                }
                v && this.skinIndices.push(d[y.a], d[y.b], d[y.c]),
                g && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(geometry),
            this.verticesNeedUpdate = geometry.verticesNeedUpdate,
            this.normalsNeedUpdate = geometry.normalsNeedUpdate,
            this.colorsNeedUpdate = geometry.colorsNeedUpdate,
            this.uvsNeedUpdate = geometry.uvsNeedUpdate,
            this.groupsNeedUpdate = geometry.groupsNeedUpdate,
            this
        }
    })
},
ne5W: function(t, e, n) {
    "use strict ";
    e.a = "#if defined(USE_ENVMAP) || defined(PHYSICAL)\\ n\\ tuniform float reflectivity;\\n\\ tuniform float envMapIntensity;\\n # endif\\ n # ifdef USE_ENVMAP\\ n\\ t #if !defined(PHYSICAL) && (defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(PHONG))\\ n\\ t\\ tvarying vec3 vWorldPosition;\\n\\ t # endif\\ n\\ t # ifdef ENVMAP_TYPE_CUBE\\ n\\ t\\ tuniform samplerCube envMap;\\n\\ t #else\\ n\\ t\\ tuniform sampler2D envMap;\\n\\ t # endif\\ n\\ tuniform float flipEnvMap;\\n\\ t #if defined(USE_BUMPMAP) || defined(USE_NORMALMAP) || defined(PHONG) || defined(PHYSICAL)\\ n\\ t\\ tuniform float refractionRatio;\\n\\ t #else\\ n\\ t\\ tvarying vec3 vReflect;\\n\\ t # endif\\ n # endif\\ n "
},
nxaU: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_SHADOWMAP\\ n\\ t #if NUM_DIR_LIGHTS > 0\\ n\\ tfor(int i = 0; i < NUM_DIR_LIGHTS; i++) {\\n\\ t\\ tvDirectionalShadowCoord[i] = directionalShadowMatrix[i] * worldPosition;\\n\\ t}\\n\\ t # endif\\ n\\ t #if NUM_SPOT_LIGHTS > 0\\ n\\ tfor(int i = 0; i < NUM_SPOT_LIGHTS; i++) {\\n\\ t\\ tvSpotShadowCoord[i] = spotShadowMatrix[i] * worldPosition;\\n\\ t}\\n\\ t # endif\\ n\\ t #if NUM_POINT_LIGHTS > 0\\ n\\ tfor(int i = 0; i < NUM_POINT_LIGHTS; i++) {\\n\\ t\\ tvPointShadowCoord[i] = pointShadowMatrix[i] * worldPosition;\\n\\ t}\\n\\ t # endif\\ n # endif\\ n "
},
LineSegments: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        r.a.call(this, t, e),
        this.type = "LineSegments "
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Line ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isLineSegments: true
    })
},
oTdC: function(t, e, n) {
    "use strict ";
    e.a = "vec3 diffuse = vec3(1.0);\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize(transformedNormal);\\ngeometry.viewDir = normalize(-mvPosition.xyz);\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3(0.0);\\n # ifdef DOUBLE_SIDED\\ n\\ tvLightBack = vec3(0.0);\\n # endif\\ nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n #if NUM_POINT_LIGHTS > 0\\ n\\ tfor(int i = 0; i < NUM_POINT_LIGHTS; i++) {\\n\\ t\\ tgetPointDirectLightIrradiance(pointLights[i], geometry, directLight);\\n\\ t\\ tdotNL = dot(geometry.normal, directLight.direction);\\n\\ t\\ tdirectLightColor_Diffuse = PI * directLight.color;\\n\\ t\\ tvLightFront += saturate(dotNL) * directLightColor_Diffuse;\\n\\ t\\ t # ifdef DOUBLE_SIDED\\ n\\ t\\ t\\ tvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\\n\\ t\\ t # endif\\ n\\ t}\\n # endif\\ n #if NUM_SPOT_LIGHTS > 0\\ n\\ tfor(int i = 0; i < NUM_SPOT_LIGHTS; i++) {\\n\\ t\\ tgetSpotDirectLightIrradiance(spotLights[i], geometry, directLight);\\n\\ t\\ tdotNL = dot(geometry.normal, directLight.direction);\\n\\ t\\ tdirectLightColor_Diffuse = PI * directLight.color;\\n\\ t\\ tvLightFront += saturate(dotNL) * directLightColor_Diffuse;\\n\\ t\\ t # ifdef DOUBLE_SIDED\\ n\\ t\\ t\\ tvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\\n\\ t\\ t # endif\\ n\\ t}\\n # endif\\ n #if NUM_DIR_LIGHTS > 0\\ n\\ tfor(int i = 0; i < NUM_DIR_LIGHTS; i++) {\\n\\ t\\ tgetDirectionalDirectLightIrradiance(directionalLights[i], geometry, directLight);\\n\\ t\\ tdotNL = dot(geometry.normal, directLight.direction);\\n\\ t\\ tdirectLightColor_Diffuse = PI * directLight.color;\\n\\ t\\ tvLightFront += saturate(dotNL) * directLightColor_Diffuse;\\n\\ t\\ t # ifdef DOUBLE_SIDED\\ n\\ t\\ t\\ tvLightBack += saturate(-dotNL) * directLightColor_Diffuse;\\n\\ t\\ t # endif\\ n\\ t}\\n # endif\\ n #if NUM_HEMI_LIGHTS > 0\\ n\\ tfor(int i = 0; i < NUM_HEMI_LIGHTS; i++) {\\n\\ t\\ tvLightFront += getHemisphereLightIrradiance(hemisphereLights[i], geometry);\\n\\ t\\ t # ifdef DOUBLE_SIDED\\ n\\ t\\ t\\ tvLightBack += getHemisphereLightIrradiance(hemisphereLights[i], backGeometry);\\n\\ t\\ t # endif\\ n\\ t}\\n # endif\\ n "
},
Matrix3: function(t, e, n) {
    "use strict ";
    function i() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments.use.set() instead.")
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Vector3 ");
    Object.assign(i.prototype, {
        isMatrix3: true,
        set: function(t, e, n, i, r, a, o, s, u) {
            var c = this.elements;
            return c[0] = t,
            c[1] = i,
            c[2] = o,
            c[3] = e,
            c[4] = r,
            c[5] = s,
            c[6] = n,
            c[7] = a,
            c[8] = u,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(t) {
            var e = this.elements,
            n = t.elements;
            return e[0] = n[0],
            e[1] = n[1],
            e[2] = n[2],
            e[3] = n[3],
            e[4] = n[4],
            e[5] = n[5],
            e[6] = n[6],
            e[7] = n[7],
            e[8] = n[8],
            this
        },
        setFromMatrix4: function(t) {
            var e = t.elements;
            return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
        },
        applyToBufferAttribute: function() {
            var t;
            return function(e) {
                undefined === t && (t = new r.a);
                for (var n = 0,
                i = e.count; n < i; n++) t.x = e.getX(n),
                t.y = e.getY(n),
                t.z = e.getZ(n),
                t.applyMatrix3(this),
                e.setXYZ(n, t.x, t.y, t.z);
                return e
            }
        } (),
        multiply: function(t) {
            return this.multiplyMatrices(this, t)
        },
        premultiply: function(t) {
            return this.multiplyMatrices(t, this)
        },
        multiplyMatrices: function(t, e) {
            var n = t.elements,
            i = e.elements,
            r = this.elements,
            a = n[0],
            o = n[3],
            s = n[6],
            u = n[1],
            c = n[4],
            h = n[7],
            l = n[2],
            f = n[5],
            p = n[8],
            d = i[0],
            m = i[3],
            v = i[6],
            g = i[1],
            y = i[4],
            _ = i[7],
            x = i[2],
            b = i[5],
            w = i[8];
            return r[0] = a * d + o * g + s * x,
            r[3] = a * m + o * y + s * b,
            r[6] = a * v + o * _ + s * w,
            r[1] = u * d + c * g + h * x,
            r[4] = u * m + c * y + h * b,
            r[7] = u * v + c * _ + h * w,
            r[2] = l * d + f * g + p * x,
            r[5] = l * m + f * y + p * b,
            r[8] = l * v + f * _ + p * w,
            this
        },
        multiplyScalar: function(t) {
            var e = this.elements;
            return e[0] *= t,
            e[3] *= t,
            e[6] *= t,
            e[1] *= t,
            e[4] *= t,
            e[7] *= t,
            e[2] *= t,
            e[5] *= t,
            e[8] *= t,
            this
        },
        determinant: function() {
            var t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            a = t[4],
            o = t[5],
            s = t[6],
            u = t[7],
            c = t[8];
            return e * a * c - e * o * u - n * r * c + n * o * s + i * r * u - i * a * s
        },
        getInverse: function(t, e) {
            t && t.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
            var n = t.elements,
            i = this.elements,
            r = n[0],
            a = n[1],
            o = n[2],
            s = n[3],
            u = n[4],
            c = n[5],
            h = n[6],
            l = n[7],
            f = n[8],
            p = f * u - c * l,
            d = c * h - f * s,
            m = l * s - u * h,
            v = r * p + a * d + o * m;
            if (0 === v) {
                var g = "THREE.Matrix3.getInverse(): can 't invert matrix, determinant is 0";
                if (true === e) throw new Error(g);
                return console.warn(g),
                this.identity()
            }
            var y = 1 / v;
            return i[0] = p * y,
            i[1] = (o * l - f * a) * y,
            i[2] = (c * a - o * u) * y,
            i[3] = d * y,
            i[4] = (f * r - o * h) * y,
            i[5] = (o * s - c * r) * y,
            i[6] = m * y,
            i[7] = (a * h - l * r) * y,
            i[8] = (u * r - a * s) * y,
            this
        },
        transpose: function() {
            var t, e = this.elements;
            return t = e[1],
            e[1] = e[3],
            e[3] = t,
            t = e[2],
            e[2] = e[6],
            e[6] = t,
            t = e[5],
            e[5] = e[7],
            e[7] = t,
            this
        },
        getNormalMatrix: function(t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        },
        transposeIntoArray: function(t) {
            var e = this.elements;
            return t[0] = e[0],
            t[1] = e[3],
            t[2] = e[6],
            t[3] = e[1],
            t[4] = e[4],
            t[5] = e[7],
            t[6] = e[2],
            t[7] = e[5],
            t[8] = e[8],
            this
        },
        equals: function(t) {
            for (var e = this.elements,
            n = t.elements,
            i = 0; i < 9; i++) if (e[i] !== n[i]) return ! 1;
            return ! 0
        },
        fromArray: function(t, e) {
            undefined === e && (e = 0);
            for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this
        },
        toArray: function(t, e) {
            undefined === t && (t = []),
            undefined === e && (e = 0);
            var n = this.elements;
            return t[e] = n[0],
            t[e + 1] = n[1],
            t[e + 2] = n[2],
            t[e + 3] = n[3],
            t[e + 4] = n[4],
            t[e + 5] = n[5],
            t[e + 6] = n[6],
            t[e + 7] = n[7],
            t[e + 8] = n[8],
            t
        }
    })
},
oYVd: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_ROUGHNESSMAP\\n\\tuniform sampler2D roughnessMap;\\n#endif"
},
oaXl: function(t, e, n) {
    "use strict";
    e.a = "uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\\n}\\n"
},
"onH+": function(t, e, n) {
    "use strict";
    function i(t, e, n) {
        o.a.call(this, t, e, n)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("RBSo"),
    a = n("Vbxv"),
    o = n("9DcM");
    i.prototype = Object.assign(Object.create(a.a), {
        constructor: i,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: r.K,
        InterpolantFactoryMethodLinear: undefined,
        InterpolantFactoryMethodSmooth: undefined
    })
},
Vector3: function(t, e, n) {
    "use strict";
    function i(t, e, n) {
        this.x = t || 0,
        this.y = e || 0,
        this.z = n || 0
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("_Math"),
    a = n("Matrix4"),
    o = n("Quaternion");
    Object.assign(i.prototype, {
        isVector3: true,
        set: function(t, e, n) {
            return this.x = t,
            this.y = e,
            this.z = n,
            this
        },
        setScalar: function(t) {
            return this.x = t,
            this.y = t,
            this.z = t,
            this
        },
        setX: function(t) {
            return this.x = t,
            this
        },
        setY: function(t) {
            return this.y = t,
            this
        },
        setZ: function(t) {
            return this.z = t,
            this
        },
        setComponent: function(t, e) {
            switch (t) {
            case 0:
                this.x = e;
                break;
            case 1:
                this.y = e;
                break;
            case 2:
                this.z = e;
                break;
            default:
                throw new Error("index is out of range: " + t)
            }
            return this
        },
        getComponent: function(t) {
            switch (t) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + t)
            }
        },
        clone: function() {
            return new this.constructor(this.x, this.y, this.z)
        },
        copy: function(t) {
            return this.x = t.x,
            this.y = t.y,
            this.z = t.z,
            this
        },
        add: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        },
        addScalar: function(t) {
            return this.x += t,
            this.y += t,
            this.z += t,
            this
        },
        addVectors: function(t, e) {
            return this.x = t.x + e.x,
            this.y = t.y + e.y,
            this.z = t.z + e.z,
            this
        },
        addScaledVector: function(t, e) {
            return this.x += t.x * e,
            this.y += t.y * e,
            this.z += t.z * e,
            this
        },
        sub: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        },
        subScalar: function(t) {
            return this.x -= t,
            this.y -= t,
            this.z -= t,
            this
        },
        subVectors: function(t, e) {
            return this.x = t.x - e.x,
            this.y = t.y - e.y,
            this.z = t.z - e.z,
            this
        },
        multiply: function(t, e) {
            return undefined !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        },
        multiplyScalar: function(t) {
            return this.x *= t,
            this.y *= t,
            this.z *= t,
            this
        },
        multiplyVectors: function(t, e) {
            return this.x = t.x * e.x,
            this.y = t.y * e.y,
            this.z = t.z * e.z,
            this
        },
        applyEuler: function() {
            var t;
            return function(e) {
                return undefined === t && (t = new o.a),
                e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
                this.applyQuaternion(t.setFromEuler(e))
            }
        } (),
        applyAxisAngle: function() {
            var t;
            return function(e, n) {
                return undefined === t && (t = new o.a),
                this.applyQuaternion(t.setFromAxisAngle(e, n))
            }
        } (),
        applyMatrix3: function(t) {
            var e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
            return this.x = r[0] * e + r[3] * n + r[6] * i,
            this.y = r[1] * e + r[4] * n + r[7] * i,
            this.z = r[2] * e + r[5] * n + r[8] * i,
            this
        },
        applyMatrix4: function(t) {
            var e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements,
            a = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * a,
            this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * a,
            this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * a,
            this
        },
        applyQuaternion: function(t) {
            var e = this.x,
            n = this.y,
            i = this.z,
            r = t.x,
            a = t.y,
            o = t.z,
            s = t.w,
            u = s * e + a * i - o * n,
            c = s * n + o * e - r * i,
            h = s * i + r * n - a * e,
            l = -r * e - a * n - o * i;
            return this.x = u * s + l * -r + c * -o - h * -a,
            this.y = c * s + l * -a + h * -r - u * -o,
            this.z = h * s + l * -o + u * -a - c * -r,
            this
        },
        project: function() {
            var t;
            return function(e) {
                return undefined === t && (t = new a.a),
                t.multiplyMatrices(e.projectionMatrix, t.getInverse(e.matrixWorld)),
                this.applyMatrix4(t)
            }
        } (),
        unproject: function() {
            var t;
            return function(e) {
                return undefined === t && (t = new a.a),
                t.multiplyMatrices(e.matrixWorld, t.getInverse(e.projectionMatrix)),
                this.applyMatrix4(t)
            }
        } (),
        transformDirection: function(t) {
            var e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
            return this.x = r[0] * e + r[4] * n + r[8] * i,
            this.y = r[1] * e + r[5] * n + r[9] * i,
            this.z = r[2] * e + r[6] * n + r[10] * i,
            this.normalize()
        },
        divide: function(t) {
            return this.x /= t.x,
            this.y /= t.y,
            this.z /= t.z,
            this
        },
        divideScalar: function(t) {
            return this.multiplyScalar(1 / t)
        },
        min: function(t) {
            return this.x = Math.min(this.x, t.x),
            this.y = Math.min(this.y, t.y),
            this.z = Math.min(this.z, t.z),
            this
        },
        max: function(t) {
            return this.x = Math.max(this.x, t.x),
            this.y = Math.max(this.y, t.y),
            this.z = Math.max(this.z, t.z),
            this
        },
        clamp: function(t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)),
            this.y = Math.max(t.y, Math.min(e.y, this.y)),
            this.z = Math.max(t.z, Math.min(e.z, this.z)),
            this
        },
        clampScalar: function() {
            var t, e;
            return function(n, r) {
                return undefined === t && (t = new i),
                undefined === e && (e = new i),
                t.set(n, n, n),
                e.set(r, r, r),
                this.clamp(t, e)
            }
        } (),
        clampLength: function(t, e) {
            var n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        lengthManhattan: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(t) {
            return this.normalize().multiplyScalar(t)
        },
        lerp: function(t, e) {
            return this.x += (t.x - this.x) * e,
            this.y += (t.y - this.y) * e,
            this.z += (t.z - this.z) * e,
            this
        },
        lerpVectors: function(t, e, n) {
            return this.subVectors(e, t).multiplyScalar(n).add(t)
        },
        cross: function(t, e) {
            if (undefined !== e) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(t, e);
            var n = this.x,
            i = this.y,
            r = this.z;
            return this.x = i * t.z - r * t.y,
            this.y = r * t.x - n * t.z,
            this.z = n * t.y - i * t.x,
            this
        },
        crossVectors: function(t, e) {
            var n = t.x,
            i = t.y,
            r = t.z,
            a = e.x,
            o = e.y,
            s = e.z;
            return this.x = i * s - r * o,
            this.y = r * a - n * s,
            this.z = n * o - i * a,
            this
        },
        projectOnVector: function(t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        },
        projectOnPlane: function() {
            var t;
            return function(e) {
                return undefined === t && (t = new i),
                t.copy(this).projectOnVector(e),
                this.sub(t)
            }
        } (),
        reflect: function() {
            var t;
            return function(e) {
                return undefined === t && (t = new i),
                this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        } (),
        angleTo: function(t) {
            var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
            return Math.acos(r.a.clamp(e, -1, 1))
        },
        distanceTo: function(t) {
            return Math.sqrt(this.distanceToSquared(t))
        },
        distanceToSquared: function(t) {
            var e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z;
            return e * e + n * n + i * i
        },
        distanceToManhattan: function(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        },
        setFromSpherical: function(t) {
            var e = Math.sin(t.phi) * t.radius;
            return this.x = e * Math.sin(t.theta),
            this.y = Math.cos(t.phi) * t.radius,
            this.z = e * Math.cos(t.theta),
            this
        },
        setFromCylindrical: function(t) {
            return this.x = t.radius * Math.sin(t.theta),
            this.y = t.y,
            this.z = t.radius * Math.cos(t.theta),
            this
        },
        setFromMatrixPosition: function(t) {
            var e = t.elements;
            return this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
        },
        setFromMatrixScale: function(t) {
            var e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length();
            return this.x = e,
            this.y = n,
            this.z = i,
            this
        },
        setFromMatrixColumn: function(t, e) {
            return this.fromArray(t.elements, 4 * e)
        },
        equals: function(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        },
        fromArray: function(t, e) {
            return undefined === e && (e = 0),
            this.x = t[e],
            this.y = t[e + 1],
            this.z = t[e + 2],
            this
        },
        toArray: function(t, e) {
            return undefined === t && (t = []),
            undefined === e && (e = 0),
            t[e] = this.x,
            t[e + 1] = this.y,
            t[e + 2] = this.z,
            t
        },
        fromBufferAttribute: function(t, e, n) {
            return undefined !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = t.getX(e),
            this.y = t.getY(e),
            this.z = t.getZ(e),
            this
        }
    })
},
opdS: function(t, e, n) {
    "use strict";
    //getEncodingComponents
    function i(t) {
        switch (t) {
        case y.P:
            return ["Linear", "( value )"];
        case y._65:
            return ["sRGB", "( value )"];
        case y._29:
            return ["RGBE", "( value )"];
        case y._32:
            return ["RGBM", "( value, 7.0 )"];
        case y._31:
            return ["RGBM", "( value, 16.0 )"];
        case y._28:
            return ["RGBD", "( value, 256.0 )"];
        case y.F:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw new Error("unsupported encoding: " + t)
        }
    }

    //getTexelDecodingFunction
    function r(t, e) {
        var n = i(e);
        return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }
    //getTexelEncodingFunction
    function a(t, e) {
        var n = i(e);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }
    //getToneMappingFunction
    function o(t, e) {
        var n;
        switch (e) {
        case y.T:
            n = "Linear";
            break;
        case y._37:
            n = "Reinhard";
            break;
        case y._52:
            n = "Uncharted2";
            break;
        case y.i:
            n = "OptimizedCineon";
            break;
        default:
            throw new Error("unsupported toneMapping: " + e)
        }
        return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }
    //generateExtensions
    function s(t, e, n) {
        return t = t || {},
        [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable": "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable": "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require": "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable": ""].filter(h).join("\\n")
    }
    //generateDefines
    function u(t) {
        var e = [];
        for (var n in t) {
            var i = t[n]; ! 1 !== i && e.push("#define " + n + " " + i)
        }
        return e.join("\\n")
    }
    //fetchAttributeLocations
    function c(t, e, n) {
        for (var i = {},
        r = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), a = 0; a < r; a++) {
            var o = t.getActiveAttrib(e, a),
            s = o.name;
            i[s] = t.getAttribLocation(e, s)
        }
        return i
    }
    //filterEmptyLine
    function h(t) {
        return "" !== t
    }
    //replaceLightNums
    function l(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }
    //parseIncludes
    function f(t) {
        function e(t, e) {
            var n = g.a[e];
            if (undefined === n) throw new Error("Can not resolve #include <" + e + ">");
            return f(n)
        }
        var n = /^[ \\t]*#include +<([\\w\\d.]+)>/gm;
        return t.replace(n, e)
    }
    //unrollLoops
    function p(t) {
        function e(t, e, n, i) {
            for (var r = "",
            a = parseInt(e); a < parseInt(n); a++) r += i.replace(/\\[ i \\]/g, "[ " + a + " ]");
            return r
        }
        var n = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;
        return t.replace(n, e)
    }
    //WebGLProgram
    function d(t, e, n, i, d) {
        var x = t.context,
        b = n.extensions,
        w = n.defines,
        M = i.vertexShader,
        S = i.fragmentShader,
        E = "SHADOWMAP_TYPE_BASIC";
        d.shadowMapType === y._19 ? E = "SHADOWMAP_TYPE_PCF": d.shadowMapType === y._20 && (E = "SHADOWMAP_TYPE_PCF_SOFT");
        var T = "ENVMAP_TYPE_CUBE",
        A = "ENVMAP_MODE_REFLECTION",
        C = "ENVMAP_BLENDING_MULTIPLY";
        if (d.envMap) {
            switch (n.envMap.mapping) {
            case y.k:
            case y.l:
                T = "ENVMAP_TYPE_CUBE";
                break;
            case y.m:
            case y.n:
                T = "ENVMAP_TYPE_CUBE_UV";
                break;
            case y.y:
            case y.z:
                T = "ENVMAP_TYPE_EQUIREC";
                break;
            case y._42:
                T = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
            case y.l:
            case y.z:
                A = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
            case y._4:
                C = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case y._2:
                C = "ENVMAP_BLENDING_MIX";
                break;
            case y.b:
                C = "ENVMAP_BLENDING_ADD"
            }
        }
        var P, L, R = t.gammaFactor > 0 ? t.gammaFactor: 1,
        I = s(b, d, t.extensions),
        O = u(w),
        N = x.createProgram();
        n.isRawShaderMaterial ? (P = [O, "\\n"].filter(h).join("\\n"), L = [I, O, "\\n"].filter(h).join("\\n")) : (P = ["precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + i.name, O, d.supportsVertexTextures ? "#define VERTEX_TEXTURES": "", "#define GAMMA_FACTOR " + R, "#define MAX_BONES " + d.maxBones, d.useFog && d.fog ? "#define USE_FOG": "", d.useFog && d.fogExp ? "#define FOG_EXP2": "", d.map ? "#define USE_MAP": "", d.envMap ? "#define USE_ENVMAP": "", d.envMap ? "#define " + A: "", d.lightMap ? "#define USE_LIGHTMAP": "", d.aoMap ? "#define USE_AOMAP": "", d.emissiveMap ? "#define USE_EMISSIVEMAP": "", d.bumpMap ? "#define USE_BUMPMAP": "", d.normalMap ? "#define USE_NORMALMAP": "", d.displacementMap && d.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP": "", d.specularMap ? "#define USE_SPECULARMAP": "", d.roughnessMap ? "#define USE_ROUGHNESSMAP": "", d.metalnessMap ? "#define USE_METALNESSMAP": "", d.alphaMap ? "#define USE_ALPHAMAP": "", d.vertexColors ? "#define USE_COLOR": "", d.flatShading ? "#define FLAT_SHADED": "", d.skinning ? "#define USE_SKINNING": "", d.useVertexTexture ? "#define BONE_TEXTURE": "", d.morphTargets ? "#define USE_MORPHTARGETS": "", d.morphNormals && false === d.flatShading ? "#define USE_MORPHNORMALS": "", d.doubleSided ? "#define DOUBLE_SIDED": "", d.flipSided ? "#define FLIP_SIDED": "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, d.shadowMapEnabled ? "#define USE_SHADOWMAP": "", d.shadowMapEnabled ? "#define " + E: "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION": "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF": "", d.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT": "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\\tattribute vec3 morphTarget0;", "\\tattribute vec3 morphTarget1;", "\\tattribute vec3 morphTarget2;", "\\tattribute vec3 morphTarget3;", "\\t#ifdef USE_MORPHNORMALS", "\\t\\tattribute vec3 morphNormal0;", "\\t\\tattribute vec3 morphNormal1;", "\\t\\tattribute vec3 morphNormal2;", "\\t\\tattribute vec3 morphNormal3;", "\\t#else", "\\t\\tattribute vec3 morphTarget4;", "\\t\\tattribute vec3 morphTarget5;", "\\t\\tattribute vec3 morphTarget6;", "\\t\\tattribute vec3 morphTarget7;", "\\t#endif", "#endif", "#ifdef USE_SKINNING", "\\tattribute vec4 skinIndex;", "\\tattribute vec4 skinWeight;", "#endif", "\\n"].filter(h).join("\\n"), L = [I, "precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + i.name, O, d.alphaTest ? "#define ALPHATEST " + d.alphaTest: "", "#define GAMMA_FACTOR " + R, d.useFog && d.fog ? "#define USE_FOG": "", d.useFog && d.fogExp ? "#define FOG_EXP2": "", d.map ? "#define USE_MAP": "", d.envMap ? "#define USE_ENVMAP": "", d.envMap ? "#define " + T: "", d.envMap ? "#define " + A: "", d.envMap ? "#define " + C: "", d.lightMap ? "#define USE_LIGHTMAP": "", d.aoMap ? "#define USE_AOMAP": "", d.emissiveMap ? "#define USE_EMISSIVEMAP": "", d.bumpMap ? "#define USE_BUMPMAP": "", d.normalMap ? "#define USE_NORMALMAP": "", d.specularMap ? "#define USE_SPECULARMAP": "", d.roughnessMap ? "#define USE_ROUGHNESSMAP": "", d.metalnessMap ? "#define USE_METALNESSMAP": "", d.alphaMap ? "#define USE_ALPHAMAP": "", d.vertexColors ? "#define USE_COLOR": "", d.gradientMap ? "#define USE_GRADIENTMAP": "", d.flatShading ? "#define FLAT_SHADED": "", d.doubleSided ? "#define DOUBLE_SIDED": "", d.flipSided ? "#define FLIP_SIDED": "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, "#define UNION_CLIPPING_PLANES " + (d.numClippingPlanes - d.numClipIntersection), d.shadowMapEnabled ? "#define USE_SHADOWMAP": "", d.shadowMapEnabled ? "#define " + E: "", d.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA": "", d.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS": "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF": "", d.logarithmicDepthBuffer && t.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT": "", d.envMap && t.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT": "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", d.toneMapping !== y._11 ? "#define TONE_MAPPING": "", d.toneMapping !== y._11 ? g.a.tonemapping_pars_fragment: "", d.toneMapping !== y._11 ? o("toneMapping", d.toneMapping) : "", d.dithering ? "#define DITHERING": "", d.outputEncoding || d.mapEncoding || d.envMapEncoding || d.emissiveMapEncoding ? g.a.encodings_pars_fragment: "", d.mapEncoding ? r("mapTexelToLinear", d.mapEncoding) : "", d.envMapEncoding ? r("envMapTexelToLinear", d.envMapEncoding) : "", d.emissiveMapEncoding ? r("emissiveMapTexelToLinear", d.emissiveMapEncoding) : "", d.outputEncoding ? a("linearToOutputTexel", d.outputEncoding) : "", d.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking: "", "\\n"].filter(h).join("\\n")),
        M = f(M),
        M = l(M, d),
        S = f(S),
        S = l(S, d),
        n.isShaderMaterial || (M = p(M), S = p(S));
        var D = P + M,
        U = L + S,
        B = Object(v.a)(x, x.VERTEX_SHADER, D),
        z = Object(v.a)(x, x.FRAGMENT_SHADER, U);
        x.attachShader(N, B),
        x.attachShader(N, z),
        undefined !== n.index0AttributeName ? x.bindAttribLocation(N, 0, n.index0AttributeName) : true === d.morphTargets && x.bindAttribLocation(N, 0, "position"),
        x.linkProgram(N);
        var F = x.getProgramInfoLog(N),
        j = x.getShaderInfoLog(B),
        k = x.getShaderInfoLog(z),
        V = true,
        G = true; ! 1 === x.getProgramParameter(N, x.LINK_STATUS) ? (V = false, console.error("THREE.WebGLProgram: shader error: ", x.getError(), "gl.VALIDATE_STATUS", x.getProgramParameter(N, x.VALIDATE_STATUS), "gl.getProgramInfoLog", F, j, k)) : "" !== F ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", F) : "" !== j && "" !== k || (G = false),
        G && (this.diagnostics = {
            runnable: V,
            material: n,
            programLog: F,
            vertexShader: {
                log: j,
                prefix: P
            },
            fragmentShader: {
                log: k,
                prefix: L
            }
        }),
        x.deleteShader(B),
        x.deleteShader(z);
        var H;
        this.getUniforms = function() {
            return undefined === H && (H = new m.a(x, N, t)),
            H
        };
        var W;
        return this.getAttributes = function() {
            return undefined === W && (W = c(x, N)),
            W
        },
        this.destroy = function() {
            x.deleteProgram(N),
            this.program = undefined
        },
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                    this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes()
                }
            }
        }),
        this.id = _++,
        this.code = e,
        this.usedTimes = 1,
        this.program = N,
        this.vertexShader = B,
        this.fragmentShader = z,
        this
    }
    n.d(e, "a",
    function() {
        return d
    });
    var m = n("TRUI"),
    v = n("XPJB"),
    g = n("WqzK"),
    y = n("RBSo"),
    _ = 0
},
"CustomerDefine2": function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return o
    });
    var i = n("CustomerDefine1"),
    r = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    a = new r.J,
    o = function() {
        function t(t, e) {
            var n = this;
            this.engine = null,
            this.model = null,
            this.frags = null,
            this.size = 0,
            this.wantCameraDistance = true,
            this.lastBatch = false,
            this.firstBatch = true,
            this.addLight = function(t) {
                n.engine.testLightVisibility(t) && n.renderList.lights.push(t)
            },
            this.addSprite = function(t) {
                n.engine.testSpriteVisibility(t) && n.renderList.sprites.push(t)
            },
            this.engine = t,
            this.model = t.doc.model,
            this.renderList = new i.a,
            this.deferredRenderList = new i.a,
            this.size = 0,
            this.capacity = e
        }
        return t.prototype.reset = function(t) { (null == this.frags || t > this.capacity) && (this.capacity = t, this.frags = new Int32Array(this.capacity)),
            this.size = 0,
            this.renderList.init(),
            this.lastBatch = false
        },
        t.prototype.addRenderItem = function(t, e, n, i, r) {
            this.renderList.addRenderItem(t, e, n, i, r)
        },
        t.prototype.updateRenderList = function() {
            this.renderList.init(),
            this.firstBatch && this.model.lights.lights.forEach(this.addLight),
            this.lastBatch && (this.model.sprites.sprites.forEach(this.addSprite), this.deferredRenderList.addRenderItemDone(), this.renderList.transparent.push.apply(this.renderList.transparent, this.deferredRenderList.transparent), this.renderList.transparentLastIndex = this.deferredRenderList.transparentLastIndex, this.deferredRenderList.init());
            for (var t = this.model.geometries.geometries,
            e = this.model.materials.materials,
            n = this.model.objects.objects,
            i = this.model.fragments,
            r = 0; r < this.size; r++) {
                var o = this.frags[r];
                if (1 !== this.model.fragments.tombs[o]) {
                    var s = n.data[i.objects[o]],
                    u = t.data[i.geometries[o]],
                    c = e.data[i.materials[o]],
                    h = i.materialIndexs[o];
                    this.wantCameraDistance && a.setFromMatrixPosition(s.matrixWorld).applyMatrix4(this.model.projScreenMatrix),
                    this.engine.customObjectFilter(s) || c.visible && (this.engine.shouldSkipByDetailCullingWithBoxArray(this.model.fragments.boxes, o) || (Array.isArray(s.material) ? this.addRenderItem(s, u, c, a.z, u.groups[h]) : this.addRenderItem(s, u, c, a.z, null)))
                }
            }
            this.renderList.addRenderItemDone(),
            this.renderList.sort(),
            this.renderList.firstBatch = this.firstBatch,
            this.renderList.lastBatch = this.lastBatch,
            this.renderList.scene = this.model.scene
        },
        t
    } ()
},
BoxGeometry||BoxBufferGeometry: function(t, e, n) {
    "use strict";
    function i(t, e, n, i, o, s) {
        a.a.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: o,
            depthSegments: s
        },
        this.fromBufferGeometry(new r(t, e, n, i, o, s)),
        this.mergeVertices()
    }
    function r(t, e, n, i, r, a) {
        function c(t, e, n, i, r, a, o, s, c, g, y) {
            var _, x, b = a / c,
            w = o / g,
            M = a / 2,
            S = o / 2,
            E = s / 2,
            T = c + 1,
            A = g + 1,
            C = 0,
            P = 0,
            L = new u.a;
            for (x = 0; x < A; x++) {
                var R = x * w - S;
                for (_ = 0; _ < T; _++) {
                    var I = _ * b - M;
                    L[t] = I * i,
                    L[e] = R * r,
                    L[n] = E,
                    f.push(L.x, L.y, L.z),
                    L[t] = 0,
                    L[e] = 0,
                    L[n] = s > 0 ? 1 : -1,
                    p.push(L.x, L.y, L.z),
                    d.push(_ / c),
                    d.push(1 - x / g),
                    C += 1
                }
            }
            for (x = 0; x < g; x++) for (_ = 0; _ < c; _++) {
                var O = m + _ + T * x,
                N = m + _ + T * (x + 1),
                D = m + (_ + 1) + T * (x + 1),
                U = m + (_ + 1) + T * x;
                l.push(O, N, U),
                l.push(N, D, U),
                P += 6
            }
            h.addGroup(v, P, y),
            v += P,
            m += C
        }
        o.a.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: a
        };
        var h = this;
        i = Math.floor(i) || 1,
        r = Math.floor(r) || 1,
        a = Math.floor(a) || 1;
        var l = [],
        f = [],
        p = [],
        d = [],
        m = 0,
        v = 0;
        c("z", "y", "x", -1, -1, n, e, t, a, r, 0),
        c("z", "y", "x", 1, -1, n, e, -t, a, r, 1),
        c("x", "z", "y", 1, 1, t, n, e, i, a, 2),
        c("x", "z", "y", 1, -1, t, n, -e, i, a, 3),
        c("x", "y", "z", 1, -1, t, e, n, i, r, 4),
        c("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
        this.setIndex(l),
        this.addAttribute("position", new s.b(f, 3)),
        this.addAttribute("normal", new s.b(p, 3)),
        this.addAttribute("uv", new s.b(d, 2))
    }
    n.d(e, "a",
    function() {
        return r
    });
    var a = n("Geometry"),
    o = n("BufferGeometry"),
    s = n("BufferAttribute"),
    u = n("Vector3");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
pAuK: function(t, e, n) {
    "use strict";
    function i(t) {
        if (0 === t.length) return - 1 / 0;
        for (var e = t[0], n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
        return e
    }
    n.d(e, "a",
    function() {
        return i
    })
},
pINk: function(t, e, n) {
    "use strict";
    function i(t, e, n, i) {
        a.a.call(this, t, e, n, i)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Vbxv"),
    a = n("9DcM");
    i.prototype = Object.assign(Object.create(r.a), {
        constructor: i,
        ValueTypeName: "number"
    })
},
Frustum: function(t, e, n) {
    "use strict";
    function i(t, e, n, i, r, a) {
        this.planes = [undefined !== t ? t: new o.a, undefined !== e ? e: new o.a, undefined !== n ? n: new o.a, undefined !== i ? i: new o.a, undefined !== r ? r: new o.a, undefined !== a ? a: new o.a]
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Vector3"),
    a = n("Sphere"),
    o = n("Plane");
    Object.assign(i.prototype, {
        set: function(t, e, n, i, r, a) {
            var o = this.planes;
            return o[0].copy(t),
            o[1].copy(e),
            o[2].copy(n),
            o[3].copy(i),
            o[4].copy(r),
            o[5].copy(a),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            for (var e = this.planes,
            n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this
        },
        setFromMatrix: function(t) {
            var e = this.planes,
            n = t.elements,
            i = n[0],
            r = n[1],
            a = n[2],
            o = n[3],
            s = n[4],
            u = n[5],
            c = n[6],
            h = n[7],
            l = n[8],
            f = n[9],
            p = n[10],
            d = n[11],
            m = n[12],
            v = n[13],
            g = n[14],
            y = n[15];
            return e[0].setComponents(o - i, h - s, d - l, y - m).normalize(),
            e[1].setComponents(o + i, h + s, d + l, y + m).normalize(),
            e[2].setComponents(o + r, h + u, d + f, y + v).normalize(),
            e[3].setComponents(o - r, h - u, d - f, y - v).normalize(),
            e[4].setComponents(o - a, h - c, d - p, y - g).normalize(),
            e[5].setComponents(o + a, h + c, d + p, y + g).normalize(),
            this
        },
        intersectsObject: function() {
            var t = new a.a;
            return function(e) {
                var n = e.geometry;
                return null === n.boundingSphere && n.computeBoundingSphere(),
                t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
            }
        } (),
        intersectsSprite: function() {
            var t = new a.a;
            return function(e) {
                return t.center.set(0, 0, 0),
                t.radius = .7071067811865476,
                t.applyMatrix4(e.matrixWorld),
                this.intersectsSphere(t)
            }
        } (),
        intersectsSphere: function(t) {
            for (var e = this.planes,
            n = t.center,
            i = -t.radius,
            r = 0; r < 6; r++) {
                if (e[r].distanceToPoint(n) < i) return ! 1
            }
            return ! 0
        },
        intersectsBox: function() {
            var t = new r.a,
            e = new r.a;
            return function(n) {
                for (var i = this.planes,
                r = 0; r < 6; r++) {
                    var a = i[r];
                    t.x = a.normal.x > 0 ? n.min.x: n.max.x,
                    e.x = a.normal.x > 0 ? n.max.x: n.min.x,
                    t.y = a.normal.y > 0 ? n.min.y: n.max.y,
                    e.y = a.normal.y > 0 ? n.max.y: n.min.y,
                    t.z = a.normal.z > 0 ? n.min.z: n.max.z,
                    e.z = a.normal.z > 0 ? n.max.z: n.min.z;
                    var o = a.distanceToPoint(t),
                    s = a.distanceToPoint(e);
                    if (o < 0 && s < 0) return ! 1
                }
                return ! 0
            }
        } (),
        containsPoint: function(t) {
            for (var e = this.planes,
            n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return ! 1;
            return ! 0
        }
    })
},
pi2b: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return p
    });
    var i = n("mUrr"),
    r = n("gIE0"),
    a = n("ChZQ"),
    o = n("ytBM"),
    s = n("UKz4"),
    u = n("OCJR"),
    c = n("9XRc"),
    h = n("+oY6"),
    l = n("4wub"),
    f = n("LKd5"),
    p = function() {
        function t() {
            var t = this;
            this.onConfigurationChanged = function() {
                t.requestRender()
            },
            this.onSceneChanged = function() {
                t.requestRender()
            },
            this.onReuqestRender = function() {
                t.requestRender()
            },
            this.statistics = new l.a,
            this.configuration = new h.a(this, {})
        }
        return Object.defineProperty(t.prototype, "scene", {
            get: function() {
                return this.doc.scene
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(t.prototype, "camera", {
            get: function() {
                return this.engine ? this.engine.camera: null
            },
            enumerable: true,
            configurable: true
        }),
        Object.defineProperty(t.prototype, "doc", {
            get: function() {
                return this._doc
            },
            enumerable: true,
            configurable: true
        }),
        t.prototype.initialize = function(t) {
            var e = this;
            this.configuration.addValueListener("engine", this.onConfigurationChanged),
            this.canvasContainer = t;
            var n = document.createElement("canvas");
            n.tabIndex = 0,
            n.viewer = this,
            this.canvasContainer.appendChild(n),
            this.canvas = n,
            this._doc = new s.a,
            this.doc.addListener("scenedoc-changed",
            function() {
                return e.onSceneChanged()
            }),
            this.engine = new r.a(n, this._doc, this.configuration),
            this.engine.onRequestRender = this.onReuqestRender,
            this.engine.initialize(),
            o.a.getInstance().emit(f.a, {
                target: this,
                width: this.engine.width,
                height: this.engine.height
            })
        },
        t.prototype.uninitialize = function() {
            this.requestRenderHandler = null,
            this.configuration.removeValueListener("engine", this.onConfigurationChanged),
            this.doc.removeListener("scenedoc-changed", this.onSceneChanged),
            this.engine.uninitialize(),
            this.canvasContainer.removeChild(this.canvas),
            this.canvasContainer = null,
            this.canvas = null,
            this.engine = null,
            o.a.getInstance().emit(f.b, {
                target: this
            })
        },
        t.prototype.setScene = function(t) {
            this.doc.scene !== t && this.doc.setScene(t)
        },
        t.prototype.setCamera = function(t) {
            this.camera !== t && (this.doc.setCamera(t), this.engine.setCamera(t))
        },
        t.prototype.getCamera = function() {
            return this.engine.camera
        },
        t.prototype.setRenderMode = function(t) {
            switch (t) {
            case a.a.SHADING:
                this.configuration.setValue("engine/outline/enabled", false);
                break;
            case a.a.OUTLINE_ONLY:
                this.configuration.setValue("engine/outline/enabled", true),
                this.configuration.setValue("engine/outline/mode", i.b.OUTLINE_ONLY);
                break;
            case a.a.OUTLINE_WITH_SHADING:
                this.configuration.setValue("engine/outline/enabled", true),
                this.configuration.setValue("engine/outline/mode", i.b.OUTLINE_WITH_SHADING)
            }
        },
        t.prototype.setBackgroundColor = function(t) {
            this.engine.setBackgroundColor(t)
        },
        t.prototype.render = function(t) {
            this.engine.performanceMonitor.rafBeginTime = t || undefined,
            this.engine.render(),
            this.engine.needsContinueRender && this.requestRender()
        },
        t.prototype.requestRender = function() {
            this.requestRenderHandler && this.requestRenderHandler()
        },
        t.prototype.resize = function(t) {
            this.engine.resize(t),
            o.a.getInstance().emit(f.a, {
                target: this,
                width: this.engine.width,
                height: this.engine.height
            }),
            this.requestRender()
        },
        t.prototype.getRenderStatistics = function() {
            return this.engine.getRenderStatistics(this.statistics),
            this.statistics
        },
        t.prototype.getSize = function() {
            return new c.a(this.engine.width, this.engine.height)
        },
        t.prototype.getCanvasElement = function() {
            return this.engine.getCanvasElement()
        },
        t.prototype.getEngine = function() {
            return this.engine
        },
        t.prototype.createPicker = function() {
            return new u.a(this)
        },
        t
    } ()
},
piF5: function(t, e, n) {
    "use strict";
    function i(t, e, n) {
        function i(t) {
            var i = n.frame,
            r = t.geometry,
            o = e.get(t, r);
            return a[o.id] !== i && (r.isGeometry && o.updateFromObject(t), e.update(o), a[o.id] = i),
            o
        }
        function r() {
            a = {}
        }
        var a = {};
        return {
            update: i,
            clear: r
        }
    }
    n.d(e, "a",
    function() {
        return i
    })
},
PlaneGeometry||PlaneBufferGeometry: function(t, e, n) {
    "use strict";
    function i(t, e, n, i) {
        a.a.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        },
        this.fromBufferGeometry(new r(t, e, n, i)),
        this.mergeVertices()
    }
    function PlaneBufferGeometry(t, e, n, i) {
        o.a.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i
        };
        var r, a, u = t / 2,
        c = e / 2,
        h = Math.floor(n) || 1,
        l = Math.floor(i) || 1,
        f = h + 1,
        p = l + 1,
        d = t / h,
        m = e / l,
        v = [],
        g = [],
        y = [],
        _ = [];
        for (a = 0; a < p; a++) {
            var x = a * m - c;
            for (r = 0; r < f; r++) {
                var b = r * d - u;
                g.push(b, -x, 0),
                y.push(0, 0, 1),
                _.push(r / h),
                _.push(1 - a / l)
            }
        }
        for (a = 0; a < l; a++) for (r = 0; r < h; r++) {
            var w = r + f * a,
            M = r + f * (a + 1),
            S = r + 1 + f * (a + 1),
            E = r + 1 + f * a;
            v.push(w, M, E),
            v.push(M, S, E)
        }
        this.setIndex(v),
        this.addAttribute("position", new s.b(g, 3)),
        this.addAttribute("normal", new s.b(y, 3)),
        this.addAttribute("uv", new s.b(_, 2))
    }
    n.d(e, "a",
    function() {
        return PlaneBufferGeometry
    });
    var a = n("Geometry"),
    o = n("BufferGeometry"),
    s = n("BufferAttribute");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
qICY: function(t, e, n) {
    "use strict";
    function i(t) {
        this._root = t,
        this._initMemoryManager(),
        this._accuIndex = 0,
        this.time = 0,
        this.timeScale = 1
    }
    var r = n("sHJs"),
    a = n("EventDispatcher"),
    o = n("WVM5"),
    s = n("2seR"),
    u = n("Byt3"),
    c = n("JzlU");
    Object.assign(i.prototype, a.a.prototype, {
        _bindAction: function(t, e) {
            var n = t._localRoot || this._root,
            i = t._clip.tracks,
            r = i.length,
            a = t._propertyBindings,
            o = t._interpolants,
            c = n.uuid,
            h = this._bindingsByRootAndName,
            l = h[c];
            undefined === l && (l = {},
            h[c] = l);
            for (var f = 0; f !== r; ++f) {
                var p = i[f],
                d = p.name,
                m = l[d];
                if (undefined !== m) a[f] = m;
                else {
                    if (undefined !== (m = a[f])) {
                        null === m._cacheIndex && (++m.referenceCount, this._addInactiveBinding(m, c, d));
                        continue
                    }
                    var v = e && e._propertyBindings[f].binding.parsedPath;
                    m = new u.a(s.a.create(n, d, v), p.ValueTypeName, p.getValueSize()),
                    ++m.referenceCount,
                    this._addInactiveBinding(m, c, d),
                    a[f] = m
                }
                o[f].resultBuffer = m.buffer
            }
        },
        _activateAction: function(t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    var e = (t._localRoot || this._root).uuid,
                    n = t._clip.uuid,
                    i = this._actionsByClip[n];
                    this._bindAction(t, i && i.knownActions[0]),
                    this._addInactiveAction(t, n, e)
                }
                for (var r = t._propertyBindings,
                a = 0,
                o = r.length; a !== o; ++a) {
                    var s = r[a];
                    0 == s.useCount++&&(this._lendBinding(s), s.saveOriginalState())
                }
                this._lendAction(t)
            }
        },
        _deactivateAction: function(t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings,
                n = 0,
                i = e.length; n !== i; ++n) {
                    var r = e[n];
                    0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(t)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    },
                    get inUse() {
                        return t._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return t._bindings.length
                    },
                    get inUse() {
                        return t._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    },
                    get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(t) {
            var e = t._cacheIndex;
            return null !== e && e < this._nActiveActions
        },
        _addInactiveAction: function(t, e, n) {
            var i = this._actions,
            r = this._actionsByClip,
            a = r[e];
            if (undefined === a) a = {
                knownActions: [t],
                actionByRoot: {}
            },
            t._byClipCacheIndex = 0,
            r[e] = a;
            else {
                var o = a.knownActions;
                t._byClipCacheIndex = o.length,
                o.push(t)
            }
            t._cacheIndex = i.length,
            i.push(t),
            a.actionByRoot[n] = t
        },
        _removeInactiveAction: function(t) {
            var e = this._actions,
            n = e[e.length - 1],
            i = t._cacheIndex;
            n._cacheIndex = i,
            e[i] = n,
            e.pop(),
            t._cacheIndex = null;
            var r = t._clip.uuid,
            a = this._actionsByClip,
            o = a[r],
            s = o.knownActions,
            u = s[s.length - 1],
            c = t._byClipCacheIndex;
            u._byClipCacheIndex = c,
            s[c] = u,
            s.pop(),
            t._byClipCacheIndex = null,
            delete o.actionByRoot[(t._localRoot || this._root).uuid],
            0 === s.length && delete a[r],
            this._removeInactiveBindingsForAction(t)
        },
        _removeInactiveBindingsForAction: function(t) {
            for (var e = t._propertyBindings,
            n = 0,
            i = e.length; n !== i; ++n) {
                var r = e[n];
                0 == --r.referenceCount && this._removeInactiveBinding(r)
            }
        },
        _lendAction: function(t) {
            var e = this._actions,
            n = t._cacheIndex,
            i = this._nActiveActions++,
            r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _takeBackAction: function(t) {
            var e = this._actions,
            n = t._cacheIndex,
            i = --this._nActiveActions,
            r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _addInactiveBinding: function(t, e, n) {
            var i = this._bindingsByRootAndName,
            r = i[e],
            a = this._bindings;
            undefined === r && (r = {},
            i[e] = r),
            r[n] = t,
            t._cacheIndex = a.length,
            a.push(t)
        },
        _removeInactiveBinding: function(t) {
            var e = this._bindings,
            n = t.binding,
            i = n.rootNode.uuid,
            r = n.path,
            a = this._bindingsByRootAndName,
            o = a[i],
            s = e[e.length - 1],
            u = t._cacheIndex;
            s._cacheIndex = u,
            e[u] = s,
            e.pop(),
            delete o[r];
            t: {
                for (var c in o) break t;
                delete a[i]
            }
        },
        _lendBinding: function(t) {
            var e = this._bindings,
            n = t._cacheIndex,
            i = this._nActiveBindings++,
            r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _takeBackBinding: function(t) {
            var e = this._bindings,
            n = t._cacheIndex,
            i = --this._nActiveBindings,
            r = e[i];
            t._cacheIndex = i,
            e[i] = t,
            r._cacheIndex = n,
            e[n] = r
        },
        _lendControlInterpolant: function() {
            var t = this._controlInterpolants,
            e = this._nActiveControlInterpolants++,
            n = t[e];
            return undefined === n && (n = new o.a(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n),
            n
        },
        _takeBackControlInterpolant: function(t) {
            var e = this._controlInterpolants,
            n = t.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = e[i];
            t.__cacheIndex = i,
            e[i] = t,
            r.__cacheIndex = n,
            e[n] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(t, e) {
            var n = e || this._root,
            i = n.uuid,
            a = "string" == typeof t ? c.a.findByName(n, t) : t,
            o = null !== a ? a.uuid: t,
            s = this._actionsByClip[o],
            u = null;
            if (undefined !== s) {
                var h = s.actionByRoot[i];
                if (undefined !== h) return h;
                u = s.knownActions[0],
                null === a && (a = u._clip)
            }
            if (null === a) return null;
            var l = new r.a(this, a, e);
            return this._bindAction(l, u),
            this._addInactiveAction(l, o, i),
            l
        },
        existingAction: function(t, e) {
            var n = e || this._root,
            i = n.uuid,
            r = "string" == typeof t ? c.a.findByName(n, t) : t,
            a = r ? r.uuid: t,
            o = this._actionsByClip[a];
            return undefined !== o ? o.actionByRoot[i] || null: null
        },
        stopAllAction: function() {
            var t = this._actions,
            e = this._nActiveActions,
            n = this._bindings,
            i = this._nActiveBindings;
            this._nActiveActions = 0,
            this._nActiveBindings = 0;
            for (var r = 0; r !== e; ++r) t[r].reset();
            for (var r = 0; r !== i; ++r) n[r].useCount = 0;
            return this
        },
        update: function(t) {
            t *= this.timeScale;
            for (var e = this._actions,
            n = this._nActiveActions,
            i = this.time += t,
            r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
                e[o]._update(i, t, r, a)
            }
            for (var s = this._bindings,
            u = this._nActiveBindings,
            o = 0; o !== u; ++o) s[o].apply(a);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(t) {
            var e = this._actions,
            n = t.uuid,
            i = this._actionsByClip,
            r = i[n];
            if (undefined !== r) {
                for (var a = r.knownActions,
                o = 0,
                s = a.length; o !== s; ++o) {
                    var u = a[o];
                    this._deactivateAction(u);
                    var c = u._cacheIndex,
                    h = e[e.length - 1];
                    u._cacheIndex = null,
                    u._byClipCacheIndex = null,
                    h._cacheIndex = c,
                    e[c] = h,
                    e.pop(),
                    this._removeInactiveBindingsForAction(u)
                }
                delete i[n]
            }
        },
        uncacheRoot: function(t) {
            var e = t.uuid,
            n = this._actionsByClip;
            for (var i in n) {
                var r = n[i].actionByRoot,
                a = r[e];
                undefined !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
            }
            var o = this._bindingsByRootAndName,
            s = o[e];
            if (undefined !== s) for (var u in s) {
                var c = s[u];
                c.restoreOriginalState(),
                this._removeInactiveBinding(c)
            }
        },
        uncacheAction: function(t, e) {
            var n = this.existingAction(t, e);
            null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
        }
    })
},
qIOK: function(t, e, n) {
    "use strict";
    e.a = "uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\nvoid main() {\\n\\tvec3 direction = normalize( vWorldPosition );\\n\\tvec2 sampleUV;\\n\\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n}\\n"
},
DirectionalLight: function(t, e, n) {
    "use strict";
    function i(t, e) {
        r.a.call(this, t, e),
        this.type = "DirectionalLight",
        this.position.copy(o.a.DefaultUp),
        this.updateMatrix(),
        this.target = new o.a,
        this.shadow = new a.a
    }
    var r = n("Light"),
    a = n("tAH4"),
    o = n("Object3D");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isDirectionalLight: true,
        copy: function(t) {
            return r.a.prototype.copy.call(this, t),
            this.target = t.target.clone(),
            this.shadow = t.shadow.clone(),
            this
        }
    })
},
qavu: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_LIGHTMAP\\n\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n"
},
qjPn: function(t, e, n) {
    "use strict";
    function i(t) {
        function e() {
            return null === St ? Ut: 1
        }
        function n() {
            ie.init(),
            ie.scissor(Lt.copy(Bt).multiplyScalar(Ut)),
            ie.viewport(It.copy(Ft).multiplyScalar(Ut))
        }
        function i() {
            Mt = null,
            Ct = null,
            At = "",
            Tt = -1,
            ie.reset()
        }
        function D(t) {
            t.preventDefault(),
            i(),
            n(),
            re.clear(),
            ue.clear()
        }
        function U(t) {
            var e = t.target;
            e.removeEventListener("dispose", U),
            B(e)
        }
        function B(t) {
            z(t),
            re.remove(t)
        }
        function z(t) {
            var e = re.get(t).program;
            t.program = undefined,
            undefined !== e && ce.releaseProgram(e)
        }
        function F(t, e, n) {
            t.render(function(t) {
                wt.renderBufferImmediate(t, e, n)
            })
        }
        function j(t, e) {
            return Math.abs(e[0]) - Math.abs(t[0])
        }
        function k(t, e, n, i) {
            if (n && n.isInstancedBufferGeometry && null === ee.get("ANGLE_instanced_arrays")) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            undefined === i && (i = 0),
            ie.initAttributes();
            var r = n.attributes,
            a = e.getAttributes(),
            o = t.defaultAttributeValues;
            for (var s in a) {
                var u = a[s];
                if (u >= 0) {
                    var c = r[s];
                    if (undefined !== c) {
                        var h = c.normalized,
                        l = c.itemSize,
                        f = oe.get(c),
                        p = f.buffer,
                        d = f.type,
                        m = f.bytesPerElement;
                        if (c.isInterleavedBufferAttribute) {
                            var v = c.data,
                            g = v.stride,
                            y = c.offset;
                            v && v.isInstancedInterleavedBuffer ? (ie.enableAttributeAndDivisor(u, v.meshPerAttribute), undefined === n.maxInstancedCount && (n.maxInstancedCount = v.meshPerAttribute * v.count)) : ie.enableAttribute(u),
                            $t.bindBuffer($t.ARRAY_BUFFER, p),
                            $t.vertexAttribPointer(u, l, d, h, g * m, (i * g + y) * m)
                        } else c.isInstancedBufferAttribute ? (ie.enableAttributeAndDivisor(u, c.meshPerAttribute), undefined === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : ie.enableAttribute(u),
                        $t.bindBuffer($t.ARRAY_BUFFER, p),
                        $t.vertexAttribPointer(u, l, d, h, 0, i * l * m)
                    } else if (undefined !== o) {
                        var _ = o[s];
                        if (undefined !== _) switch (_.length) {
                        case 2:
                            $t.vertexAttrib2fv(u, _);
                            break;
                        case 3:
                            $t.vertexAttrib3fv(u, _);
                            break;
                        case 4:
                            $t.vertexAttrib4fv(u, _);
                            break;
                        default:
                            $t.vertexAttrib1fv(u, _)
                        }
                    }
                }
            }
            ie.disableUnusedAttributes()
        }
        function V(t, e, n) {
            if (t.visible) {
                if (t.layers.test(e.layers)) if (t.isLight) gt.push(t);
                else if (t.isSprite) t.frustumCulled && !jt.intersectsSprite(t) || xt.push(t);
                else if (t.isLensFlare) bt.push(t);
                else if (t.isImmediateRenderObject) n && Wt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Ht),
                yt.push(t, null, t.material, Wt.z, null);
                else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || jt.intersectsObject(t))) {
                    n && Wt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Ht);
                    var i = ue.update(t),
                    r = t.material;
                    if (Array.isArray(r)) for (var a = i.groups,
                    o = 0,
                    s = a.length; o < s; o++) {
                        var u = a[o],
                        c = r[u.materialIndex];
                        c && c.visible && yt.push(t, i, c, Wt.z, u)
                    } else r.visible && yt.push(t, i, r, Wt.z, null)
                }
                for (var h = t.children,
                o = 0,
                s = h.length; o < s; o++) V(h[o], e, n)
            }
        }
        function G(t, e, n, i) {
            for (var r = 0,
            a = t.length; r < a; r++) {
                var o = t[r],
                s = o.object,
                u = o.geometry,
                c = undefined === i ? o.material: i,
                h = o.group;
                if (n.isArrayCamera) {
                    Pt = n;
                    for (var l = n.cameras,
                    f = 0,
                    p = l.length; f < p; f++) {
                        var d = l[f];
                        if (s.layers.test(d.layers)) {
                            var m = d.bounds,
                            v = m.x * Nt,
                            g = m.y * Dt,
                            y = m.z * Nt,
                            _ = m.w * Dt;
                            wt.setViewport(v, g, y, _),
                            wt.setScissor(v, g, y, _),
                            wt.setScissorTest(true),
                            H(s, e, d, u, c, h)
                        }
                    }
                } else Pt = null,
                H(s, e, n, u, c, h)
            }
        }
        function H(t, e, n, i, r, a) {
            if (t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.onBeforeRender(wt, e, n, i, r, a), t.isImmediateRenderObject) {
                ie.setMaterial(r);
                var o = X(n, e.fog, r, t);
                At = "",
                F(t, o, r)
            } else wt.renderBufferDirect(n, e.fog, i, r, t, a);
            t.onAfterRender(wt, e, n, i, r, a)
        }
        function W(t, e, n) {
            var i = re.get(t),
            r = ce.getParameters(t, Yt, e, kt.numPlanes, kt.numIntersection, n),
            a = ce.getProgramCode(t, r),
            o = i.program,
            s = true;
            if (undefined === o) t.addEventListener("dispose", U);
            else if (o.code !== a) z(t);
            else {
                if (undefined !== r.shaderID) return;
                s = false
            }
            if (s) {
                if (r.shaderID) {
                    var c = l.a[r.shaderID];
                    i.shader = {
                        name: t.type,
                        uniforms: h.a.clone(c.uniforms),
                        vertexShader: c.vertexShader,
                        fragmentShader: c.fragmentShader
                    }
                } else i.shader = {
                    name: t.type,
                    uniforms: t.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                };
                t.onBeforeCompile(i.shader),
                o = ce.acquireProgram(t, i.shader, r, a),
                i.program = o,
                t.program = o
            }
            var f = o.getAttributes();
            if (t.morphTargets) {
                t.numSupportedMorphTargets = 0;
                for (var p = 0; p < wt.maxMorphTargets; p++) f["morphTarget" + p] >= 0 && t.numSupportedMorphTargets++
            }
            if (t.morphNormals) {
                t.numSupportedMorphNormals = 0;
                for (var p = 0; p < wt.maxMorphNormals; p++) f["morphNormal" + p] >= 0 && t.numSupportedMorphNormals++
            }
            var d = i.shader.uniforms; (t.isShaderMaterial || t.isRawShaderMaterial) && true !== t.clipping || (i.numClippingPlanes = kt.numPlanes, i.numIntersection = kt.numIntersection, d.clippingPlanes = kt.uniform),
            i.fog = e,
            i.lightsHash = Yt.hash,
            t.lights && (d.ambientLightColor.value = Yt.ambient, d.directionalLights.value = Yt.directional, d.spotLights.value = Yt.spot, d.rectAreaLights.value = Yt.rectArea, d.pointLights.value = Yt.point, d.hemisphereLights.value = Yt.hemi, d.directionalShadowMap.value = Yt.directionalShadowMap, d.directionalShadowMatrix.value = Yt.directionalShadowMatrix, d.spotShadowMap.value = Yt.spotShadowMap, d.spotShadowMatrix.value = Yt.spotShadowMatrix, d.pointShadowMap.value = Yt.pointShadowMap, d.pointShadowMatrix.value = Yt.pointShadowMatrix);
            var m = i.program.getUniforms(),
            v = u.a.seqWithValue(m.seq, d);
            i.uniformsList = v
        }
        function X(t, e, n, i) {
            Ot = 0;
            var o = re.get(n);
            if (Vt && (Gt || t !== Ct)) {
                var h = t === Ct && n.id === Tt;
                kt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, o, h)
            } ! 1 === n.needsUpdate && (undefined === o.program ? n.needsUpdate = true : n.fog && o.fog !== e ? n.needsUpdate = true : n.lights && o.lightsHash !== Yt.hash ? n.needsUpdate = true : undefined === o.numClippingPlanes || o.numClippingPlanes === kt.numPlanes && o.numIntersection === kt.numIntersection || (n.needsUpdate = true)),
            n.needsUpdate && (W(n, e, i), n.needsUpdate = false);
            var l = false,
            f = false,
            p = false,
            d = o.program,
            m = d.getUniforms(),
            v = o.shader.uniforms;
            if (d.id !== Mt && ($t.useProgram(d.program), Mt = d.id, l = true, f = true, p = true), n.id !== Tt && (Tt = n.id, f = true), l || t !== Ct) {
                if (m.setValue($t, "projectionMatrix", t.projectionMatrix), ne.logarithmicDepthBuffer && m.setValue($t, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), Ct !== (Pt || t) && (Ct = Pt || t, f = true, p = true), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                    var g = m.map.cameraPosition;
                    undefined !== g && g.setValue($t, Wt.setFromMatrixPosition(t.matrixWorld))
                } (n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && m.setValue($t, "viewMatrix", t.matrixWorldInverse)
            }
            if (n.skinning) {
                m.setOptional($t, i, "bindMatrix"),
                m.setOptional($t, i, "bindMatrixInverse");
                var y = i.skeleton;
                if (y) {
                    var _ = y.bones;
                    if (ne.floatVertexTextures) {
                        if (undefined === y.boneTexture) {
                            var x = Math.sqrt(4 * _.length);
                            x = a.a.nextPowerOfTwo(Math.ceil(x)),
                            x = Math.max(x, 4);
                            var b = new Float32Array(x * x * 4);
                            b.set(y.boneMatrices);
                            var w = new s.a(b, x, x, r._22, r.C);
                            y.boneMatrices = b,
                            y.boneTexture = w,
                            y.boneTextureSize = x
                        }
                        m.setValue($t, "boneTexture", y.boneTexture),
                        m.setValue($t, "boneTextureSize", y.boneTextureSize)
                    } else m.setOptional($t, y, "boneMatrices")
                }
            }
            return f && (m.setValue($t, "toneMappingExposure", wt.toneMappingExposure), m.setValue($t, "toneMappingWhitePoint", wt.toneMappingWhitePoint), n.lights && rt(v, p), e && n.fog && Q(v, e), (n.isMeshBasicMaterial || n.isMeshLambertMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.isMeshNormalMaterial || n.isMeshDepthMaterial) && q(v, n), n.isLineBasicMaterial ? Y(v, n) : n.isLineDashedMaterial ? (Y(v, n), Z(v, n)) : n.isPointsMaterial ? J(v, n) : n.isMeshLambertMaterial ? K(v, n) : n.isMeshToonMaterial ? tt(v, n) : n.isMeshPhongMaterial ? $(v, n) : n.isMeshPhysicalMaterial ? nt(v, n) : n.isMeshStandardMaterial ? et(v, n) : n.isMeshDepthMaterial ? n.displacementMap && (v.displacementMap.value = n.displacementMap, v.displacementScale.value = n.displacementScale, v.displacementBias.value = n.displacementBias) : n.isMeshNormalMaterial && it(v, n), undefined !== v.ltcMat && (v.ltcMat.value = c.a.LTC_MAT_TEXTURE), undefined !== v.ltcMag && (v.ltcMag.value = c.a.LTC_MAG_TEXTURE), u.a.upload($t, o.uniformsList, v, wt)),
            m.setValue($t, "modelViewMatrix", i.modelViewMatrix),
            m.setValue($t, "normalMatrix", i.normalMatrix),
            m.setValue($t, "modelMatrix", i.matrixWorld),
            d
        }
        function q(t, e) {
            t.opacity.value = e.opacity,
            t.diffuse.value = e.color,
            e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
            t.map.value = e.map,
            t.specularMap.value = e.specularMap,
            t.alphaMap.value = e.alphaMap,
            e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity),
            e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity);
            var n;
            if (e.map ? n = e.map: e.specularMap ? n = e.specularMap: e.displacementMap ? n = e.displacementMap: e.normalMap ? n = e.normalMap: e.bumpMap ? n = e.bumpMap: e.roughnessMap ? n = e.roughnessMap: e.metalnessMap ? n = e.metalnessMap: e.alphaMap ? n = e.alphaMap: e.emissiveMap && (n = e.emissiveMap), undefined !== n) {
                n.isWebGLRenderTarget && (n = n.texture);
                var i = n.offset,
                r = n.repeat;
                t.offsetRepeat.value.set(i.x, i.y, r.x, r.y)
            }
            t.envMap.value = e.envMap,
            t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1,
            t.reflectivity.value = e.reflectivity,
            t.refractionRatio.value = e.refractionRatio
        }
        function Y(t, e) {
            t.diffuse.value = e.color,
            t.opacity.value = e.opacity
        }
        function Z(t, e) {
            t.dashSize.value = e.dashSize,
            t.totalSize.value = e.dashSize + e.gapSize,
            t.scale.value = e.scale
        }
        function J(t, e) {
            if (t.diffuse.value = e.color, t.opacity.value = e.opacity, t.size.value = e.size * Ut, t.scale.value = .5 * Dt, t.map.value = e.map, null !== e.map) {
                var n = e.map.offset,
                i = e.map.repeat;
                t.offsetRepeat.value.set(n.x, n.y, i.x, i.y)
            }
        }
        function Q(t, e) {
            t.fogColor.value = e.color,
            e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
        }
        function K(t, e) {
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
        }
        function $(t, e) {
            t.specular.value = e.specular,
            t.shininess.value = Math.max(e.shininess, 1e-4),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale),
            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)),
            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }
        function tt(t, e) {
            $(t, e),
            e.gradientMap && (t.gradientMap.value = e.gradientMap)
        }
        function et(t, e) {
            t.roughness.value = e.roughness,
            t.metalness.value = e.metalness,
            e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
            e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale),
            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)),
            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias),
            e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }
        function nt(t, e) {
            t.clearCoat.value = e.clearCoat,
            t.clearCoatRoughness.value = e.clearCoatRoughness,
            et(t, e)
        }
        function it(t, e) {
            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale),
            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale)),
            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }
        function rt(t, e) {
            t.ambientLightColor.needsUpdate = e,
            t.directionalLights.needsUpdate = e,
            t.pointLights.needsUpdate = e,
            t.spotLights.needsUpdate = e,
            t.rectAreaLights.needsUpdate = e,
            t.hemisphereLights.needsUpdate = e
        }
        function at(t) {
            for (var e = 0,
            n = 0,
            i = t.length; n < i; n++) {
                var r = t[n];
                r.castShadow && (Yt.shadows[e] = r, e++)
            }
            Yt.shadows.length = e
        }
        function ot(t, e) {
            var n, i, r, a, o, s, u, c, h = 0,
            l = 0,
            f = 0,
            p = e.matrixWorldInverse,
            d = 0,
            m = 0,
            v = 0,
            g = 0,
            y = 0;
            for (n = 0, i = t.length; n < i; n++) if (r = t[n], o = r.color, s = r.intensity, u = r.distance, c = r.shadow && r.shadow.map ? r.shadow.map.texture: null, r.isAmbientLight) h += o.r * s,
            l += o.g * s,
            f += o.b * s;
            else if (r.isDirectionalLight) {
                var _ = he.get(r);
                _.color.copy(r.color).multiplyScalar(r.intensity),
                _.direction.setFromMatrixPosition(r.matrixWorld),
                Wt.setFromMatrixPosition(r.target.matrixWorld),
                _.direction.sub(Wt),
                _.direction.transformDirection(p),
                _.shadow = r.castShadow,
                r.castShadow && (a = r.shadow, _.shadowBias = a.bias, _.shadowRadius = a.radius, _.shadowMapSize = a.mapSize),
                Yt.directionalShadowMap[d] = c,
                Yt.directionalShadowMatrix[d] = r.shadow.matrix,
                Yt.directional[d] = _,
                d++
            } else if (r.isSpotLight) {
                var _ = he.get(r);
                _.position.setFromMatrixPosition(r.matrixWorld),
                _.position.applyMatrix4(p),
                _.color.copy(o).multiplyScalar(s),
                _.distance = u,
                _.direction.setFromMatrixPosition(r.matrixWorld),
                Wt.setFromMatrixPosition(r.target.matrixWorld),
                _.direction.sub(Wt),
                _.direction.transformDirection(p),
                _.coneCos = Math.cos(r.angle),
                _.penumbraCos = Math.cos(r.angle * (1 - r.penumbra)),
                _.decay = 0 === r.distance ? 0 : r.decay,
                _.shadow = r.castShadow,
                r.castShadow && (a = r.shadow, _.shadowBias = a.bias, _.shadowRadius = a.radius, _.shadowMapSize = a.mapSize),
                Yt.spotShadowMap[v] = c,
                Yt.spotShadowMatrix[v] = r.shadow.matrix,
                Yt.spot[v] = _,
                v++
            } else if (r.isRectAreaLight) {
                var _ = he.get(r);
                _.color.copy(o).multiplyScalar(s / (r.width * r.height)),
                _.position.setFromMatrixPosition(r.matrixWorld),
                _.position.applyMatrix4(p),
                qt.identity(),
                Xt.copy(r.matrixWorld),
                Xt.premultiply(p),
                qt.extractRotation(Xt),
                _.halfWidth.set(.5 * r.width, 0, 0),
                _.halfHeight.set(0, .5 * r.height, 0),
                _.halfWidth.applyMatrix4(qt),
                _.halfHeight.applyMatrix4(qt),
                Yt.rectArea[g] = _,
                g++
            } else if (r.isPointLight) {
                var _ = he.get(r);
                _.position.setFromMatrixPosition(r.matrixWorld),
                _.position.applyMatrix4(p),
                _.color.copy(r.color).multiplyScalar(r.intensity),
                _.distance = r.distance,
                _.decay = 0 === r.distance ? 0 : r.decay,
                _.shadow = r.castShadow,
                r.castShadow && (a = r.shadow, _.shadowBias = a.bias, _.shadowRadius = a.radius, _.shadowMapSize = a.mapSize),
                Yt.pointShadowMap[m] = c,
                Yt.pointShadowMatrix[m] = r.shadow.matrix,
                Yt.point[m] = _,
                m++
            } else if (r.isHemisphereLight) {
                var _ = he.get(r);
                _.direction.setFromMatrixPosition(r.matrixWorld),
                _.direction.transformDirection(p),
                _.direction.normalize(),
                _.skyColor.copy(r.color).multiplyScalar(s),
                _.groundColor.copy(r.groundColor).multiplyScalar(s),
                Yt.hemi[y] = _,
                y++
            }
            Yt.ambient[0] = h,
            Yt.ambient[1] = l,
            Yt.ambient[2] = f,
            Yt.directional.length = d,
            Yt.spot.length = v,
            Yt.rectArea.length = g,
            Yt.point.length = m,
            Yt.hemi.length = y,
            Yt.hash = d + "," + m + "," + v + "," + g + "," + y + "," + Yt.shadows.length
        }
        function st() {
            var t = Ot;
            return t >= ne.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + ne.maxTextures),
            Ot += 1,
            t
        }
        function ut(t) {
            var e;
            if (t === r._38) return $t.REPEAT;
            if (t === r.j) return $t.CLAMP_TO_EDGE;
            if (t === r._1) return $t.MIRRORED_REPEAT;
            if (t === r._5) return $t.NEAREST;
            if (t === r._7) return $t.NEAREST_MIPMAP_NEAREST;
            if (t === r._6) return $t.NEAREST_MIPMAP_LINEAR;
            if (t === r.Q) return $t.LINEAR;
            if (t === r.S) return $t.LINEAR_MIPMAP_NEAREST;
            if (t === r.R) return $t.LINEAR_MIPMAP_LINEAR;
            if (t === r._53) return $t.UNSIGNED_BYTE;
            if (t === r._56) return $t.UNSIGNED_SHORT_4_4_4_4;
            if (t === r._57) return $t.UNSIGNED_SHORT_5_5_5_1;
            if (t === r._58) return $t.UNSIGNED_SHORT_5_6_5;
            if (t === r.h) return $t.BYTE;
            if (t === r._40) return $t.SHORT;
            if (t === r._59) return $t.UNSIGNED_SHORT;
            if (t === r.J) return $t.INT;
            if (t === r._55) return $t.UNSIGNED_INT;
            if (t === r.C) return $t.FLOAT;
            if (t === r.I && null !== (e = ee.get("OES_texture_half_float"))) return e.HALF_FLOAT_OES;
            if (t === r.d) return $t.ALPHA;
            if (t === r._30) return $t.RGB;
            if (t === r._22) return $t.RGBA;
            if (t === r.Y) return $t.LUMINANCE;
            if (t === r.X) return $t.LUMINANCE_ALPHA;
            if (t === r.s) return $t.DEPTH_COMPONENT;
            if (t === r.t) return $t.DEPTH_STENCIL;
            if (t === r.a) return $t.FUNC_ADD;
            if (t === r._46) return $t.FUNC_SUBTRACT;
            if (t === r._39) return $t.FUNC_REVERSE_SUBTRACT;
            if (t === r._63) return $t.ZERO;
            if (t === r._14) return $t.ONE;
            if (t === r._45) return $t.SRC_COLOR;
            if (t === r._18) return $t.ONE_MINUS_SRC_COLOR;
            if (t === r._43) return $t.SRC_ALPHA;
            if (t === r._17) return $t.ONE_MINUS_SRC_ALPHA;
            if (t === r.v) return $t.DST_ALPHA;
            if (t === r._15) return $t.ONE_MINUS_DST_ALPHA;
            if (t === r.w) return $t.DST_COLOR;
            if (t === r._16) return $t.ONE_MINUS_DST_COLOR;
            if (t === r._44) return $t.SRC_ALPHA_SATURATE;
            if ((t === r._36 || t === r._25 || t === r._26 || t === r._27) && null !== (e = ee.get("WEBGL_compressed_texture_s3tc"))) {
                if (t === r._36) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (t === r._25) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (t === r._26) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (t === r._27) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT
            }
            if ((t === r._35 || t === r._34 || t === r._24 || t === r._23) && null !== (e = ee.get("WEBGL_compressed_texture_pvrtc"))) {
                if (t === r._35) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (t === r._34) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (t === r._24) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (t === r._23) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            }
            if (t === r._33 && null !== (e = ee.get("WEBGL_compressed_texture_etc1"))) return e.COMPRESSED_RGB_ETC1_WEBGL;
            if ((t === r._0 || t === r.Z) && null !== (e = ee.get("EXT_blend_minmax"))) {
                if (t === r._0) return e.MIN_EXT;
                if (t === r.Z) return e.MAX_EXT
            }
            return t === r._54 && null !== (e = ee.get("WEBGL_depth_texture")) ? e.UNSIGNED_INT_24_8_WEBGL: 0
        }
        t = t || {};
        var ct = undefined !== t.canvas ? t.canvas: document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
        ht = undefined !== t.context ? t.context: null,
        lt = undefined !== t.alpha && t.alpha,
        ft = undefined === t.depth || t.depth,
        pt = undefined === t.stencil || t.stencil,
        dt = undefined !== t.antialias && t.antialias,
        mt = undefined === t.premultipliedAlpha || t.premultipliedAlpha,
        vt = undefined !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
        gt = [],
        yt = null,
        _t = new Float32Array(8),
        xt = [],
        bt = [];
        this.domElement = ct,
        this.context = null,
        this.autoClear = true,
        this.autoClearColor = true,
        this.autoClearDepth = true,
        this.autoClearStencil = true,
        this.sortObjects = true,
        this.clippingPlanes = [],
        this.localClippingEnabled = false,
        this.gammaFactor = 2,
        this.gammaInput = false,
        this.gammaOutput = false,
        this.physicallyCorrectLights = false,
        this.toneMapping = r.T,
        this.toneMappingExposure = 1,
        this.toneMappingWhitePoint = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4;
        var wt = this,
        Mt = null,
        St = null,
        Et = null,
        Tt = -1,
        At = "",
        Ct = null,
        Pt = null,
        Lt = new N.a,
        Rt = null,
        It = new N.a,
        Ot = 0,
        Nt = ct.width,
        Dt = ct.height,
        Ut = 1,
        Bt = new N.a(0, 0, Nt, Dt),
        zt = false,
        Ft = new N.a(0, 0, Nt, Dt),
        jt = new O.a,
        kt = new I.a,
        Vt = false,
        Gt = false,
        Ht = new o.a,
        Wt = new R.a,
        Xt = new o.a,
        qt = new o.a,
        Yt = {
            hash: "",
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            shadows: []
        },
        Zt = {
            geometries: 0,
            textures: 0
        },
        Jt = {
            frame: 0,
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        },
        Qt = false,
        Kt = {
            threeWebGLPrepare: 0
        };
        this.info = {
            render: Jt,
            memory: Zt,
            programs: null,
            egsinfo: Kt
        };
        var $t;
        try {
            var te = {
                alpha: lt,
                depth: ft,
                stencil: pt,
                antialias: dt,
                premultipliedAlpha: mt,
                preserveDrawingBuffer: vt
            };
            if (null === ($t = ht || ct.getContext("webgl", te) || ct.getContext("experimental-webgl", te))) throw null !== ct.getContext("webgl") ? "Error creating WebGL context with your selected attributes.": "Error creating WebGL context.";
            undefined === $t.getShaderPrecisionFormat && ($t.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }),
            ct.addEventListener("webglcontextlost", D, false)
        } catch(t) {
            console.error("THREE.WebGLRenderer: " + t)
        }
        var ee = new L.a($t);
        ee.get("WEBGL_depth_texture"),
        ee.get("OES_texture_float"),
        ee.get("OES_texture_float_linear"),
        ee.get("OES_texture_half_float"),
        ee.get("OES_texture_half_float_linear"),
        ee.get("OES_standard_derivatives"),
        ee.get("ANGLE_instanced_arrays"),
        ee.get("OES_element_index_uint") && (P.a.MaxIndex = 4294967296);
        var ne = new A.a($t, ee, t),
        ie = new T.a($t, ee, ut),
        re = new E.a,
        ae = new S.a($t, ee, ie, re, ne, ut, Zt),
        oe = new m.a($t),
        se = new x.a($t, oe, Zt),
        ue = new w.a($t, se, Jt),
        ce = new M.a(this, ne),
        he = new b.a,
        le = new g.a,
        fe = new v.a(this, ie, ue, mt),
        pe = new C.a(this);
        this.info.programs = ce.programs;
        var de = new _.a($t, ee, Jt),
        me = new y.a($t, ee, Jt);
        n(),
        this.context = $t,
        this.capabilities = ne,
        this.extensions = ee,
        this.properties = re,
        this.renderLists = le,
        this.state = ie,
        this.vr = pe;
        var ve = new d.a(this, Yt, ue, ne);
        this.shadowMap = ve;
        var ge = new p.a(this, xt),
        ye = new f.a(this, bt);
        this.getContext = function() {
            return $t
        },
        this.getContextAttributes = function() {
            return $t.getContextAttributes()
        },
        this.forceContextLoss = function() {
            var t = ee.get("WEBGL_lose_context");
            t && t.loseContext()
        },
        this.getMaxAnisotropy = function() {
            return ne.getMaxAnisotropy()
        },
        this.getPrecision = function() {
            return ne.precision
        },
        this.getPixelRatio = function() {
            return Ut
        },
        this.setPixelRatio = function(t) {
            undefined !== t && (Ut = t, this.setSize(Nt, Dt, false))
        },
        this.getSize = function() {
            return {
                width: Nt,
                height: Dt
            }
        },
        this.setSize = function(t, e, n) {
            var i = pe.getDevice();
            if (i && i.isPresenting) return void console.warn("THREE.WebGLRenderer: Can't change sizewhile VR device is presenting.");
            Nt = t,
            Dt = e,
            ct.width = t * Ut,
            ct.height = e * Ut,
            false !== n && (ct.style.width = t + "px ", ct.style.height = e + "px "),
            this.setViewport(0, 0, t, e)
        },
        this.getDrawingBufferSize = function() {
            return {
                width: Nt * Ut,
                height: Dt * Ut
            }
        },
        this.setDrawingBufferSize = function(t, e, n) {
            Nt = t,
            Dt = e,
            Ut = n,
            ct.width = t * n,
            ct.height = e * n,
            this.setViewport(0, 0, t, e)
        },
        this.setViewport = function(t, e, n, i) {
            Ft.set(t, Dt - e - i, n, i),
            ie.viewport(It.copy(Ft).multiplyScalar(Ut))
        },
        this.setScissor = function(t, e, n, i) {
            Bt.set(t, Dt - e - i, n, i),
            ie.scissor(Lt.copy(Bt).multiplyScalar(Ut))
        },
        this.setScissorTest = function(t) {
            ie.setScissorTest(zt = t)
        },
        this.getClearColor = fe.getClearColor,
        this.setClearColor = fe.setClearColor,
        this.getClearAlpha = fe.getClearAlpha,
        this.setClearAlpha = fe.setClearAlpha,
        this.clear = function(t, e, n) {
            var i = 0; (undefined === t || t) && (i |= $t.COLOR_BUFFER_BIT),
            (undefined === e || e) && (i |= $t.DEPTH_BUFFER_BIT),
            (undefined === n || n) && (i |= $t.STENCIL_BUFFER_BIT),
            $t.clear(i)
        },
        this.clearColor = function() {
            this.clear(true, false, false)
        },
        this.clearDepth = function() {
            this.clear(false, true, false)
        },
        this.clearStencil = function() {
            this.clear(false, false, true)
        },
        this.clearTarget = function(t, e, n, i) {
            this.setRenderTarget(t),
            this.clear(e, n, i)
        },
        this.resetGLState = i,
        this.dispose = function() {
            ct.removeEventListener("webglcontextlost ", D, false),
            le.dispose()
        },
        this.renderBufferImmediate = function(t, e, n) {
            ie.initAttributes();
            var i = re.get(t);
            t.hasPositions && !i.position && (i.position = $t.createBuffer()),
            t.hasNormals && !i.normal && (i.normal = $t.createBuffer()),
            t.hasUvs && !i.uv && (i.uv = $t.createBuffer()),
            t.hasColors && !i.color && (i.color = $t.createBuffer());
            var a = e.getAttributes();
            if (t.hasPositions && ($t.bindBuffer($t.ARRAY_BUFFER, i.position), $t.bufferData($t.ARRAY_BUFFER, t.positionArray, $t.DYNAMIC_DRAW), ie.enableAttribute(a.position), $t.vertexAttribPointer(a.position, 3, $t.FLOAT, false, 0, 0)), t.hasNormals) {
                if ($t.bindBuffer($t.ARRAY_BUFFER, i.normal), !n.isMeshPhongMaterial && !n.isMeshStandardMaterial && !n.isMeshNormalMaterial && n.shading === r.B) for (var o = 0,
                s = 3 * t.count; o < s; o += 9) {
                    var u = t.normalArray,
                    c = (u[o + 0] + u[o + 3] + u[o + 6]) / 3,
                    h = (u[o + 1] + u[o + 4] + u[o + 7]) / 3,
                    l = (u[o + 2] + u[o + 5] + u[o + 8]) / 3;
                    u[o + 0] = c,
                    u[o + 1] = h,
                    u[o + 2] = l,
                    u[o + 3] = c,
                    u[o + 4] = h,
                    u[o + 5] = l,
                    u[o + 6] = c,
                    u[o + 7] = h,
                    u[o + 8] = l
                }
                $t.bufferData($t.ARRAY_BUFFER, t.normalArray, $t.DYNAMIC_DRAW),
                ie.enableAttribute(a.normal),
                $t.vertexAttribPointer(a.normal, 3, $t.FLOAT, false, 0, 0)
            }
            t.hasUvs && n.map && ($t.bindBuffer($t.ARRAY_BUFFER, i.uv), $t.bufferData($t.ARRAY_BUFFER, t.uvArray, $t.DYNAMIC_DRAW), ie.enableAttribute(a.uv), $t.vertexAttribPointer(oe.uv, 2, $t.FLOAT, false, 0, 0)),
            t.hasColors && n.vertexColors !== r._10 && ($t.bindBuffer($t.ARRAY_BUFFER, i.color), $t.bufferData($t.ARRAY_BUFFER, t.colorArray, $t.DYNAMIC_DRAW), ie.enableAttribute(a.color), $t.vertexAttribPointer(a.color, 3, $t.FLOAT, false, 0, 0)),
            ie.disableUnusedAttributes(),
            $t.drawArrays($t.TRIANGLES, 0, t.count),
            t.count = 0
        },
        this.renderBufferDirect = function(t, n, i, a, o, s) {
            ie.setMaterial(a);
            var u = X(t, n, a, o),
            c = i.id + "_ " + u.id + "_ " + (true === a.wireframe),
            h = false;
            c !== At && (At = c, h = true);
            var l = o.morphTargetInfluences;
            if (undefined !== l) {
                for (var f = [], p = 0, d = l.length; p < d; p++) {
                    var m = l[p];
                    f.push([m, p])
                }
                f.sort(j),
                f.length > 8 && (f.length = 8);
                for (var v = i.morphAttributes,
                p = 0,
                d = f.length; p < d; p++) {
                    var m = f[p];
                    if (_t[p] = m[0], 0 !== m[0]) {
                        var g = m[1]; ! 0 === a.morphTargets && v.position && i.addAttribute("morphTarget " + p, v.position[g]),
                        true === a.morphNormals && v.normal && i.addAttribute("morphNormal " + p, v.normal[g])
                    } else ! 0 === a.morphTargets && i.removeAttribute("morphTarget " + p),
                    true === a.morphNormals && i.removeAttribute("morphNormal " + p)
                }
                for (var p = f.length,
                y = _t.length; p < y; p++) _t[p] = 0;
                u.getUniforms().setValue($t, "morphTargetInfluences ", _t),
                h = true
            }
            var g = i.index,
            _ = i.attributes.position,
            x = 1; ! 0 === a.wireframe && (g = se.getWireframeAttribute(i), x = 2);
            var b, w = de;
            null !== g && (b = oe.get(g), w = me, w.setIndex(b)),
            h && (k(a, u, i), null !== g && $t.bindBuffer($t.ELEMENT_ARRAY_BUFFER, b.buffer));
            var M = 0;
            null !== g ? M = g.count: undefined !== _ && (M = _.count);
            var S = i.drawRange.start * x,
            E = i.drawRange.count * x,
            T = null !== s ? s.start * x: 0,
            A = null !== s ? s.count * x: 1 / 0,
            C = Math.max(S, T),
            P = Math.min(M, S + E, T + A) - 1,
            L = Math.max(0, P - C + 1);
            if (0 !== L) {
                if (o.isMesh) if (true === a.wireframe) ie.setLineWidth(a.wireframeLinewidth * e()),
                w.setMode($t.LINES);
                else switch (o.drawMode) {
                case r._50:
                    w.setMode($t.TRIANGLES);
                    break;
                case r._49:
                    w.setMode($t.TRIANGLE_STRIP);
                    break;
                case r._48:
                    w.setMode($t.TRIANGLE_FAN)
                } else if (o.isLine) {
                    var R = a.linewidth;
                    undefined === R && (R = 1),
                    ie.setLineWidth(R * e()),
                    o.isLineSegments ? w.setMode($t.LINES) : o.isLineLoop ? w.setMode($t.LINE_LOOP) : w.setMode($t.LINE_STRIP)
                } else o.isPoints && w.setMode($t.POINTS);
                i && i.isInstancedBufferGeometry ? i.maxInstancedCount > 0 && w.renderInstances(i, C, L) : w.render(C, L)
            }
        },
        this.compile = function(t, e) {
            gt = [],
            t.traverse(function(t) {
                t.isLight && gt.push(t)
            }),
            ot(gt, e),
            t.traverse(function(e) {
                if (e.material) if (Array.isArray(e.material)) for (var n = 0; n < e.material.length; n++) W(e.material[n], t.fog, e);
                else W(e.material, t.fog, e)
            })
        },
        this.animate = function(t) {
            function e() {
                t(),
                (pe.getDevice() || window).requestAnimationFrame(e)
            } (pe.getDevice() || window).requestAnimationFrame(e)
        },
        this.egsBeginRender = function(t, e, n, i) {
            if (!e || !e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            At = "",
            Tt = -1,
            Ct = null,
            pe.enabled && (e = pe.getCamera(e)),
            gt.length = 0,
            xt.length = 0,
            bt.length = 0,
            undefined === n && (n = null),
            this.setRenderTarget(n),
            Gt = this.localClippingEnabled,
            Vt = kt.init(this.clippingPlanes, Gt, e);
            for (var r = 0; r < t.lights.length; r++) gt[r] = t.lights[r];
            Vt && kt.beginShadows(),
            at(gt),
            ve.render(t.scene, e),
            ot(gt, e),
            Vt && kt.endShadows(),
            fe.render(t.scene, e, i)
        },
        this.egsRenderObjects = function(t, e) {
            Kt.threeWebGLPrepare = performance.now(),
            Jt.frame++,
            Jt.calls = 0,
            Jt.vertices = 0,
            Jt.faces = 0,
            Jt.points = 0;
            for (var n = 0,
            i = t.opaque.length; n < i; n++) t.opaque[n].geometry = ue.update(t.opaque[n].object);
            for (var n = 0,
            i = t.transparent.length; n < i; n++) t.transparent[n].geometry = ue.update(t.transparent[n].object);
            Kt.threeWebGLPrepare = performance.now() - Kt.threeWebGLPrepare;
            var r = t.opaque,
            a = t.transparent;
            if (t.scene.overrideMaterial) {
                var o = t.scene.overrideMaterial;
                r.length && G(r, t.scene, e, o),
                a.length && G(a, t.scene, e, o)
            } else r.length && G(r, t.scene, e),
            a.length && G(a, t.scene, e)
        },
        this.egsEndRender = function(t, e) {
            for (var n = 0; n < t.sprites.length; n++) xt[n] = t.sprites[n];
            ge.render(t.scene, e),
            ye.render(t.scene, e, It),
            this._currentRenderTarget && ae.updateRenderTargetMipmap(St),
            ie.buffers.depth.setTest(true),
            ie.buffers.depth.setMask(true),
            ie.buffers.color.setMask(true),
            e.isArrayCamera && wt.setScissorTest(false),
            pe.enabled && pe.submitFrame()
        },
        this.render = function(t, e, n, i) {
            if (t.isRenderList) return t.firstBatch && (Qt && (this.egsEndRender(t, e), Qt = false), this.egsBeginRender(t, e, n, i)),
            this.egsRenderObjects(t, e),
            void(t.lastBatch ? (this.egsEndRender(t, e), Qt = false) : Qt = true);
            if (!e || !e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            At = "",
            Tt = -1,
            Ct = null,
            Kt.threeWebGLPrepare = performance.now(),
            true === t.autoUpdate && t.updateMatrixWorld(),
            null === e.parent && e.updateMatrixWorld(),
            pe.enabled && (e = pe.getCamera(e)),
            Ht.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
            jt.setFromMatrix(Ht),
            gt.length = 0,
            xt.length = 0,
            bt.length = 0,
            Gt = this.localClippingEnabled,
            Vt = kt.init(this.clippingPlanes, Gt, e),
            yt = le.get(t, e),
            yt.init(),
            V(t, e, wt.sortObjects),
            yt.finish(),
            true === wt.sortObjects && yt.sort(),
            Vt && kt.beginShadows(),
            at(gt),
            ve.render(t, e),
            ot(gt, e),
            Vt && kt.endShadows(),
            Jt.frame++,
            Jt.calls = 0,
            Jt.vertices = 0,
            Jt.faces = 0,
            Jt.points = 0,
            Kt.threeWebGLPrepare = performance.now() - Kt.renderPrepareTime,
            undefined === n && (n = null),
            this.setRenderTarget(n),
            fe.render(t, e, i);
            var r = yt.opaque,
            a = yt.transparent;
            if (t.overrideMaterial) {
                var o = t.overrideMaterial;
                r.length && G(r, t, e, o),
                a.length && G(a, t, e, o)
            } else r.length && G(r, t, e),
            a.length && G(a, t, e);
            ge.render(t, e),
            ye.render(t, e, It),
            n && ae.updateRenderTargetMipmap(n),
            ie.buffers.depth.setTest(true),
            ie.buffers.depth.setMask(true),
            ie.buffers.color.setMask(true),
            e.isArrayCamera && wt.setScissorTest(false),
            pe.enabled && pe.submitFrame()
        },
        this.setFaceCulling = function(t, e) {
            ie.setCullFace(t),
            ie.setFlipSided(e === r.D)
        },
        this.allocTextureUnit = st,
        this.setTexture2D = function() {
            var t = false;
            return function(e, n) {
                e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don 't use render targets as textures. Use their .texture property instead."), t = true), e = e.texture),
                ae.setTexture2D(e, n)
            }
        } (),
        this.setTexture = function() {
            var t = false;
            return function(e, n) {
                t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = true),
                ae.setTexture2D(e, n)
            }
        } (),
        this.setTextureCube = function() {
            var t = false;
            return function(e, n) {
                e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures.Use their.texture property instead."), t = true), e = e.texture),
                e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? ae.setTextureCube(e, n) : ae.setTextureCubeDynamic(e, n)
            }
        } (),
        this.getRenderTarget = function() {
            return St
        },
        this.setRenderTarget = function(t) {
            St = t,
            t && undefined === re.get(t).__webglFramebuffer && ae.setupRenderTarget(t);
            var e, n = t && t.isWebGLRenderTargetCube;
            if (t) {
                var i = re.get(t);
                e = n ? i.__webglFramebuffer[t.activeCubeFace] : i.__webglFramebuffer,
                Lt.copy(t.scissor),
                Rt = t.scissorTest,
                It.copy(t.viewport)
            } else e = null,
            Lt.copy(Bt).multiplyScalar(Ut),
            Rt = zt,
            It.copy(Ft).multiplyScalar(Ut);
            if (Et !== e && ($t.bindFramebuffer($t.FRAMEBUFFER, e), Et = e), ie.scissor(Lt), ie.setScissorTest(Rt), ie.viewport(It), n) {
                var r = re.get(t.texture);
                $t.framebufferTexture2D($t.FRAMEBUFFER, $t.COLOR_ATTACHMENT0, $t.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace, r.__webglTexture, t.activeMipMapLevel)
            }
        },
        this.readRenderTargetPixels = function(t, e, n, i, a, o) {
            if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            var s = re.get(t).__webglFramebuffer;
            if (s) {
                var u = false;
                s !== Et && ($t.bindFramebuffer($t.FRAMEBUFFER, s), u = true);
                try {
                    var c = t.texture,
                    h = c.format,
                    l = c.type;
                    if (h !== r._22 && ut(h) !== $t.getParameter($t.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    if (! (l === r._53 || ut(l) === $t.getParameter($t.IMPLEMENTATION_COLOR_READ_TYPE) || l === r.C && (ee.get("OES_texture_float ") || ee.get("WEBGL_color_buffer_float ")) || l === r.I && ee.get("EXT_color_buffer_half_float "))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    $t.checkFramebufferStatus($t.FRAMEBUFFER) === $t.FRAMEBUFFER_COMPLETE ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - a && $t.readPixels(e, n, i, a, ut(h), ut(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed.Framebuffer not complete.")
                } finally {
                    u && $t.bindFramebuffer($t.FRAMEBUFFER, Et)
                }
            }
        }
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("RBSo "),
    a = n("7 MDU "),
    o = n("6 HoM "),
    s = n("DataTexture "),
    u = n("TRUI "),
    c = n("yQK5 "),
    h = n("UniformsUtils "),
    l = n("ShaderLib "),
    f = n("IriH "),
    p = n("7 tNX "),
    d = n("GDAY "),
    m = n("O0yN "),
    v = n("aB5d "),
    g = n("uPDx "),
    y = n("cRRw "),
    _ = n("w9Lf "),
    x = n("PcuP "),
    b = n("I4yL "),
    w = n("piF5 "),
    M = n("WMvH "),
    S = n("xs6E "),
    E = n("fVU3 "),
    T = n("eLnu "),
    A = n("9 pX5 "),
    C = n("ea3E "),
    P = n("BufferGeometry "),
    L = n("d / hv "),
    R = n("Vector3 "),
    I = n("TeME "),
    O = n("Frustum "),
    N = n("Vector4 ")
},
qlS9: function(t, e, n) {
    "use strict ";
    e.a = "#if DEPTH_PACKING == 3200\\ n\\ tuniform float opacity;\\n # endif\\ n # include < common > \\n # include < packing > \\n # include < uv_pars_fragment > \\n # include < map_pars_fragment > \\n # include < alphamap_pars_fragment > \\n # include < logdepthbuf_pars_fragment > \\n # include < clipping_planes_pars_fragment > \\nvoid main() {\\n\\ t # include < clipping_planes_fragment > \\n\\ tvec4 diffuseColor = vec4(1.0);\\n\\ t #if DEPTH_PACKING == 3200\\ n\\ t\\ tdiffuseColor.a = opacity;\\n\\ t # endif\\ n\\ t # include < map_fragment > \\n\\ t # include < alphamap_fragment > \\n\\ t # include < alphatest_fragment > \\n\\ t # include < logdepthbuf_fragment > \\n\\ t #if DEPTH_PACKING == 3200\\ n\\ t\\ tgl_FragColor = vec4(vec3(gl_FragCoord.z), opacity);\\n\\ t # elif DEPTH_PACKING == 3201\\ n\\ t\\ tgl_FragColor = packDepthToRGBA(gl_FragCoord.z);\\n\\ t # endif\\ n}\\n "
},
qoGD: function(t, e) {
    undefined === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    undefined === Number.isInteger && (Number.isInteger = function(t) {
        return "number " == typeof t && isFinite(t) && Math.floor(t) === t
    }),
    undefined === Math.sign && (Math.sign = function(t) {
        return t < 0 ? -1 : t > 0 ? 1 : +t
    }),
    undefined === Function.prototype.name && Object.defineProperty(Function.prototype, "name ", {
        get: function() {
            return this.toString().match(/^\\s*function\\s*([^\\(\\s]*)/)[1]
        }
    }),
    undefined === Object.assign &&
    function() {
        Object.assign = function(t) {
            "use strict ";
            if (undefined === t || null === t) throw new TypeError("Cannot convert undefined or null to object ");
            for (var e = Object(t), n = 1; n < arguments.length; n++) {
                var i = arguments[n];
                if (undefined !== i && null !== i) for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (e[r] = i[r])
            }
            return e
        }
    } ()
},
qtbg: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_AOMAP\\ n\\ tuniform sampler2D aoMap;\\n\\ tuniform float aoMapIntensity;\\n # endif "
},
r1Tu: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef DOUBLE_SIDED\\ n\\ tfloat flipNormal = (float(gl_FrontFacing) * 2.0 - 1.0);\\n #else\\ n\\ tfloat flipNormal = 1.0;\\n # endif\\ n "
},
r7QY: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        Object(u.a)(t) ? (t.opaque.forEach(function(t) {
            return e(t.object)
        }), t.transparent.forEach(function(t) {
            return e(t.object)
        })) : t.traverse(e)
    }
    n.d(e, "a ",
    function() {
        return l
    });
    var r = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    a = n("sz / p "),
    o = n("cHSn "),
    s = n("85 Qu "),
    u = n("AoCO "),
    c = this && this.__extends ||
    function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array &&
        function(t, e) {
            t.__proto__ = e
        } ||
        function(t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        };
        return function(e, n) {
            function i() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
        }
    } (),
    h = new r.I,
    l = function(t) {
        function e() {
            var e = t.call(this) || this;
            return e.encodeMaterial = Object(s.a)(o.a),
            e.encodeId = 0,
            e.originalOnBeforeRenders = new Map,
            e
        }
        return c(e, t),
        e.prototype.overrideOnBeforeRender = function() {
            function t(t, e, i, r, a, o) {
                var s = o && Array.isArray(this.material) ? this.material[o.materialIndex] : this.material;
                n.encodeMaterial.side = s.side,
                n.encodeMaterial.polygonOffset = s.polygonOffset,
                n.encodeMaterial.polygonOffsetUnits = s.polygonOffsetUnits,
                n.encodeMaterial.polygonOffsetFactor = s.polygonOffsetFactor;
                var u = n.encodeId++,
                c = t.getContext(),
                l = t.properties.get(n.encodeMaterial).program;
                l && (c.useProgram(l.program), l.getUniforms().setValue(c, "id ", h.set((u >> 8 & 255) / 255, (255 & u) / 255)))
            }
            var e = this,
            n = this;
            i(this.scene,
            function(n) {
                e.originalOnBeforeRenders.has(n.uuid) || (e.originalOnBeforeRenders.set(n.uuid, n.onBeforeRender), n.onBeforeRender = t)
            })
        },
        e.prototype.restoreOnBeforeRender = function() {
            var t = this;
            i(this.scene,
            function(e) {
                return e.onBeforeRender = t.originalOnBeforeRenders.get(e.uuid)
            })
        },
        e.prototype.render = function(t, e) {
            var n = this.renderToScreen ? null: e;
            this.encodeId = 0,
            this.originalOnBeforeRenders.clear();
            var i = this.scene.overrideMaterial;
            this.overrideOnBeforeRender(),
            this.scene.overrideMaterial = this.encodeMaterial,
            this.clear && (t.setRenderTarget(n), t.clear()),
            t.render(this.scene, this.camera, n),
            this.restoreOnBeforeRender(),
            this.scene.overrideMaterial = i,
            this.originalOnBeforeRenders.clear()
        },
        e
    } (a.a)
},
TorusGeometry||TorusBufferGeometry: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i, o) {
        a.a.call(this),
        this.type = "TorusGeometry ",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: o
        },
        this.fromBufferGeometry(new r(t, e, n, i, o)),
        this.mergeVertices()
    }
    function r(t, e, n, i, r) {
        o.a.call(this),
        this.type = "TorusBufferGeometry ",
        this.parameters = {
            radius: t,
            tube: e,
            radialSegments: n,
            tubularSegments: i,
            arc: r
        },
        t = t || 100,
        e = e || 40,
        n = Math.floor(n) || 8,
        i = Math.floor(i) || 6,
        r = r || 2 * Math.PI;
        var a, c, h = [],
        l = [],
        f = [],
        p = [],
        d = new u.a,
        m = new u.a,
        v = new u.a;
        for (a = 0; a <= n; a++) for (c = 0; c <= i; c++) {
            var g = c / i * r,
            y = a / n * Math.PI * 2;
            m.x = (t + e * Math.cos(y)) * Math.cos(g),
            m.y = (t + e * Math.cos(y)) * Math.sin(g),
            m.z = e * Math.sin(y),
            l.push(m.x, m.y, m.z),
            d.x = t * Math.cos(g),
            d.y = t * Math.sin(g),
            v.subVectors(m, d).normalize(),
            f.push(v.x, v.y, v.z),
            p.push(c / i),
            p.push(a / n)
        }
        for (a = 1; a <= n; a++) for (c = 1; c <= i; c++) {
            var _ = (i + 1) * a + c - 1,
            x = (i + 1) * (a - 1) + c - 1,
            b = (i + 1) * (a - 1) + c,
            w = (i + 1) * a + c;
            h.push(_, x, w),
            h.push(x, b, w)
        }
        this.setIndex(h),
        this.addAttribute("position ", new s.b(l, 3)),
        this.addAttribute("normal ", new s.b(f, 3)),
        this.addAttribute("uv ", new s.b(p, 2))
    }
    var a = n("Geometry "),
    o = n("BufferGeometry "),
    s = n("BufferAttribute "),
    u = n("Vector3 ");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
rc98: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        r.a.call(this, t, e, n),
        this.activeCubeFace = 0,
        this.activeMipMapLevel = 0
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("v504 ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isWebGLRenderTargetCube = true
},
rqIV: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        this.name = "",
        this.color = new r.a(t),
        this.near = undefined !== e ? e: 1,
        this.far = undefined !== n ? n: 1e3
    }
    var r = n("Color ");
    i.prototype.isFog = true,
    i.prototype.clone = function() {
        return new i(this.color.getHex(), this.near, this.far)
    },
    i.prototype.toJSON = function(t) {
        return {
            type: "Fog ",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
},
"rt / V ": function(t, e, n) {
    "use strict ";
    e.a = "# ifdef USE_EMISSIVEMAP\\ n\\ tuniform sampler2D emissiveMap;\\n # endif\\ n "
},
rzcw: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = false;
        var e = new o.a({
            color: t.color
        }),
        n = new s.a;
        n.addAttribute("position ", new u.a(new Float32Array(15), 3)),
        this.add(new a.a(n, e)),
        this.update()
    }
    var r = n("87 g3 "),
    a = n("Line "),
    o = n("LineBasicMaterial"),
    s = n("BufferGeometry "),
    u = n("BufferAttribute ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    },
    i.prototype.update = function() {
        var t = this.children[0];
        t.material.color.copy(this.light.color);
        var e = .5 * this.light.width,
        n = .5 * this.light.height,
        i = t.geometry.attributes.position,
        r = i.array;
        r[0] = e,
        r[1] = -n,
        r[2] = 0,
        r[3] = e,
        r[4] = n,
        r[5] = 0,
        r[6] = -e,
        r[7] = n,
        r[8] = 0,
        r[9] = -e,
        r[10] = -n,
        r[11] = 0,
        r[12] = e,
        r[13] = -n,
        r[14] = 0,
        i.needsUpdate = true
    }
},
sHJs: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        this._mixer = t,
        this._clip = e,
        this._localRoot = n || null;
        for (var i = e.tracks,
        a = i.length,
        o = new Array(a), s = {
            endingStart: r._62,
            endingEnd: r._62
        },
        u = 0; u !== a; ++u) {
            var c = i[u].createInterpolant(null);
            o[u] = c,
            c.settings = s
        }
        this._interpolantSettings = s,
        this._interpolants = o,
        this._propertyBindings = new Array(a),
        this._cacheIndex = null,
        this._byClipCacheIndex = null,
        this._timeScaleInterpolant = null,
        this._weightInterpolant = null,
        this.loop = r.W,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this.timeScale = 1,
        this._effectiveTimeScale = 1,
        this.weight = 1,
        this._effectiveWeight = 1,
        this.repetitions = 1 / 0,
        this.paused = false,
        this.enabled = true,
        this.clampWhenFinished = false,
        this.zeroSlopeAtStart = true,
        this.zeroSlopeAtEnd = true
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("RBSo ");
    Object.assign(i.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = false,
            this.enabled = true,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(t) {
            return this._startTime = t,
            this
        },
        setLoop: function(t, e) {
            return this.loop = t,
            this.repetitions = e,
            this
        },
        setEffectiveWeight: function(t) {
            return this.weight = t,
            this._effectiveWeight = this.enabled ? t: 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(t) {
            return this._scheduleFading(t, 0, 1)
        },
        fadeOut: function(t) {
            return this._scheduleFading(t, 1, 0)
        },
        crossFadeFrom: function(t, e, n) {
            if (t.fadeOut(e), this.fadeIn(e), n) {
                var i = this._clip.duration,
                r = t._clip.duration,
                a = r / i,
                o = i / r;
                t.warp(1, a, e),
                this.warp(o, 1, e)
            }
            return this
        },
        crossFadeTo: function(t, e, n) {
            return t.crossFadeFrom(this, e, n)
        },
        stopFading: function() {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)),
            this
        },
        setEffectiveTimeScale: function(t) {
            return this.timeScale = t,
            this._effectiveTimeScale = this.paused ? 0 : t,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(t) {
            return this.timeScale = this._clip.duration / t,
            this.stopWarping()
        },
        syncWith: function(t) {
            return this.time = t.time,
            this.timeScale = t.timeScale,
            this.stopWarping()
        },
        halt: function(t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        },
        warp: function(t, e, n) {
            var i = this._mixer,
            r = i.time,
            a = this._timeScaleInterpolant,
            o = this.timeScale;
            null === a && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
            var s = a.parameterPositions,
            u = a.sampleValues;
            return s[0] = r,
            s[1] = r + n,
            u[0] = t / o,
            u[1] = e / o,
            this
        },
        stopWarping: function() {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(t, e, n, i) {
            if (!this.enabled) return void this._updateWeight(t);
            var r = this._startTime;
            if (null !== r) {
                var a = (t - r) * n;
                if (a < 0 || 0 === n) return;
                this._startTime = null,
                e = n * a
            }
            e *= this._updateTimeScale(t);
            var o = this._updateTime(e),
            s = this._updateWeight(t);
            if (s > 0) for (var u = this._interpolants,
            c = this._propertyBindings,
            h = 0,
            l = u.length; h !== l; ++h) u[h].evaluate(o),
            c[h].accumulate(i, s)
        },
        _updateWeight: function(t) {
            var e = 0;
            if (this.enabled) {
                e = this.weight;
                var n = this._weightInterpolant;
                if (null !== n) {
                    var i = n.evaluate(t)[0];
                    e *= i,
                    t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = false))
                }
            }
            return this._effectiveWeight = e,
            e
        },
        _updateTimeScale: function(t) {
            var e = 0;
            if (!this.paused) {
                e = this.timeScale;
                var n = this._timeScaleInterpolant;
                if (null !== n) {
                    e *= n.evaluate(t)[0],
                    t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = true : this.timeScale = e)
                }
            }
            return this._effectiveTimeScale = e,
            e
        },
        _updateTime: function(t) {
            var e = this.time + t;
            if (0 === t) return e;
            var n = this._clip.duration,
            i = this.loop,
            a = this._loopCount;
            if (i === r.U) { - 1 === a && (this._loopCount = 0, this._setEndings(true, true, false));
                t: {
                    if (e >= n) e = n;
                    else {
                        if (! (e < 0)) break t;
                        e = 0
                    }
                    this.clampWhenFinished ? this.paused = true : this.enabled = false,
                    this._mixer.dispatchEvent({
                        type: "finished ",
                        action: this,
                        direction: t < 0 ? -1 : 1
                    })
                }
            } else {
                var o = i === r.V;
                if ( - 1 === a && (t >= 0 ? (a = 0, this._setEndings(true, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, true, o)), e >= n || e < 0) {
                    var s = Math.floor(e / n);
                    e -= n * s,
                    a += Math.abs(s);
                    var u = this.repetitions - a;
                    if (u < 0) this.clampWhenFinished ? this.paused = true : this.enabled = false,
                    e = t > 0 ? n: 0,
                    this._mixer.dispatchEvent({
                        type: "finished ",
                        action: this,
                        direction: t > 0 ? 1 : -1
                    });
                    else {
                        if (0 === u) {
                            var c = t < 0;
                            this._setEndings(c, !c, o)
                        } else this._setEndings(false, false, o);
                        this._loopCount = a,
                        this._mixer.dispatchEvent({
                            type: "loop ",
                            action: this,
                            loopDelta: s
                        })
                    }
                }
                if (o && 1 == (1 & a)) return this.time = e,
                n - e
            }
            return this.time = e,
            e
        },
        _setEndings: function(t, e, n) {
            var i = this._interpolantSettings;
            n ? (i.endingStart = r._64, i.endingEnd = r._64) : (i.endingStart = t ? this.zeroSlopeAtStart ? r._64: r._62: r._61, i.endingEnd = e ? this.zeroSlopeAtEnd ? r._64: r._62: r._61)
        },
        _scheduleFading: function(t, e, n) {
            var i = this._mixer,
            r = i.time,
            a = this._weightInterpolant;
            null === a && (a = i._lendControlInterpolant(), this._weightInterpolant = a);
            var o = a.parameterPositions,
            s = a.sampleValues;
            return o[0] = r,
            s[0] = e,
            o[1] = r + t,
            s[1] = n,
            this
        }
    })
},
sTAr: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        r.a.call(this),
        this.v0 = t,
        this.v1 = e,
        this.v2 = n
    }
    var r = n("Lk8y "),
    a = n("JJh5 "),
    o = n("Vector3 ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.getPoint = function(t) {
        var e = this.v0,
        n = this.v1,
        i = this.v2;
        return new o.a(Object(a.c)(t, e.x, n.x, i.x), Object(a.c)(t, e.y, n.y, i.y), Object(a.c)(t, e.z, n.z, i.z))
    }
},
LOD: function(t, e, n) {
    "use strict ";
    function i() {
        a.a.call(this),
        this.type = "LOD ",
        Object.defineProperties(this, {
            levels: {
                enumerable: true,
                value: []
            }
        })
    }
    var r = n("Vector3 "),
    a = n("87 g3 ");
    i.prototype = Object.assign(Object.create(a.a.prototype), {
        constructor: i,
        copy: function(t) {
            a.a.prototype.copy.call(this, t, false);
            for (var e = t.levels,
            n = 0,
            i = e.length; n < i; n++) {
                var r = e[n];
                this.addLevel(r.object.clone(), r.distance)
            }
            return this
        },
        addLevel: function(t, e) {
            undefined === e && (e = 0),
            e = Math.abs(e);
            for (var n = this.levels,
            i = 0; i < n.length && !(e < n[i].distance); i++);
            n.splice(i, 0, {
                distance: e,
                object: t
            }),
            this.add(t)
        },
        getObjectForDistance: function(t) {
            for (var e = this.levels,
            n = 1,
            i = e.length; n < i && !(t < e[n].distance); n++);
            return e[n - 1].object
        },
        raycast: function() {
            var t = new r.a;
            return function(e, n) {
                t.setFromMatrixPosition(this.matrixWorld);
                var i = e.ray.origin.distanceTo(t);
                this.getObjectForDistance(i).raycast(e, n)
            }
        } (),
        update: function() {
            var t = new r.a,
            e = new r.a;
            return function(n) {
                var i = this.levels;
                if (i.length > 1) {
                    t.setFromMatrixPosition(n.matrixWorld),
                    e.setFromMatrixPosition(this.matrixWorld);
                    var r = t.distanceTo(e);
                    i[0].object.visible = true;
                    for (var a = 1,
                    o = i.length; a < o && r >= i[a].distance; a++) i[a - 1].object.visible = false,
                    i[a].object.visible = true;
                    for (; a < o; a++) i[a].object.visible = false
                }
            }
        } (),
        toJSON: function(t) {
            var e = a.a.prototype.toJSON.call(this, t);
            e.object.levels = [];
            for (var n = this.levels,
            i = 0,
            r = n.length; i < r; i++) {
                var o = n[i];
                e.object.levels.push({
                    object: o.object.uuid,
                    distance: o.distance
                })
            }
            return e
        }
    })
},
"sz / p ": function(t, e, n) {
    "use strict ";
    n.d(e, "a ",
    function() {
        return i
    });
    var i = function() {
        function t() {
            this.enabled = true,
            this.needsSwap = true,
            this.clear = true,
            this.renderToScreen = false
        }
        return t.prototype.setSize = function(t, e) {},
        t.prototype.setup = function(t, e) {
            this.scene = t,
            this.camera = e
        },
        t.prototype.dispose = function() {
            for (var t = 0,
            e = Object.keys(this); t < e.length; t++) {
                var n = e[t];
                this[n] && "function " == typeof this[n].dispose && (this[n].dispose(), this[n] = null)
            }
        },
        t
    } ()
},
tAH4: function(t, e, n) {
    "use strict ";
    function i() {
        r.a.call(this, new a.a( - 5, 5, 5, -5, .5, 500))
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("6 f23 "),
    a = n("OrthographicCamera ");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i
    })
},
ShaderMaterial: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.type = "ShaderMaterial ",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\\n\\ tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}",
        this.fragmentShader = "void main() {\\n\\ tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\\n}",
        this.linewidth = 1,
        this.wireframe = false,
        this.wireframeLinewidth = 1,
        this.fog = false,
        this.lights = false,
        this.clipping = false,
        this.skinning = false,
        this.morphTargets = false,
        this.morphNormals = false,
        this.extensions = {
            derivatives: false,
            fragDepth: false,
            drawBuffers: false,
            shaderTextureLOD: false
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = undefined,
        undefined !== t && (undefined !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Material "),
    a = n("UniformsUtils ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isShaderMaterial = true,
    i.prototype.copy = function(t) {
        return r.a.prototype.copy.call(this, t),
        this.fragmentShader = t.fragmentShader,
        this.vertexShader = t.vertexShader,
        this.uniforms = a.a.clone(t.uniforms),
        this.defines = t.defines,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.lights = t.lights,
        this.clipping = t.clipping,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this.morphNormals = t.morphNormals,
        this.extensions = t.extensions,
        this
    },
    i.prototype.toJSON = function(t) {
        var e = r.a.prototype.toJSON.call(this, t);
        return e.uniforms = this.uniforms,
        e.vertexShader = this.vertexShader,
        e.fragmentShader = this.fragmentShader,
        e
    }
},
PopMesh: function(t, e, n) {
    "use strict ";
    function i(t) {
        var e;
        return function() {
            return e || (e = t())
        }
    }
    function r(t, e, n) {
        for (var i = 0,
        r = e; r <= n; r++) i += t[r];
        return i
    }
    function a(t, e) {
        for (var n = t.length,
        i = n - 1,
        r = 0; r < n; r++) if (t[r] <= e) {
            i = r;
            break
        }
        return i
    }
    n.d(e, "a ",
    function() {
        return f
    });
    var o = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.),
    s = n("M4fF "),
    u = (n.n(s), this && this.__extends ||
    function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array &&
        function(t, e) {
            t.__proto__ = e
        } ||
        function(t, e) {
            for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n])
        };
        return function(e, n) {
            function i() {
                this.constructor = e
            }
            t(e, n),
            e.prototype = null === n ? Object.create(n) : (i.prototype = n.prototype, new i)
        }
    } ()),
    c = Math.PI / 180,
    h = Object(s.memoize)(function(t) {
        return 2 * Math.tan(t * c / 2)
    }),
    l = Object(s.memoize)(function(t) {
        return Math.pow(2, t)
    }),


    f = function(t) {
        function e(e, n) {
            var i = t.call(this) || this;
            return i.isPopMesh = true,
            i.type = "PopMesh ",
            i.minLevel = -Infinity,
            i.computed = false,
            i.renderCount = 0,
            i.levelFactor = -1,
            i.levelIndex = -1,
            i.onBeforeRender = function(t, e, n, r, a, o) {
                i.computed || 
                (i.computed = true, i.updateLevelFactor(t, n), 
                    i.updateLevelIndex(), i.updateMaterials()),
                ++i.renderCount === i.geometry.groups.length && (i.computed = false, i.renderCount = 0),
                i.updateGroup(o)
            },
            i.geometry = e,
            i.material = n,
            i
        }
        return u(e, t),
        e.prototype.updateLevelFactor = function(t, n) {
            var i = e.updateLevelFactor_cache(),
            r = i.v1,
            a = i.v2,
            s = this.geometry.metadata.boxSizeMagnitude;
            r.setFromMatrixPosition(n.matrixWorld),
            a.setFromMatrixPosition(this.matrixWorld);
            var u = r.distanceTo(a),
            c = h(n.fov),
            l = t.getSize().height,
            f = u * (c / l),
            p = s * this.matrixWorld.getMaxScaleOnAxis(),
            d = p / f,
            m = Math.ceil(Math.log(d) / Math.LN2) + 6;
            m = Math.max(m, this.minLevel),
            m = _Math.clamp(m, 1, 16),
            this.levelFactor = m
        },
        e.prototype.updateLevelIndex = function() {
            var t = this.geometry.model.levelPrecisions,
            e = 16 - this.levelFactor;
            this.levelIndex = a(t, e)
        },
        e.prototype.updateMaterials = function() {
            for (var t = this.geometry,
            e = t.model.levelPrecisions,
            n = t.metadata,
            i = n.vertexConstant,
            r = n.vertexGridSize,
            a = l(e[this.levelIndex]), o = 0, s = this.material; o < s.length; o++) {
                var u = s[o];
                u.uniforms.vertexConstant.value.copy(i),
                u.uniforms.vertexParameters.value.set(r, a)
            }
        },
        e.prototype.updateGroup = function(t) {
            var e = this.geometry.model.blocks;
            t.count = 3 * r(e[t.index].levelFaceCounts, 0, this.levelIndex)
        },
        e.prototype.clone = function() {
            return new e(this.geometry, this.material).copy(this)
        },
        e.prototype.toJSON = function(t) {
            function e(e, n) {
                return undefined === e[n.uuid] && (e[n.uuid] = n.toJSON(t)),
                n.uuid
            }
            if (!t) throw "export error: popmesh cant be root object ";
            var n = {},
            i = {};
            if (i.uuid = this.uuid, i.type = this.type, "" !== 
                this.name && (i.name = this.name), true === this.castShadow && 
                (i.castShadow = true), true === this.receiveShadow && 
                (i.receiveShadow = true), false === this.visible && (i.visible = false), 
                " {}" !== JSON.stringify(this.userData) && (i.userData = this.userData), 
                i.matrix = this.matrix.toArray(), undefined !== this.geometry && (undefined === 
                    t.models && (t.models = {}), i.geometry = e(t.models, this.geometry)), 
                undefined !== this.material) {
                undefined === t.popMaterial && (t.popMaterial = {});
                for (var r = [], a = 0, o = this.material.length; a < o; a++) r.push(e(t.popMaterial, this.material[a])),
                i.material = r
            }
            if (this.children.length > 0) {
                i.children = [];
                for (var a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(t).object)
            }
            return n.object = i,
            n
        },
        e.updateLevelFactor_cache = i(function() {
            return {
                v1: new Vector3(),
                v2: new Vector3()
            }
        }),
        e
    } (o.q)
},
tjQS: function(t, e, n) {
    "use strict ";
    e.a = "# ifdef ALPHATEST\\ n\\ tif(diffuseColor.a < ALPHATEST) discard;\\n # endif\\ n "
},
tv9O: function(t, e, n) {
    "use strict ";
    function i(t) {
        this.manager = undefined !== t ? t: o.a
    }
    var r = n("XJ5Z "),
    a = n("mUPD "),
    o = n("OJZr ");
    Object.assign(i.prototype, {
        load: function(t, e, n, i) {
            var o = new a.a,
            s = new r.a(this.manager);
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path);
            for (var u = 0,
            c = 0; c < t.length; ++c) !
            function(n) {
                s.load(t[n],
                function(t) {
                    o.images[n] = t,
                    6 == ++u && (o.needsUpdate = true, e && e(o))
                },
                undefined, i)
            } (c);
            return o
        },
        setCrossOrigin: function(t) {
            return this.crossOrigin = t,
            this
        },
        setPath: function(t) {
            return this.path = t,
            this
        }
    })
},
tzsk: function(t, e, n) {
    "use strict ";
    function i(t) {
        "string " == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]),
        this.value = t
    }
    i.prototype.clone = function() {
        return new i(undefined === this.value.clone ? this.value: this.value.clone())
    }
},
u0MW: function(t, e, n) {
    "use strict ";
    function i(t) {
        var e = t.readByte(),
        n = t.readSwappedInt(),
        i = t.readSwappedInt();
        if (i < 0) throw new Error("Illegal data array length " + i);
        if (0 === i) return [];
        var r = t.readBytes(n),
        o = r.length;
        if (o < n) throw new Error("Not enough data!we need " + n + "bytes, but only read " + o + "bytes.type is " + e);
        var s = new a.a(r),
        u = d[e];
        if (u) return u.read(s, i);
        throw new Error("Illegal data array type ")
    }
    e.a = i;
    var r = n("4 ic7 "),
    a = n("5 mWq "),
    o = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            for (var n = [], i = 0; i < e; i++) n.push(t.readSwappedInt());
            return n
        },
        t
    } (),
    s = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            for (var n = [], i = 0; i < e; i++) n.push(t.readSwappedShort());
            return n
        },
        t
    } (),
    u = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            for (var n = [], i = 0; i < e; i++) n.push(t.readSwappedShort() + 32767);
            return n
        },
        t
    } (),
    c = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            var n = [],
            i = t.readZigzag(),
            r = t.readZigzag(),
            a = t.readZigzag();
            if (n.push(i, r, a), e % 3 != 0) throw new Error("Invalid VriantArray data ");
            for (var o = 1; o < e / 3; o++) i += t.readZigzag(),
            n.push(i),
            r += t.readZigzag(),
            n.push(r),
            a += t.readZigzag(),
            n.push(a);
            return n
        },
        t
    } (),
    h = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            var n = [],
            i = t.readZigzag(),
            r = t.readZigzag();
            if (n.push(i, r), e % 2 != 0) throw new Error("Invalid TwoStepVriantArray data ");
            for (var a = 1; a < e / 2; a++) i += t.readZigzag(),
            n.push(i),
            r += t.readZigzag(),
            n.push(r);
            return n
        },
        t
    } (),
    l = function() {
        function t() {}
        return t.prototype.read = function(e, n) {
            if (n <= 0) return [];
            for (var i = t.BITS,
            a = new r.a(e), o = [], s = 0; s < n; s++) o.push(a.read(i));
            for (var u = 0,
            c = [], s = 0; s < n; s++) if (0 === o[s]) c.push(u);
            else {
                var h = a.read(o[s]),
                l = 1 << o[s] - 1;
                h < l && (h = -h - l),
                h += u,
                c.push(h),
                u = h
            }
            return c
        },
        t.BITS = 5,
        t
    } (),
    f = function() {
        function t() {}
        return t.prototype.read = function(e, n) {
            if (n <= 0) return [];
            for (var i = t.BITS,
            a = t.STRIDE,
            o = new r.a(e), s = [0, 0], u = [], c = 0; c < n / a; c++) u.push(o.read(i));
            for (var h = [], c = 0; c < n / a; c++) {
                var l = u[c];
                if (0 === l) for (var f = 0; f < a; f++) h.push(s[f]);
                else for (var f = 0; f < a; f++) {
                    var p = o.read(l),
                    d = 1 << l - 1;
                    p = p - d + s[f],
                    h.push(p),
                    s[f] = p
                }
            }
            return h
        },
        t.BITS = 5,
        t.STRIDE = 2,
        t
    } (),
    p = function() {
        function t() {}
        return t.prototype.read = function(e, n) {
            if (n <= 0) return [];
            for (var i = t.BITS,
            a = t.STRIDE,
            o = new r.a(e), s = [0, 0, 0], u = [], c = 0; c < n / a; c++) u.push(o.read(i));
            for (var h = [], c = 0; c < n / a; c++) {
                var l = u[c];
                if (0 === l) for (var f = 0; f < a; f++) h.push(s[f]);
                else for (var f = 0; f < a; f++) {
                    var p = o.read(l),
                    d = 1 << l - 1;
                    p = p - d + s[f],
                    h.push(p),
                    s[f] = p
                }
            }
            return h
        },
        t.BITS = 5,
        t.STRIDE = 3,
        t
    } (),
    d = {
        0 : new o,
        1 : new s,
        2 : new u,
        3 : new c,
        4 : new h,
        5 : new l,
        6 : new f,
        7 : new p
    }
},
uDA3: function(t, e, n) {
    "use strict ";
    function i(t, e, n, i) {
        r.a.call(this),
        this.v0 = t,
        this.v1 = e,
        this.v2 = n,
        this.v3 = i
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Lk8y "),
    a = n("JJh5 "),
    o = n("Ne + j ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.getPoint = function(t) {
        var e = this.v0,
        n = this.v1,
        i = this.v2,
        r = this.v3;
        return new o.a(Object(a.b)(t, e.x, n.x, i.x, r.x), Object(a.b)(t, e.y, n.y, i.y, r.y))
    }
},
uPDx: function(t, e, n) {
    "use strict ";
    function i(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder: t.program && e.program && t.program !== e.program ? t.program.id - e.program.id: t.material.id !== e.material.id ? t.material.id - e.material.id: t.z !== e.z ? t.z - e.z: t.id - e.id
    }
    function r(t, e) {
        return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder: t.z !== e.z ? e.z - t.z: t.id - e.id
    }
    function a() {
        function t() {
            s = -1,
            c = -1
        }
        function e(t, e, n, i, r) {
            var a, h;
            n.transparent ? (a = u, h = ++c) : (a = o, h = ++s);
            var l = a[h];
            l ? (l.id = t.id, l.object = t, l.geometry = e, l.material = n, l.program = n.program, l.renderOrder = t.renderOrder, l.z = i, l.group = r) : (l = {
                id: t.id,
                object: t,
                geometry: e,
                material: n,
                program: n.program,
                renderOrder: t.renderOrder,
                z: i,
                group: r
            },
            a.push(l))
        }
        function n() {
            o.length = s + 1,
            u.length = c + 1
        }
        function a() {
            o.sort(i),
            u.sort(r)
        }
        var o = [],
        s = -1,
        u = [],
        c = -1;
        return {
            opaque: o,
            transparent: u,
            init: t,
            push: e,
            finish: n,
            sort: a
        }
    }
    function o() {
        function t(t, e) {
            var i = t.id + ", " + e.id,
            r = n[i];
            return undefined === r && (r = new a, n[i] = r),
            r
        }
        function e() {
            n = {}
        }
        var n = {};
        return {
            get: t,
            dispose: e
        }
    }
    n.d(e, "a ",
    function() {
        return o
    })
},
uQxt: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.points = undefined === t ? [] : t
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Lk8y "),
    a = n("JJh5 "),
    o = n("Ne + j ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isSplineCurve = true,
    i.prototype.getPoint = function(t) {
        var e = this.points,
        n = (e.length - 1) * t,
        i = Math.floor(n),
        r = n - i,
        s = e[0 === i ? i: i - 1],
        u = e[i],
        c = e[i > e.length - 2 ? e.length - 1 : i + 1],
        h = e[i > e.length - 3 ? e.length - 1 : i + 2];
        return new o.a(Object(a.a)(r, s.x, u.x, c.x, h.x), Object(a.a)(r, s.y, u.y, c.y, h.y))
    }
},
uiDP: function(t, e, n) {
    "use strict ";
    function i(t) {
        if (t) return t.isPerspectiveCamera ? r.Perspective: t.isOrthographicCamera ? r.Orthographic: undefined
    }
    n.d(e, "a ",
    function() {
        return o
    });
    var r, a = n(.D:ShaderLib.G:UniformsUtils.C:Scene.q:Mesh.h:DataTexture.x:PlaneBufferGeometry.
.r:MeshBasicMaterial.s:MeshDepthMaterial.E:ShaderMaterial.w:OrthographicCamera.
.e:BufferGeometry.d:BufferAttribute.m:EventDispatcher.M:_Math.n:Frustum.p:Matrix4.
.c:Box3.l:Euler.K:Vector4.J:Vector3.I:Vector2.f:Color.); !
    function(t) {
        t[t.Perspective = 0] = "Perspective ",
        t[t.Orthographic = 1] = "Orthographic "
    } (r || (r = {}));
    var o = function() {
        function t() {
            this.up = new a.J,
            this.position = new a.J,
            this.target = new a.J
        }
        return t.prototype.copyProjection = function(t) {
            var e = i(t);
            if (e === r.Perspective) {
                this.cameraType = r.Perspective;
                var n = t;
                this.near = n.near,
                this.far = n.far,
                this.fov = n.fov,
                this.aspect = n.aspect
            } else if (e === r.Orthographic) {
                this.cameraType = r.Orthographic;
                var a = t;
                this.left = a.left,
                this.right = a.right,
                this.top = a.top,
                this.bottom = a.bottom,
                this.near = a.near,
                this.far = a.far
            } else console.warn("unsupported camera type.")
        },
        t.prototype.setProjection = function(t) {
            var e = i(t);
            if (e !== this.cameraType) return void console.warn("mismatched camera type.");
            e === r.Perspective ? (t.fov = this.fov, t.aspect = this.aspect, t.near = this.near, t.far = this.far) : e === r.Orthographic ? (t.left = this.left, t.right = this.right, t.top = this.top, t.bottom = this.bottom, t.near = this.near, t.far = this.far) : console.warn("unsupported camera type.")
        },
        t.prototype.copy = function(t) {
            return this.up.copy(t.up),
            this.position.copy(t.position),
            this.target.copy(t.target),
            this.near = t.near,
            this.far = t.far,
            this.fov = t.fov,
            this.aspect = t.aspect,
            this.left = t.left,
            this.right = t.right,
            this.top = t.top,
            this.bottom = t.bottom,
            this.cameraType = t.cameraType,
            this
        },
        t.prototype.clone = function() {
            var e = new t;
            return e.copy(this),
            e
        },
        t.prototype.interpolate = function(t, e, n) {
            this.cameraType === t.cameraType ? (this.up.copy(t.up), this.position.copy(e.position).sub(t.position).multiplyScalar(n).add(t.position), this.target.copy(e.target).sub(t.target).multiplyScalar(n).add(t.target)) : console.warn("mismatched camera type.")
        },
        t
    } ()
},
AudioListener: function(t, e, n) {
    "use strict ";
    function i() {
        o.a.call(this),
        this.type = "AudioListener ",
        this.context = s.a.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null
    }
    var r = n("Vector3 "),
    a = n("Quaternion "),
    o = n("87 g3 "),
    s = n("IASN ");
    i.prototype = Object.assign(Object.create(o.a.prototype), {
        constructor: i,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(t) {
            null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
            this.filter = t,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination)
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(t) {
            this.gain.gain.value = t
        },
        updateMatrixWorld: function() {
            var t = new r.a,
            e = new a.a,
            n = new r.a,
            i = new r.a;
            return function(r) {
                o.a.prototype.updateMatrixWorld.call(this, r);
                var a = this.context.listener,
                s = this.up;
                this.matrixWorld.decompose(t, e, n),
                i.set(0, 0, -1).applyQuaternion(e),
                a.positionX ? (a.positionX.setValueAtTime(t.x, this.context.currentTime), a.positionY.setValueAtTime(t.y, this.context.currentTime), a.positionZ.setValueAtTime(t.z, this.context.currentTime), a.forwardX.setValueAtTime(i.x, this.context.currentTime), a.forwardY.setValueAtTime(i.y, this.context.currentTime), a.forwardZ.setValueAtTime(i.z, this.context.currentTime), a.upX.setValueAtTime(s.x, this.context.currentTime), a.upY.setValueAtTime(s.y, this.context.currentTime), a.upZ.setValueAtTime(s.z, this.context.currentTime)) : (a.setPosition(t.x, t.y, t.z), a.setOrientation(i.x, i.y, i.z, s.x, s.y, s.z))
            }
        } ()
    })
},
v0yF: function(t, e, n) {
    "use strict ";
    e.a = "#if defined(DITHERING)\\ n\\ tvec3 dithering(vec3 color) {\\n\\ t\\ tfloat grid_position = rand(gl_FragCoord.xy);\\n\\ t\\ tvec3 dither_shift_RGB = vec3(0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0);\\n\\ t\\ tdither_shift_RGB = mix(2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position);\\n\\ t\\ treturn color + dither_shift_RGB;\\n\\ t}\\n # endif\\ n "
},
v504: function(t, e, n) {
    "use strict ";
    function i(t, e, n) {
        this.uuid = u.a.generateUUID(),
        this.width = t,
        this.height = e,
        this.scissor = new s.a(0, 0, t, e),
        this.scissorTest = false,
        this.viewport = new s.a(0, 0, t, e),
        n = n || {},
        undefined === n.minFilter && (n.minFilter = o.Q),
        this.texture = new a.a(undefined, undefined, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding),
        this.depthBuffer = undefined === n.depthBuffer || n.depthBuffer,
        this.stencilBuffer = undefined === n.stencilBuffer || n.stencilBuffer,
        this.depthTexture = undefined !== n.depthTexture ? n.depthTexture: null
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("2 aAi "),
    a = n("vh + C "),
    o = n("RBSo "),
    s = n("Vector4 "),
    u = n("7 MDU ");
    Object.assign(i.prototype, r.a.prototype, {
        isWebGLRenderTarget: true,
        setSize: function(t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.width = t.width,
            this.height = t.height,
            this.viewport.copy(t.viewport),
            this.texture = t.texture.clone(),
            this.depthBuffer = t.depthBuffer,
            this.stencilBuffer = t.stencilBuffer,
            this.depthTexture = t.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose "
            })
        }
    })
},
vaUk: function(t, e, n) {
    "use strict ";
    function i() {
        this.mask = 1
    }
    n.d(e, "a ",
    function() {
        return i
    }),
    Object.assign(i.prototype, {
        set: function(t) {
            this.mask = 1 << t | 0
        },
        enable: function(t) {
            this.mask |= 1 << t | 0
        },
        toggle: function(t) {
            this.mask ^= 1 << t | 0
        },
        disable: function(t) {
            this.mask &= ~ (1 << t | 0)
        },
        test: function(t) {
            return 0 != (this.mask & t.mask)
        }
    })
},
PointsMaterial: function(t, e, n) {
    "use strict ";
    function i(t) {
        r.a.call(this),
        this.type = "PointsMaterial ",
        this.color = new a.a(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = true,
        this.lights = false,
        this.setValues(t)
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("Material "),
    a = n("Color ");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isPointsMaterial = true,
    i.prototype.copy = function(t) {
        return r.a.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.size = t.size,
        this.sizeAttenuation = t.sizeAttenuation,
        this
    }
},
"vh + C ": function(t, e, n) {
    "use strict ";
    function i(t, e, n, r, c, h, l, f, p, d) {
        Object.defineProperty(this, "id ", {
            value: u++
        }),
        this.uuid = o.a.generateUUID(),
        this.name = "",
        this.image = undefined !== t ? t: i.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = undefined !== e ? e: i.DEFAULT_MAPPING,
        this.wrapS = undefined !== n ? n: a.j,
        this.wrapT = undefined !== r ? r: a.j,
        this.magFilter = undefined !== c ? c: a.Q,
        this.minFilter = undefined !== h ? h: a.R,
        this.anisotropy = undefined !== p ? p: 1,
        this.format = undefined !== l ? l: a._22,
        this.type = undefined !== f ? f: a._53,
        this.offset = new s.a(0, 0),
        this.repeat = new s.a(1, 1),
        this.generateMipmaps = true,
        this.premultiplyAlpha = false,
        this.flipY = true,
        this.unpackAlignment = 4,
        this.encoding = undefined !== d ? d: a.P,
        this.version = 0,
        this.onUpdate = null
    }
    n.d(e, "a ",
    function() {
        return i
    });
    var r = n("2 aAi "),
    a = n("RBSo "),
    o = n("7 MDU "),
    s = n("Ne + j "),
    u = 0;
    i.DEFAULT_IMAGE = undefined,
    i.DEFAULT_MAPPING = a._51,
    Object.defineProperty(i.prototype, "needsUpdate ", {
        set: function(t) { ! 0 === t && this.version++
        }
    }),
    Object.assign(i.prototype, r.a.prototype, {
        constructor: i,
        isTexture: true,
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.name = t.name,
            this.image = t.image,
            this.mipmaps = t.mipmaps.slice(0),
            this.mapping = t.mapping,
            this.wrapS = t.wrapS,
            this.wrapT = t.wrapT,
            this.magFilter = t.magFilter,
            this.minFilter = t.minFilter,
            this.anisotropy = t.anisotropy,
            this.format = t.format,
            this.type = t.type,
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.generateMipmaps = t.generateMipmaps,
            this.premultiplyAlpha = t.premultiplyAlpha,
            this.flipY = t.flipY,
            this.unpackAlignment = t.unpackAlignment,
            this.encoding = t.encoding,
            this
        },
        toJSON: function(t) {
            if (undefined !== t.textures[this.uuid]) return t.textures[this.uuid];
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Texture ",
                    generator: "Texture.toJSON "
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                wrap: [this.wrapS, this.wrapT],
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY
            };
            if (undefined !== this.image) {
                var n = this.image;
                undefined === n.uuid && (n.uuid = o.a.generateUUID()),
                undefined === t.images[n.uuid] && (t.images[n.uuid] = {
                    uuid: n.uuid,
                    url: function(t) {
                        var e;
                        return undefined !== t.toDataURL ? e = t: (e = document.createElementNS("http: //www.w3.org/1999/xhtml", "canvas"), e.width = t.width, e.height = t.height, e.getContext("2d").drawImage(t, 0, 0, t.width, t.height)),
                        e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    } (n)
                }),
                e.image = n.uuid
            }
            return t.textures[this.uuid] = e,
            e
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(t) {
            if (this.mapping === a._51) {
                if (t.multiply(this.repeat), t.add(this.offset), t.x < 0 || t.x > 1) switch (this.wrapS) {
                case a._38:
                    t.x = t.x - Math.floor(t.x);
                    break;
                case a.j:
                    t.x = t.x < 0 ? 0 : 1;
                    break;
                case a._1:
                    1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x: t.x = t.x - Math.floor(t.x)
                }
                if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                case a._38:
                    t.y = t.y - Math.floor(t.y);
                    break;
                case a.j:
                    t.y = t.y < 0 ? 0 : 1;
                    break;
                case a._1:
                    1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y: t.y = t.y - Math.floor(t.y)
                }
                this.flipY && (t.y = 1 - t.y)
            }
        }
    })
},
vrbZ: function(t, e, n) {
    "use strict";
    e.a = "#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\\t#include <uv_vertex>\\n\\t#include <uv2_vertex>\\n\\t#include <color_vertex>\\n\\t#include <skinbase_vertex>\\n\\t#ifdef USE_ENVMAP\\n\\t#include <beginnormal_vertex>\\n\\t#include <morphnormal_vertex>\\n\\t#include <skinnormal_vertex>\\n\\t#include <defaultnormal_vertex>\\n\\t#endif\\n\\t#include <begin_vertex>\\n\\t#include <morphtarget_vertex>\\n\\t#include <skinning_vertex>\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\t#include <envmap_vertex>\\n\\t#include <fog_vertex>\\n}\\n"
},
w2Sq: function(t, e, n) {
    "use strict";
    function i(t) {
        this.manager = undefined !== t ? t: a.a
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("/bYS"),
    a = n("OJZr");
    Object.assign(i.prototype, {
        load: function(t, e, n, i) {
            undefined === t && (t = ""),
            undefined !== this.path && (t = this.path + t);
            var a = this,
            o = r.a.get(t);
            if (undefined !== o) return a.manager.itemStart(t),
            setTimeout(function() {
                e && e(o),
                a.manager.itemEnd(t)
            },
            0),
            o;
            var s = /^data:(.*?)(;base64)?,(.*)$/,
            u = t.match(s);
            if (u) {
                var c = u[1],
                h = !!u[2],
                l = u[3];
                l = window.decodeURIComponent(l),
                h && (l = window.atob(l));
                try {
                    var f, p = (this.responseType || "").toLowerCase();
                    switch (p) {
                    case "arraybuffer":
                    case "blob":
                        f = new ArrayBuffer(l.length);
                        for (var d = new Uint8Array(f), m = 0; m < l.length; m++) d[m] = l.charCodeAt(m);
                        "blob" === p && (f = new Blob([f], {
                            type: c
                        }));
                        break;
                    case "document":
                        var v = new DOMParser;
                        f = v.parseFromString(l, c);
                        break;
                    case "json":
                        f = JSON.parse(l);
                        break;
                    default:
                        f = l
                    }
                    window.setTimeout(function() {
                        e && e(f),
                        a.manager.itemEnd(t)
                    },
                    0)
                } catch(e) {
                    window.setTimeout(function() {
                        i && i(e),
                        a.manager.itemEnd(t),
                        a.manager.itemError(t)
                    },
                    0)
                }
            } else {
                var g = new XMLHttpRequest;
                g.open("GET", t, true),
                g.addEventListener("load",
                function(n) {
                    var o = n.target.response;
                    r.a.add(t, o),
                    200 === this.status ? (e && e(o), a.manager.itemEnd(t)) : 0 === this.status ? (console.warn("THREE.FileLoader: HTTP Status 0 received."), e && e(o), a.manager.itemEnd(t)) : (i && i(n), a.manager.itemEnd(t), a.manager.itemError(t))
                },
                false),
                undefined !== n && g.addEventListener("progress",
                function(t) {
                    n(t)
                },
                false),
                g.addEventListener("error",
                function(e) {
                    i && i(e),
                    a.manager.itemEnd(t),
                    a.manager.itemError(t)
                },
                false),
                undefined !== this.responseType && (g.responseType = this.responseType),
                undefined !== this.withCredentials && (g.withCredentials = this.withCredentials),
                g.overrideMimeType && g.overrideMimeType(undefined !== this.mimeType ? this.mimeType: "text/plain");
                for (var y in this.requestHeader) g.setRequestHeader(y, this.requestHeader[y]);
                g.send(null)
            }
            return a.manager.itemStart(t),
            g
        },
        setPath: function(t) {
            return this.path = t,
            this
        },
        setResponseType: function(t) {
            return this.responseType = t,
            this
        },
        setWithCredentials: function(t) {
            return this.withCredentials = t,
            this
        },
        setMimeType: function(t) {
            return this.mimeType = t,
            this
        },
        setRequestHeader: function(t) {
            return this.requestHeader = t,
            this
        }
    })
},
w6dw: function(t, e, n) {
    "use strict";
    function i(t, e) {
        return t.distance - e.distance
    }
    function r(t, e) {
        for (var n = 0,
        i = t.length; n < i; ++n) {
            var a = t[n];
            a.isMesh && a.visible && e.push(a),
            r(a.children, e)
        }
    }
    n.d(e, "a",
    function() {
        return c
    });
    var a = n("nBLQ"),
    o = n("Box3"),
    s = n("CustomerDefine3"),
    u = new o.a,
    c = function() {
        function t() {
            this.raycaster = new a.a
        }
        return t.prototype.setRenderModel = function(t) {
            this.renderModel = t
        },
        t.prototype.intersectObject = function(t) {
            var e = this,
            n = [];
            if (undefined === t) this.renderModel.fragments.forEach(function(t, i) {
                var r = e.renderModel.getObject(i),
                a = e.renderModel.getSubMeshGroup(i);
                s.b.setToThree(e.renderModel.fragments.boxes, i, u),
                !Number.isNaN(u.min.x) && e.raycaster.ray.intersectsBox(u) && r.egsRaycast(e.raycaster, n, a)
            });
            else {
                var a = [];
                r(t, a);
                for (var o = 0,
                c = a.length; o < c; ++o) {
                    var h = a[o],
                    l = this.renderModel.fragments.getObjectFragmentIds(h);
                    if (undefined !== l) for (var f = 0; f < l.length; f++) {
                        var p = l[f],
                        d = this.renderModel.getSubMeshGroup(p);
                        s.b.setToThree(this.renderModel.fragments.boxes, p, u),
                        !Number.isNaN(u.min.x) && this.raycaster.ray.intersectsBox(u) && h.egsRaycast(this.raycaster, n, d)
                    }
                }
            }
            return n.sort(i)
        },
        t.prototype.pick = function(t, e, n, i) {
            return undefined === n && (n = false),
            this.raycaster.setFromCamera(t, e),
            n ? this.pickFirst(t, e, i) : this.intersectObject(i)
        },
        t.prototype.pickFirst = function(t, e, n) {
            var i = this,
            a = [],
            o = [];
            if (undefined === n) {
                this.renderModel.fragments.forEach(function(t, e) {
                    var n = i.renderModel.fragments.objects[e],
                    r = i.renderModel.getObject(n);
                    s.b.setToThree(i.renderModel.fragments.boxes, e, u);
                    var a = i.raycaster.ray.intersectsBox(u);
                    Number.isNaN(u.min.x) || null === a || o.push({
                        obj: r,
                        distance: a
                    })
                }),
                o.sort(function(t, e) {
                    return t.distance - e.distance
                });
                for (var c = Number.MAX_VALUE,
                h = 0,
                l = undefined,
                f = 0; f < o.length; f++) {
                    l = o[f];
                    var p = a.length;
                    if (l.obj.egsRaycast(this.raycaster, a), h = f === o.length - 1 ? c: o[f + 1].distance, a.length > p) {
                        for (var d = a.length - p,
                        m = a.length - d; m < a.length; m++) c = Math.min(c, a[m].distance);
                        if ((c = Math.min(c, a[a.length - 1].distance)) <= h + 1e-8) return a.slice(a.length - d)
                    }
                }
                return []
            }
            var v = [],
            g = [];
            r(n, g);
            for (var f = 0,
            y = g.length; f < y; ++f) for (var _ = g[f], x = this.renderModel.fragments.getObjectFragmentIds(_), b = 0; b < x.length; b++) {
                var w = x[b];
                s.b.setToThree(this.renderModel.fragments.boxes, w, u);
                var M = this.raycaster.ray.intersectBox(u);
                if (null !== M) {
                    var S = M.distanceTo(this.raycaster.ray.origin);
                    v.push({
                        distance: S,
                        object: _
                    })
                }
            }
            v.sort(function(t, e) {
                return t.distance - e.distance
            });
            for (var E = Number.MAX_VALUE,
            T = null,
            f = 0,
            y = v.length; f < y; ++f) {
                var A = v[0],
                S = A.distance,
                C = A.object;
                if (! (E < Number.MAX_VALUE && S > E)) {
                    var P = [];
                    C.egsRaycast(this.raycaster, P),
                    P.length > 0 && P[0].distance < E && (T = P[0])
                }
            }
            return null === T ? [] : [T]
        },
        t
    } ()
},
w9Lf: function(t, e, n) {
    "use strict";
    function i(t, e, n) {
        function i(t) {
            o = t
        }
        function r(e, i) {
            t.drawArrays(o, e, i),
            n.calls++,
            n.vertices += i,
            o === t.TRIANGLES && (n.faces += i / 3)
        }
        function a(i, r, a) {
            var s = e.get("ANGLE_instanced_arrays");
            if (null === s) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            var u = i.attributes.position;
            u.isInterleavedBufferAttribute ? (a = u.data.count, s.drawArraysInstancedANGLE(o, 0, a, i.maxInstancedCount)) : s.drawArraysInstancedANGLE(o, r, a, i.maxInstancedCount),
            n.calls++,
            n.vertices += a * i.maxInstancedCount,
            o === t.TRIANGLES && (n.faces += i.maxInstancedCount * a / 3)
        }
        var o;
        this.setMode = i,
        this.render = r,
        this.renderInstances = a
    }
    n.d(e, "a",
    function() {
        return i
    })
},
w9Z8: function(t, e, n) {
    "use strict";
    e.a = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\\tvViewPosition = - mvPosition.xyz;\\n#endif\\n"
},
MeshBasicMaterial: function(t, e, n) {
    "use strict";
    function i(t) {
        r.a.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new o.a(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.combine = a._4,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = false,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = false,
        this.morphTargets = false,
        this.lights = false,
        this.setValues(t)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Material"),
    a = n("RBSo"),
    o = n("Color");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isMeshBasicMaterial = true,
    i.prototype.copy = function(t) {
        return r.a.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.map = t.map,
        this.lightMap = t.lightMap,
        this.lightMapIntensity = t.lightMapIntensity,
        this.aoMap = t.aoMap,
        this.aoMapIntensity = t.aoMapIntensity,
        this.specularMap = t.specularMap,
        this.alphaMap = t.alphaMap,
        this.envMap = t.envMap,
        this.combine = t.combine,
        this.reflectivity = t.reflectivity,
        this.refractionRatio = t.refractionRatio,
        this.wireframe = t.wireframe,
        this.wireframeLinewidth = t.wireframeLinewidth,
        this.wireframeLinecap = t.wireframeLinecap,
        this.wireframeLinejoin = t.wireframeLinejoin,
        this.skinning = t.skinning,
        this.morphTargets = t.morphTargets,
        this
    }
},
x5fO: function(t, e, n) {
    "use strict";
    e.a = "uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\\t\\tdiscard;\\n\\t}\\n\\tvec3 outgoingLight = vec3( 0.0 );\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <color_fragment>\\n\\toutgoingLight = diffuseColor.rgb;\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n}\\n"
},
Line: function(t, e, n) {
    "use strict";
    function i(t, e, n) {
        if (1 === n) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
        new l.a(t, e);
        s.a.call(this),
        this.type = "Line";
        var i = undefined !== t ? t: new h.a,
        r = undefined !== e ? e: new c.a({
            color: 16777215 * Math.random()
        });
        Object.defineProperties(this, {
            geometry: {
                get: function() {
                    return i
                },
                set: function(t) {
                    i = t,
                    this.setGeometryChanged()
                }
            },
            material: {
                get: function() {
                    return r
                },
                set: function(t) {
                    r = t,
                    this.setMaterialChanged()
                }
            }
        })
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Sphere"),
    a = n("6YUT"),
    o = n("Matrix4"),
    s = n("Object3D"),
    u = n("Vector3"),
    c = n("LineBasicMaterial"),
    h = n("BufferGeometry"),
    l = n("LineSegments");
    i.prototype = Object.assign(Object.create(s.a.prototype), {
        constructor: i,
        isLine: true,
        egsRaycast: function(t, e) {
            this.raycast(t, e)
        },
        raycast: function() {
            var t = new new Matrix4(),
            e = new a.a,
            n = new r.a;
            return function(i, r) {
                var a = i.linePrecision,
                o = a * a,
                s = this.geometry,
                c = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(), n.copy(s.boundingSphere), n.applyMatrix4(c), false !== i.ray.intersectsSphere(n)) {
                    t.getInverse(c),
                    e.copy(i.ray).applyMatrix4(t);
                    var h = new u.a,
                    l = new u.a,
                    f = new u.a,
                    p = new u.a,
                    d = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var m = s.index,
                        v = s.attributes,
                        g = v.position.array;
                        if (null !== m) for (var y = m.array,
                        _ = 0,
                        x = y.length - 1; _ < x; _ += d) {
                            var b = y[_],
                            w = y[_ + 1];
                            h.fromArray(g, 3 * b),
                            l.fromArray(g, 3 * w);
                            var M = e.distanceSqToSegment(h, l, p, f);
                            if (! (M > o)) {
                                p.applyMatrix4(this.matrixWorld);
                                var S = i.ray.origin.distanceTo(p);
                                S < i.near || S > i.far || r.push({
                                    distance: S,
                                    point: f.clone().applyMatrix4(this.matrixWorld),
                                    index: _,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else for (var _ = 0,
                        x = g.length / 3 - 1; _ < x; _ += d) {
                            h.fromArray(g, 3 * _),
                            l.fromArray(g, 3 * _ + 3);
                            var M = e.distanceSqToSegment(h, l, p, f);
                            if (! (M > o)) {
                                p.applyMatrix4(this.matrixWorld);
                                var S = i.ray.origin.distanceTo(p);
                                S < i.near || S > i.far || r.push({
                                    distance: S,
                                    point: f.clone().applyMatrix4(this.matrixWorld),
                                    index: _,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        }
                    } else if (s.isGeometry) for (var E = s.vertices,
                    T = E.length,
                    _ = 0; _ < T - 1; _ += d) {
                        var M = e.distanceSqToSegment(E[_], E[_ + 1], p, f);
                        if (! (M > o)) {
                            p.applyMatrix4(this.matrixWorld);
                            var S = i.ray.origin.distanceTo(p);
                            S < i.near || S > i.far || r.push({
                                distance: S,
                                point: f.clone().applyMatrix4(this.matrixWorld),
                                index: _,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                }
            }
        } (),
        clone: function() {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    })
},
xBPj: function(t, e, n) {
    "use strict";
    function i(t) {
        function e(t, e, i) {
            n(t, i),
            n(e, i)
        }
        function n(t, e) {
            a.push(0, 0, 0),
            f.push(e.r, e.g, e.b),
            undefined === p[t] && (p[t] = []),
            p[t].push(a.length / 3 - 1)
        }
        var i = new h.a,
        r = new c.a({
            color: 16777215,
            vertexColors: u.A
        }),
        a = [],
        f = [],
        p = {},
        d = new s.a(16755200),
        m = new s.a(16711680),
        v = new s.a(43775),
        g = new s.a(16777215),
        y = new s.a(3355443);
        e("n1", "n2", d),
        e("n2", "n4", d),
        e("n4", "n3", d),
        e("n3", "n1", d),
        e("f1", "f2", d),
        e("f2", "f4", d),
        e("f4", "f3", d),
        e("f3", "f1", d),
        e("n1", "f1", d),
        e("n2", "f2", d),
        e("n3", "f3", d),
        e("n4", "f4", d),
        e("p", "n1", m),
        e("p", "n2", m),
        e("p", "n3", m),
        e("p", "n4", m),
        e("u1", "u2", v),
        e("u2", "u3", v),
        e("u3", "u1", v),
        e("c", "t", g),
        e("p", "c", y),
        e("cn1", "cn2", y),
        e("cn3", "cn4", y),
        e("cf1", "cf2", y),
        e("cf3", "cf4", y),
        i.addAttribute("position", new l.b(a, 3)),
        i.addAttribute("color", new l.b(f, 3)),
        o.a.call(this, i, r),
        this.camera = t,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = false,
        this.pointMap = p,
        this.update()
    }
    var r = n("Camera"),
    a = n("Vector3"),
    o = n("LineSegments"),
    s = n("Color"),
    u = n("RBSo"),
    c = n("LineBasicMaterial"),
    h = n("BufferGeometry"),
    l = n("BufferAttribute");
    i.prototype = Object.create(o.a.prototype),
    i.prototype.constructor = i,
    i.prototype.update = function() {
        function t(t, r, a, s) {
            i.set(r, a, s).unproject(o);
            var u = n[t];
            if (undefined !== u) for (var c = e.getAttribute("position"), h = 0, l = u.length; h < l; h++) c.setXYZ(u[h], i.x, i.y, i.z)
        }
        var e, n, i = new a.a,
        o = new r.a;
        return function() {
            e = this.geometry,
            n = this.pointMap;
            o.projectionMatrix.copy(this.camera.projectionMatrix),
            t("c", 0, 0, -1),
            t("t", 0, 0, 1),
            t("n1", -1, -1, -1),
            t("n2", 1, -1, -1),
            t("n3", -1, 1, -1),
            t("n4", 1, 1, -1),
            t("f1", -1, -1, 1),
            t("f2", 1, -1, 1),
            t("f3", -1, 1, 1),
            t("f4", 1, 1, 1),
            t("u1", .7, 1.1, -1),
            t("u2", -.7, 1.1, -1),
            t("u3", 0, 2, -1),
            t("cf1", -1, 0, 1),
            t("cf2", 1, 0, 1),
            t("cf3", 0, -1, 1),
            t("cf4", 0, 1, 1),
            t("cn1", -1, 0, -1),
            t("cn2", 1, 0, -1),
            t("cn3", 0, -1, -1),
            t("cn4", 0, 1, -1),
            e.getAttribute("position").needsUpdate = true
        }
    } ()
},
xKwM: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_DISPLACEMENTMAP\\n\\tuniform sampler2D displacementMap;\\n\\tuniform float displacementScale;\\n\\tuniform float displacementBias;\\n#endif\\n"
},
xcHZ: function(t, e, n) {
    "use strict";
    function i() {
        this.subPaths = [],
        this.currentPath = null
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("/wr7"),
    a = n("8Zdr"),
    o = n("f7ra");
    Object.assign(i.prototype, {
        moveTo: function(t, e) {
            this.currentPath = new r.a,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(t, e)
        },
        lineTo: function(t, e) {
            this.currentPath.lineTo(t, e)
        },
        quadraticCurveTo: function(t, e, n, i) {
            this.currentPath.quadraticCurveTo(t, e, n, i)
        },
        bezierCurveTo: function(t, e, n, i, r, a) {
            this.currentPath.bezierCurveTo(t, e, n, i, r, a)
        },
        splineThru: function(t) {
            this.currentPath.splineThru(t)
        },
        toShapes: function(t, e) {
            function n(t) {
                for (var e = [], n = 0, i = t.length; n < i; n++) {
                    var r = t[n],
                    o = new a.a;
                    o.curves = r.curves,
                    e.push(o)
                }
                return e
            }
            var i = o.a.isClockWise,
            r = this.subPaths;
            if (0 === r.length) return [];
            if (true === e) return n(r);
            var s, u, c, h = [];
            if (1 === r.length) return u = r[0],
            c = new a.a,
            c.curves = u.curves,
            h.push(c),
            h;
            var l = !i(r[0].getPoints());
            l = t ? !l: l;
            var f, p = [],
            d = [],
            m = [],
            v = 0;
            d[v] = undefined,
            m[v] = [];
            for (var g = 0,
            y = r.length; g < y; g++) u = r[g],
            f = u.getPoints(),
            s = i(f),
            s = t ? !s: s,
            s ? (!l && d[v] && v++, d[v] = {
                s: new a.a,
                p: f
            },
            d[v].s.curves = u.curves, l && v++, m[v] = []) : m[v].push({
                h: u,
                p: f[0]
            });
            if (!d[0]) return n(r);
            if (d.length > 1) {
                for (var _ = false,
                x = [], b = 0, w = d.length; b < w; b++) p[b] = [];
                for (var b = 0,
                w = d.length; b < w; b++) for (var M = m[b], S = 0; S < M.length; S++) {
                    for (var E = M[S], T = true, A = 0; A < d.length; A++)(function(t, e) {
                        for (var n = e.length,
                        i = false,
                        r = n - 1,
                        a = 0; a < n; r = a++) {
                            var o = e[r],
                            s = e[a],
                            u = s.x - o.x,
                            c = s.y - o.y;
                            if (Math.abs(c) > Number.EPSILON) {
                                if (c < 0 && (o = e[a], u = -u, s = e[r], c = -c), t.y < o.y || t.y > s.y) continue;
                                if (t.y === o.y) {
                                    if (t.x === o.x) return ! 0
                                } else {
                                    var h = c * (t.x - o.x) - u * (t.y - o.y);
                                    if (0 === h) return ! 0;
                                    if (h < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== o.y) continue;
                                if (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x) return ! 0
                            }
                        }
                        return i
                    })(E.p, d[A].p) && (b !== A && x.push({
                        froms: b,
                        tos: A,
                        hole: S
                    }), T ? (T = false, p[A].push(E)) : _ = true);
                    T && p[b].push(E)
                }
                x.length > 0 && (_ || (m = p))
            }
            for (var C, g = 0,
            P = d.length; g < P; g++) {
                c = d[g].s,
                h.push(c),
                C = m[g];
                for (var L = 0,
                R = C.length; L < R; L++) c.holes.push(C[L].h)
            }
            return h
        }
    })
},
xs6E: function(t, e, n) {
    "use strict";
    function i(t, e, n, i, o, s, u) {
        function c(t, e) {
            if (t.width > e || t.height > e) {
                var n = e / Math.max(t.width, t.height),
                i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                i.width = Math.floor(t.width * n),
                i.height = Math.floor(t.height * n);
                return i.getContext("2d").drawImage(t, 0, 0, t.width, t.height, 0, 0, i.width, i.height),
                console.warn("THREE.WebGLRenderer: image is too big (" + t.width + "x" + t.height + "). Resized to " + i.width + "x" + i.height, t),
                i
            }
            return t
        }
        function h(t) {
            return a.a.isPowerOfTwo(t.width) && a.a.isPowerOfTwo(t.height)
        }
        function l(t) {
            if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement) {
                var e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                e.width = a.a.nearestPowerOfTwo(t.width),
                e.height = a.a.nearestPowerOfTwo(t.height);
                return e.getContext("2d").drawImage(t, 0, 0, e.width, e.height),
                console.warn("THREE.WebGLRenderer: image is not power of two (" + t.width + "x" + t.height + "). Resized to " + e.width + "x" + e.height, t),
                e
            }
            return t
        }
        function f(t) {
            return t.wrapS !== r.j || t.wrapT !== r.j || t.minFilter !== r._5 && t.minFilter !== r.Q
        }
        function p(t, e) {
            return t.generateMipmaps && e && t.minFilter !== r._5 && t.minFilter !== r.Q
        }
        function d(e) {
            return e === r._5 || e === r._7 || e === r._6 ? t.NEAREST: t.LINEAR
        }
        function m(t) {
            var e = t.target;
            e.removeEventListener("dispose", m),
            g(e),
            u.textures--
        }
        function v(t) {
            var e = t.target;
            e.removeEventListener("dispose", v),
            y(e),
            u.textures--
        }
        function g(e) {
            var n = i.get(e);
            if (e.image && n.__image__webglTextureCube) t.deleteTexture(n.__image__webglTextureCube);
            else {
                if (undefined === n.__webglInit) return;
                t.deleteTexture(n.__webglTexture)
            }
            i.remove(e)
        }
        function y(e) {
            var n = i.get(e),
            r = i.get(e.texture);
            if (e) {
                if (undefined !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube) for (var a = 0; a < 6; a++) t.deleteFramebuffer(n.__webglFramebuffer[a]),
                n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[a]);
                else t.deleteFramebuffer(n.__webglFramebuffer),
                n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                i.remove(e.texture),
                i.remove(e)
            }
        }
        function _(e, r) {
            var a = i.get(e);
            if (e.version > 0 && a.__version !== e.version) {
                var o = e.image;
                if (undefined === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
                else {
                    if (false !== o.complete) return void M(a, e, r);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e)
                }
            }
            n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_2D, a.__webglTexture)
        }
        function x(e, a) {
            var l = i.get(e);
            if (6 === e.image.length) if (e.version > 0 && l.__version !== e.version) {
                l.__image__webglTextureCube || (e.addEventListener("dispose", m), l.__image__webglTextureCube = t.createTexture(), u.textures++),
                n.activeTexture(t.TEXTURE0 + a),
                n.bindTexture(t.TEXTURE_CUBE_MAP, l.__image__webglTextureCube),
                t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, e.flipY);
                for (var f = e && e.isCompressedTexture,
                d = e.image[0] && e.image[0].isDataTexture, v = [], g = 0; g < 6; g++) v[g] = f || d ? d ? e.image[g].image: e.image[g] : c(e.image[g], o.maxCubemapSize);
                var y = v[0],
                _ = h(y),
                x = s(e.format),
                b = s(e.type);
                w(t.TEXTURE_CUBE_MAP, e, _);
                for (var g = 0; g < 6; g++) if (f) for (var M, S = v[g].mipmaps, E = 0, T = S.length; E < T; E++) M = S[E],
                e.format !== r._22 && e.format !== r._30 ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, E, x, M.width, M.height, 0, M.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, E, x, M.width, M.height, 0, x, b, M.data);
                else d ? n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, x, v[g].width, v[g].height, 0, x, b, v[g].data) : n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + g, 0, x, x, b, v[g]);
                p(e, _) && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                l.__version = e.version,
                e.onUpdate && e.onUpdate(e)
            } else n.activeTexture(t.TEXTURE0 + a),
            n.bindTexture(t.TEXTURE_CUBE_MAP, l.__image__webglTextureCube)
        }
        function b(e, r) {
            n.activeTexture(t.TEXTURE0 + r),
            n.bindTexture(t.TEXTURE_CUBE_MAP, i.get(e).__webglTexture)
        }
        function w(n, a, u) {
            var c;
            if (u ? (t.texParameteri(n, t.TEXTURE_WRAP_S, s(a.wrapS)), t.texParameteri(n, t.TEXTURE_WRAP_T, s(a.wrapT)), t.texParameteri(n, t.TEXTURE_MAG_FILTER, s(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, s(a.minFilter))) : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), a.wrapS === r.j && a.wrapT === r.j || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", a), t.texParameteri(n, t.TEXTURE_MAG_FILTER, d(a.magFilter)), t.texParameteri(n, t.TEXTURE_MIN_FILTER, d(a.minFilter)), a.minFilter !== r._5 && a.minFilter !== r.Q && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", a)), c = e.get("EXT_texture_filter_anisotropic")) {
                if (a.type === r.C && null === e.get("OES_texture_float_linear")) return;
                if (a.type === r.I && null === e.get("OES_texture_half_float_linear")) return; (a.anisotropy > 1 || i.get(a).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, o.getMaxAnisotropy())), i.get(a).__currentAnisotropy = a.anisotropy)
            }
        }
        function M(e, i, a) {
            undefined === e.__webglInit && (e.__webglInit = true, i.addEventListener("dispose", m), e.__webglTexture = t.createTexture(), u.textures++),
            n.activeTexture(t.TEXTURE0 + a),
            n.bindTexture(t.TEXTURE_2D, e.__webglTexture),
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, i.flipY),
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
            t.pixelStorei(t.UNPACK_ALIGNMENT, i.unpackAlignment);
            var d = c(i.image, o.maxTextureSize);
            f(i) && false === h(d) && (d = l(d));
            var v = h(d),
            g = s(i.format),
            y = s(i.type);
            w(t.TEXTURE_2D, i, v);
            var _, x = i.mipmaps;
            if (i.isDepthTexture) {
                var b = t.DEPTH_COMPONENT;
                if (i.type === r.C) {
                    if (!L) throw new Error("Float Depth Texture only supported in WebGL2.0");
                    b = t.DEPTH_COMPONENT32F
                } else L && (b = t.DEPTH_COMPONENT16);
                i.format === r.s && b === t.DEPTH_COMPONENT && i.type !== r._59 && i.type !== r._55 && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = r._59, y = s(i.type)),
                i.format === r.t && (b = t.DEPTH_STENCIL, i.type !== r._54 && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = r._54, y = s(i.type))),
                n.texImage2D(t.TEXTURE_2D, 0, b, d.width, d.height, 0, g, y, null)
            } else if (i.isDataTexture) if (x.length > 0 && v) {
                for (var M = 0,
                S = x.length; M < S; M++) _ = x[M],
                n.texImage2D(t.TEXTURE_2D, M, g, _.width, _.height, 0, g, y, _.data);
                i.generateMipmaps = false
            } else n.texImage2D(t.TEXTURE_2D, 0, g, d.width, d.height, 0, g, y, d.data);
            else if (i.isCompressedTexture) for (var M = 0,
            S = x.length; M < S; M++) _ = x[M],
            i.format !== r._22 && i.format !== r._30 ? n.getCompressedTextureFormats().indexOf(g) > -1 ? n.compressedTexImage2D(t.TEXTURE_2D, M, g, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(t.TEXTURE_2D, M, g, _.width, _.height, 0, g, y, _.data);
            else if (x.length > 0 && v) {
                for (var M = 0,
                S = x.length; M < S; M++) _ = x[M],
                n.texImage2D(t.TEXTURE_2D, M, g, g, y, _);
                i.generateMipmaps = false
            } else n.texImage2D(t.TEXTURE_2D, 0, g, g, y, d);
            p(i, v) && t.generateMipmap(t.TEXTURE_2D),
            e.__version = i.version,
            i.onUpdate && i.onUpdate(i)
        }
        function S(e, r, a, o) {
            var u = s(r.texture.format),
            c = s(r.texture.type);
            n.texImage2D(o, 0, u, r.width, r.height, 0, u, c, null),
            t.bindFramebuffer(t.FRAMEBUFFER, e),
            t.framebufferTexture2D(t.FRAMEBUFFER, a, o, i.get(r.texture).__webglTexture, 0),
            t.bindFramebuffer(t.FRAMEBUFFER, null)
        }
        function E(e, n) {
            t.bindRenderbuffer(t.RENDERBUFFER, e),
            n.depthBuffer && !n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_COMPONENT16, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, e)) : n.depthBuffer && n.stencilBuffer ? (t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, n.width, n.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, e)) : t.renderbufferStorage(t.RENDERBUFFER, t.RGBA4, n.width, n.height),
            t.bindRenderbuffer(t.RENDERBUFFER, null)
        }
        function T(e, n) {
            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported!");
            if (t.bindFramebuffer(t.FRAMEBUFFER, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = true),
            _(n.depthTexture, 0);
            var a = i.get(n.depthTexture).__webglTexture;
            if (n.depthTexture.format === r.s) t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.TEXTURE_2D, a, 0);
            else {
                if (n.depthTexture.format !== r.t) throw new Error("Unknown depthTexture format");
                t.framebufferTexture2D(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.TEXTURE_2D, a, 0)
            }
        }
        function A(e) {
            var n = i.get(e),
            r = true === e.isWebGLRenderTargetCube;
            if (e.depthTexture) {
                if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                T(n.__webglFramebuffer, e)
            } else if (r) {
                n.__webglDepthbuffer = [];
                for (var a = 0; a < 6; a++) t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer[a]),
                n.__webglDepthbuffer[a] = t.createRenderbuffer(),
                E(n.__webglDepthbuffer[a], e)
            } else t.bindFramebuffer(t.FRAMEBUFFER, n.__webglFramebuffer),
            n.__webglDepthbuffer = t.createRenderbuffer(),
            E(n.__webglDepthbuffer, e);
            t.bindFramebuffer(t.FRAMEBUFFER, null)
        }
        function C(e) {
            var r = i.get(e),
            a = i.get(e.texture);
            e.addEventListener("dispose", v),
            a.__webglTexture = t.createTexture(),
            u.textures++;
            var o = true === e.isWebGLRenderTargetCube,
            s = h(e);
            if (o) {
                r.__webglFramebuffer = [];
                for (var c = 0; c < 6; c++) r.__webglFramebuffer[c] = t.createFramebuffer()
            } else r.__webglFramebuffer = t.createFramebuffer();
            if (o) {
                n.bindTexture(t.TEXTURE_CUBE_MAP, a.__webglTexture),
                w(t.TEXTURE_CUBE_MAP, e.texture, s);
                for (var c = 0; c < 6; c++) S(r.__webglFramebuffer[c], e, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + c);
                p(e.texture, s) && t.generateMipmap(t.TEXTURE_CUBE_MAP),
                n.bindTexture(t.TEXTURE_CUBE_MAP, null)
            } else n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
            w(t.TEXTURE_2D, e.texture, s),
            S(r.__webglFramebuffer, e, t.COLOR_ATTACHMENT0, t.TEXTURE_2D),
            p(e.texture, s) && t.generateMipmap(t.TEXTURE_2D),
            n.bindTexture(t.TEXTURE_2D, null);
            e.depthBuffer && A(e)
        }
        function P(e) {
            var r = e.texture;
            if (p(r, h(e))) {
                var a = e.isWebGLRenderTargetCube ? t.TEXTURE_CUBE_MAP: t.TEXTURE_2D,
                o = i.get(r).__webglTexture;
                n.bindTexture(a, o),
                t.generateMipmap(a),
                n.bindTexture(a, null)
            }
        }
        var L = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext;
        this.setTexture2D = _,
        this.setTextureCube = x,
        this.setTextureCubeDynamic = b,
        this.setupRenderTarget = C,
        this.updateRenderTargetMipmap = P
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("RBSo"),
    a = n("_Math")
},
PopModelHeader: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return r
    });
    var i = n("PopModelAttributes"),
    r = function() {
        function t() {}
        return t.prototype.readFromStream = function(t) {
            this.version = t.readSwappedShort(),
            this.attributes = new PopModelAttributes(),
            this.attributes.readFromStream(t)
        },
        t
    } ()
},
y5LD: function(t, e, n) {
    "use strict";
    e.a = "uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\\t#include <clipping_planes_fragment>\\n\\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\\tvec3 totalEmissiveRadiance = emissive;\\n\\t#include <logdepthbuf_fragment>\\n\\t#include <map_fragment>\\n\\t#include <color_fragment>\\n\\t#include <alphamap_fragment>\\n\\t#include <alphatest_fragment>\\n\\t#include <specularmap_fragment>\\n\\t#include <emissivemap_fragment>\\n\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\\t#include <lightmap_fragment>\\n\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\\t#ifdef DOUBLE_SIDED\\n\\t\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\\t#else\\n\\t\\treflectedLight.directDiffuse = vLightFront;\\n\\t#endif\\n\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\\t#include <aomap_fragment>\\n\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\\t#include <normal_flip>\\n\\t#include <envmap_fragment>\\n\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\\t#include <tonemapping_fragment>\\n\\t#include <encodings_fragment>\\n\\t#include <fog_fragment>\\n\\t#include <premultiplied_alpha_fragment>\\n\\t#include <dithering_fragment>\\n}\\n"
},
y6Pz: function(t, e, n) {
    "use strict";
    function i(t, e, n, i) {
        r.a.call(this, t, e, n, i)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("R+5/"),
    a = n("Quaternion");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        interpolate_: function(t, e, n, i) {
            for (var r = this.resultBuffer,
            o = this.sampleValues,
            s = this.valueSize,
            u = t * s,
            c = (n - e) / (i - e), h = u + s; u !== h; u += 4) a.a.slerpFlat(r, 0, o, u - s, o, u, c);
            return r
        }
    })
},
y6cm: function(t, e, n) {
    "use strict";
    e.a = "\\nvec3 transformed = vec3( position );\\n"
},
yAYr: function(t, e, n) {
    "use strict";
    function i(t, e, n, i, a) {
        r.a.call(this),
        this.lensFlares = [],
        this.positionScreen = new s.a,
        this.customUpdateCallback = undefined,
        undefined !== t && this.add(t, e, n, i, a)
    }
    var r = n("Object3D"),
    a = n("RBSo"),
    o = n("Color"),
    s = n("Vector3");
    i.prototype = Object.assign(Object.create(r.a.prototype), {
        constructor: i,
        isLensFlare: true,
        copy: function(t) {
            r.a.prototype.copy.call(this, t),
            this.positionScreen.copy(t.positionScreen),
            this.customUpdateCallback = t.customUpdateCallback;
            for (var e = 0,
            n = t.lensFlares.length; e < n; e++) this.lensFlares.push(t.lensFlares[e]);
            return this
        },
        add: function(t, e, n, i, r, s) {
            undefined === e && (e = -1),
            undefined === n && (n = 0),
            undefined === s && (s = 1),
            undefined === r && (r = new o.a(16777215)),
            undefined === i && (i = a._12),
            n = Math.min(n, Math.max(0, n)),
            this.lensFlares.push({
                texture: t,
                size: e,
                distance: n,
                x: 0,
                y: 0,
                z: 0,
                scale: 1,
                rotation: 0,
                opacity: s,
                color: r,
                blending: i
            })
        },
        updateLensFlares: function() {
            var t, e, n = this.lensFlares.length,
            i = 2 * -this.positionScreen.x,
            r = 2 * -this.positionScreen.y;
            for (t = 0; t < n; t++) e = this.lensFlares[t],
            e.x = this.positionScreen.x + i * e.distance,
            e.y = this.positionScreen.y + r * e.distance,
            e.wantedRotation = e.x * Math.PI * .25,
            e.rotation += .25 * (e.wantedRotation - e.rotation)
        }
    })
},
yErb: function(t, e, n) {
    "use strict";
    function i(t, e) {
        this.start = undefined !== t ? t: new r.a,
        this.end = undefined !== e ? e: new r.a
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("Vector3"),
    a = n("_Math");
    Object.assign(i.prototype, {
        set: function(t, e) {
            return this.start.copy(t),
            this.end.copy(e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(t) {
            return this.start.copy(t.start),
            this.end.copy(t.end),
            this
        },
        getCenter: function(t) {
            return (t || new r.a).addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(t) {
            return (t || new r.a).subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(t, e) {
            var n = e || new r.a;
            return this.delta(n).multiplyScalar(t).add(this.start)
        },
        closestPointToPointParameter: function() {
            var t = new r.a,
            e = new r.a;
            return function(n, i) {
                t.subVectors(n, this.start),
                e.subVectors(this.end, this.start);
                var r = e.dot(e),
                o = e.dot(t),
                s = o / r;
                return i && (s = a.a.clamp(s, 0, 1)),
                s
            }
        } (),
        closestPointToPoint: function(t, e, n) {
            var i = this.closestPointToPointParameter(t, e),
            a = n || new r.a;
            return this.delta(a).multiplyScalar(i).add(this.start)
        },
        applyMatrix4: function(t) {
            return this.start.applyMatrix4(t),
            this.end.applyMatrix4(t),
            this
        },
        equals: function(t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    })
},
yIBW: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_FOG\\n\\t#ifdef FOG_EXP2\\n\\t\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\n\\t#else\\n\\t\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\\t#endif\\n\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n"
},
yKmP: function(t, e, n) {
    "use strict";
    function i(t, e) {
        this.uuid = r.a.generateUUID(),
        this.array = t,
        this.stride = e,
        this.count = undefined !== t ? t.length / e: 0,
        this.dynamic = false,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.onUploadCallback = function() {},
        this.version = 0
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("_Math");
    Object.defineProperty(i.prototype, "needsUpdate", {
        set: function(t) { ! 0 === t && this.version++
        }
    }),
    Object.assign(i.prototype, {
        isInterleavedBuffer: true,
        setArray: function(t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.count = undefined !== t ? t.length / this.stride: 0,
            this.array = t
        },
        setDynamic: function(t) {
            return this.dynamic = t,
            this
        },
        copy: function(t) {
            return this.array = new t.array.constructor(t.array),
            this.count = t.count,
            this.stride = t.stride,
            this.dynamic = t.dynamic,
            this
        },
        copyAt: function(t, e, n) {
            t *= this.stride,
            n *= e.stride;
            for (var i = 0,
            r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
            return this
        },
        set: function(t, e) {
            return undefined === e && (e = 0),
            this.array.set(t, e),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(t) {
            return this.onUploadCallback = t,
            this
        }
    })
},
yQK5: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return o
    });
    var i = n("Vector4"),
    r = n("Color"),
    o = {
        common: {
            diffuse: {
                value: new r.a(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new i.a(0, 0, 1, 1)
            },
            specularMap: {
                value: null
            },
            alphaMap: {
                value: null
            },
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Vector2(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new r.a(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new r.a(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            offsetRepeat: {
                value: new i.a(0, 0, 1, 1)
            }
        }
    }
},
yZzt: function(t, e, n) {
    "use strict";
    e.a = "#ifdef USE_SHADOWMAP\\n\\t#if NUM_DIR_LIGHTS > 0\\n\\t\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\\t\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_SPOT_LIGHTS > 0\\n\\t\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\\t\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\\t#endif\\n\\t#if NUM_POINT_LIGHTS > 0\\n\\t\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\\t\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\\t#endif\\n\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\\t\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\\t}\\n\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\\t\\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / size;\\n\\t\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\\t\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\\t\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\\t\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\\t\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\\t\\tvec2 f = fract( uv * size + 0.5 );\\n\\t\\tfloat a = mix( lb, lt, f.y );\\n\\t\\tfloat b = mix( rb, rt, f.y );\\n\\t\\tfloat c = mix( a, b, f.x );\\n\\t\\treturn c;\\n\\t}\\n\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tfloat shadow = 1.0;\\n\\t\\tshadowCoord.xyz /= shadowCoord.w;\\n\\t\\tshadowCoord.z += shadowBias;\\n\\t\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\\t\\tbool inFrustum = all( inFrustumVec );\\n\\t\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\t\\tbool frustumTest = all( frustumTestVec );\\n\\t\\tif ( frustumTest ) {\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\\t\\t\\tfloat dx0 = - texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy0 = - texelSize.y * shadowRadius;\\n\\t\\t\\tfloat dx1 = + texelSize.x * shadowRadius;\\n\\t\\t\\tfloat dy1 = + texelSize.y * shadowRadius;\\n\\t\\t\\tshadow = (\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\\t\\t\\t\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\\t\\t#endif\\n\\t\\t}\\n\\t\\treturn shadow;\\n\\t}\\n\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\\t\\tvec3 absV = abs( v );\\n\\t\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\\t\\tabsV *= scaleToCube;\\n\\t\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\\t\\tvec2 planar = v.xy;\\n\\t\\tfloat almostATexel = 1.5 * texelSizeY;\\n\\t\\tfloat almostOne = 1.0 - almostATexel;\\n\\t\\tif ( absV.z >= almostOne ) {\\n\\t\\t\\tif ( v.z > 0.0 )\\n\\t\\t\\t\\tplanar.x = 4.0 - v.x;\\n\\t\\t} else if ( absV.x >= almostOne ) {\\n\\t\\t\\tfloat signX = sign( v.x );\\n\\t\\t\\tplanar.x = v.z * signX + 2.0 * signX;\\n\\t\\t} else if ( absV.y >= almostOne ) {\\n\\t\\t\\tfloat signY = sign( v.y );\\n\\t\\t\\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\\t\\t\\tplanar.y = v.z * signY - 2.0;\\n\\t\\t}\\n\\t\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\\t}\\n\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\\t\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\\t\\tvec3 lightToPosition = shadowCoord.xyz;\\n\\t\\tvec3 bd3D = normalize( lightToPosition );\\n\\t\\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\\t\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\t\\t\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\\t\\t\\treturn (\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\\t\\t\\t\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\\t\\t\\t) * ( 1.0 / 9.0 );\\n\\t\\t#else\\n\\t\\t\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\\t\\t#endif\\n\\t}\\n#endif\\n"
},
PopChunksContent: function(t, e, n) {
    "use strict";
    n.d(e, "a",
    function() {
        return r
    });
    // var i = n("u0MW"),
    var o = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            for (var n = [], i = 0; i < e; i++) n.push(t.readSwappedInt());
            return n
        },
        t
    } (),
    s = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            for (var n = [], i = 0; i < e; i++) n.push(t.readSwappedShort());
            return n
        },
        t
    } (),
    u = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            for (var n = [], i = 0; i < e; i++) n.push(t.readSwappedShort() + 32767);
            return n
        },
        t
    } (),
    c = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            var n = [],
            i = t.readZigzag(),
            r = t.readZigzag(),
            a = t.readZigzag();
            if (n.push(i, r, a), e % 3 != 0) throw new Error("Invalid VriantArray data ");
            for (var o = 1; o < e / 3; o++) i += t.readZigzag(),
            n.push(i),
            r += t.readZigzag(),
            n.push(r),
            a += t.readZigzag(),
            n.push(a);
            return n
        },
        t
    } (),
    h = function() {
        function t() {}
        return t.prototype.read = function(t, e) {
            if (e <= 0) return [];
            var n = [],
            i = t.readZigzag(),
            r = t.readZigzag();
            if (n.push(i, r), e % 2 != 0) throw new Error("Invalid TwoStepVriantArray data ");
            for (var a = 1; a < e / 2; a++) i += t.readZigzag(),
            n.push(i),
            r += t.readZigzag(),
            n.push(r);
            return n
        },
        t
    } (),
    l = function() {
        function t() {}
        return t.prototype.read = function(e, n) {
            if (n <= 0) return [];
            for (var i = t.BITS,
            a = new r.a(e), o = [], s = 0; s < n; s++) o.push(a.read(i));
            for (var u = 0,
            c = [], s = 0; s < n; s++) if (0 === o[s]) c.push(u);
            else {
                var h = a.read(o[s]),
                l = 1 << o[s] - 1;
                h < l && (h = -h - l),
                h += u,
                c.push(h),
                u = h
            }
            return c
        },
        t.BITS = 5,
        t
    } (),
    f = function() {
        function t() {}
        return t.prototype.read = function(e, n) {
            if (n <= 0) return [];
            for (var i = t.BITS,
            a = t.STRIDE,
            o = new r.a(e), s = [0, 0], u = [], c = 0; c < n / a; c++) u.push(o.read(i));
            for (var h = [], c = 0; c < n / a; c++) {
                var l = u[c];
                if (0 === l) for (var f = 0; f < a; f++) h.push(s[f]);
                else for (var f = 0; f < a; f++) {
                    var p = o.read(l),
                    d = 1 << l - 1;
                    p = p - d + s[f],
                    h.push(p),
                    s[f] = p
                }
            }
            return h
        },
        t.BITS = 5,
        t.STRIDE = 2,
        t
    } (),
    p = function() {
        function t() {}
        return t.prototype.read = function(e, n) {
            if (n <= 0) return [];
            for (var i = t.BITS,
            a = t.STRIDE,
            o = new r.a(e), s = [0, 0, 0], u = [], c = 0; c < n / a; c++) u.push(o.read(i));
            for (var h = [], c = 0; c < n / a; c++) {
                var l = u[c];
                if (0 === l) for (var f = 0; f < a; f++) h.push(s[f]);
                else for (var f = 0; f < a; f++) {
                    var p = o.read(l),
                    d = 1 << l - 1;
                    p = p - d + s[f],
                    h.push(p),
                    s[f] = p
                }
            }
            return h
        },
        t.BITS = 5,
        t.STRIDE = 3,
        t
    } (),
    d = {
        0 : new o,
        1 : new s,
        2 : new u,
        3 : new c,
        4 : new h,
        5 : new l,
        6 : new f,
        7 : new p
    }

    function inlineFunction(t) {
        var e = t.readByte(),
        n = t.readSwappedInt(),
        i = t.readSwappedInt();
        if (i < 0) throw new Error("Illegal data array length " + i);
        if (0 === i) return [];
        var r = t.readBytes(n),
        o = r.length;
        if (o < n) throw new Error("Not enough data!we need " + n + "bytes, but only read " + o + "bytes.type is " + e);
        var s = new PopModelData(r),
        u = d[e];
        if (u) return u.read(s, i);
        throw new Error("Illegal data array type ")
    }

    r = function() {
        function t() {}
        return t.prototype.readFromStream = function(t) {
            this.vertices = inlineFunction(t),
            this.normals = inlineFunction(t),
            this.textures = inlineFunction(t),
            this.indices = inlineFunction(t)
        },
        t
    } ()
},
ytBM: function(t, e, n) {
    "use strict";
    function i(t, e, n, i) {
        var r = t._events[e];
        if (r.fn) return void(r.priority = i);
        r.find(function(t) {
            return t.fn === n
        }).priority = i,
        r.sort(function(t, e) {
            return e.priority - t.priority
        })
    }
    function r(t) {
        t.emit = function(t, e, n, i, r, s) {
            var u = a.EventEmitter.prefixed,
            c = u ? u + t: t;
            if (!this._events[c]) return ! 1;
            var h, l, f = this._events[c],
            p = arguments.length,
            d = false;
            if (f.fn) {
                switch (f.once && this.removeListener(t, f.fn, undefined, true), p) {
                case 1:
                    return f.fn.call(f.context),
                    true;
                case 2:
                    return f.fn.call(f.context, e),
                    true;
                case 3:
                    return f.fn.call(f.context, e, n),
                    true;
                case 4:
                    return f.fn.call(f.context, e, n, i),
                    true;
                case 5:
                    return f.fn.call(f.context, e, n, i, r),
                    true;
                case 6:
                    return f.fn.call(f.context, e, n, i, r, s),
                    true
                }
                for (l = 1, h = new Array(p - 1); l < p; l++) h[l - 1] = arguments[l];
                f.fn.apply(f.context, h)
            } else {
                var m = f.length,
                v = undefined;
                for (l = 0; l < m; l++) {
                    switch (f[l].once && this.removeListener(t, f[l].fn, undefined, true), p) {
                    case 1:
                        d = f[l].fn.call(f[l].context) === o;
                        break;
                    case 2:
                        d = f[l].fn.call(f[l].context, e) === o;
                        break;
                    case 3:
                        d = f[l].fn.call(f[l].context, e, n) === o;
                        break;
                    case 4:
                        d = f[l].fn.call(f[l].context, e, n, i) === o;
                        break;
                    default:
                        if (!h) for (v = 1, h = new Array(p - 1); v < p; v++) h[v - 1] = arguments[v];
                        d = f[l].fn.apply(f[l].context, h) === o
                    }
                    if (d) break
                }
            }
            return ! 0
        }
    }
    n.d(e, "a",
    function() {
        return s
    });
    var a = n("BzvE"),
    o = (n.n(a), {}),
    s = function() {
        function t() {
            this._emitter = new a.EventEmitter,
            r(this._emitter)
        }
        return t.prototype.emit = function() {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            return this._emitter.emit(t[0].symbol, t[1]),
            this
        },
        t.prototype.on = function(t, e, n) {
            return undefined === n && (n = 0),
            this._emitter.on(t.symbol, e),
            i(this._emitter, t.symbol, e, n),
            this
        },
        t.prototype.off = function(t, e) {
            return this._emitter.off(t.symbol, e),
            this
        },
        t.prototype.listeners = function(t, e) {
            return undefined === e && (e = false),
            this._emitter.listeners(t.symbol, e)
        },
        t.prototype.getSession = function() {
            return new u(this)
        },
        t.getInstance = function() {
            return this.instance || (this.instance = new t),
            this.instance
        },
        t.getSession = function(e) {
            return undefined === e && (e = t.getInstance()),
            new u(e instanceof u ? e.rawEventBus: e)
        },
        t.EVENT_STOPPED = o,
        t
    } (),
    u = function() {
        function t(t) {
            this.eventBus = t,
            this.listenters = [],
            this.rawEventBus = t
        }
        return t.prototype.on = function(t, e, n) {
            return undefined === n && (n = 0),
            this.listenters.push({
                type: t,
                handler: e,
                priority: n
            }),
            this.rawEventBus.on(t, e, n),
            this
        },
        t.prototype.off = function(t, e) {
            return this.rawEventBus.off(t, e),
            this
        },
        t.prototype.emit = function() {
            for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
            return this.rawEventBus.emit(t[0], t[1]),
            this
        },
        t.prototype.clear = function() {
            var t = this;
            this.listenters.forEach(function(e) {
                var n = e.type,
                i = e.handler;
                return t.rawEventBus.off(n, i)
            })
        },
        t
    } ()
},
yx72: function(t, e, n) {
    "use strict";
    e.a = "\\n#ifdef USE_FOG\\nfogDepth = -mvPosition.z;\\n#endif"
},
MeshPhysicalMaterial: function(t, e, n) {
    "use strict";
    function i(t) {
        r.a.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoat = 0,
        this.clearCoatRoughness = 0,
        this.setValues(t)
    }
    n.d(e, "a",
    function() {
        return i
    });
    var r = n("MeshStandardMaterial");
    i.prototype = Object.create(r.a.prototype),
    i.prototype.constructor = i,
    i.prototype.isMeshPhysicalMaterial = true,
    i.prototype.copy = function(t) {
        return r.a.prototype.copy.call(this, t),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = t.reflectivity,
        this.clearCoat = t.clearCoat,
        this.clearCoatRoughness = t.clearCoatRoughness,
        this
    }
},
"TextGeometry||TextBufferGeometry": function(t, e, n) {
    "use strict";
    function i(t, e) {
        a.a.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: t,
            parameters: e
        },
        this.fromBufferGeometry(new r(t, e)),
        this.mergeVertices()
    }
    function r(t, e) {
        e = e || {};
        var n = e.font;
        if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
        new a.a;
        var i = n.generateShapes(t, e.size, e.curveSegments);
        e.amount = undefined !== e.height ? e.height: 50,
        undefined === e.bevelThickness && (e.bevelThickness = 10),
        undefined === e.bevelSize && (e.bevelSize = 8),
        undefined === e.bevelEnabled && (e.bevelEnabled = false),
        o.a.call(this, i, e),
        this.type = "TextBufferGeometry"
    }
    var a = n("Geometry"),
    o = n("ExtrudeGeometry");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    r.prototype = Object.create(o.a.prototype),
    r.prototype.constructor = r
},
zVJs: function(t, e, n) {
    "use strict";
    function i(t, e, n, i) {
        this.uuid = r.a.generateUUID(),
        this.data = t,
        this.itemSize = e,
        this.offset = n,
        this.normalized = true === i
    }
    var r = n("_Math");
    Object.defineProperties(i.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(i.prototype, {
        isInterleavedBufferAttribute: true,
        setX: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e,
            this
        },
        setY: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e,
            this
        },
        setZ: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e,
            this
        },
        setW: function(t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e,
            this
        },
        getX: function(t) {
            return this.data.array[t * this.data.stride + this.offset]
        },
        getY: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        },
        getZ: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        },
        getW: function(t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        },
        setXY: function(t, e, n) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this
        },
        setXYZ: function(t, e, n, i) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this
        },
        setXYZW: function(t, e, n, i, r) {
            return t = t * this.data.stride + this.offset,
            this.data.array[t + 0] = e,
            this.data.array[t + 1] = n,
            this.data.array[t + 2] = i,
            this.data.array[t + 3] = r,
            this
        }
    })
},
zeL8: function(t, e, n) {
    "use strict";
    function i(t, e) {
        a.a.call(this),
        this.light = t,
        this.light.updateMatrixWorld(),
        this.matrix = t.matrixWorld,
        this.matrixAutoUpdate = false,
        undefined === e && (e = 1);
        var n = new u.a;
        n.addAttribute("position", new s.b([ - e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
        var i = new c.a({
            fog: false
        });
        this.add(new o.a(n, i)),
        n = new u.a,
        n.addAttribute("position", new s.b([0, 0, 0, 0, 0, 1], 3)),
        this.add(new o.a(n, i)),
        this.update()
    }
    var r = n("Vector3"),
    a = n("Object3D"),
    o = n("Line"),
    s = n("BufferAttribute"),
    u = n("BufferGeometry"),
    c = n("LineBasicMaterial");
    i.prototype = Object.create(a.a.prototype),
    i.prototype.constructor = i,
    i.prototype.dispose = function() {
        var t = this.children[0],
        e = this.children[1];
        t.geometry.dispose(),
        t.material.dispose(),
        e.geometry.dispose(),
        e.material.dispose()
    },
    i.prototype.update = function() {
        var t = new r.a,
        e = new r.a,
        n = new r.a;
        return function() {
            t.setFromMatrixPosition(this.light.matrixWorld),
            e.setFromMatrixPosition(this.light.target.matrixWorld),
            n.subVectors(e, t);
            var i = this.children[0],
            r = this.children[1];
            i.lookAt(n),
            i.material.color.copy(this.light.color),
            r.lookAt(n),
            r.scale.z = n.length()
        }
    } ()
}
});
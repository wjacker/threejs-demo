<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - scene animation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				background-color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}
			a {
				color: #0af;
			}
			#panel {
				position: absolute;
				top: 0px; 
				bottom: 0px;
				right: 0px;
				width: 200px;
				padding: 5px;
				background: white;
				display: none;
			}
			#scene-panel {
				position: absolute;
				top: 0px; 
				right: 0px;
				width: 100px;
				padding: 5px;
				height: 100px;
				background: white;
				display: block;
			}
			.input-wrap {
				clear: both;
			}

			.object-menu-warp {
				position: fixed;
				left: 0;
				top: 0;
				background: #323232;
				border-radius: 20px 20px 20px 2px;
				color: #fff;
				display: none;
			}
			.object-menu .menu-item {
				display: inline-block;
				width: 34px;
				height: 34px;
				padding: 4px;
				line-height: 34px;
				position: relative;
				cursor: pointer;
				color: #fff;

			}

			.icon {
			    display: inline-block;
			    cursor: pointer;
				color: #fff;
			}

			#container {
				margin-left: 200px; 
			}

			#left-panel {
				position: absolute;
				top: 0px; 
				bottom: 0px;
				left: 0px;
				width: 200px;
				padding: 5px;
				background: white;
				display: block;
			}
			.left-panel .category_item {
			}

		</style>
	</head>

	<body>
		<div id="left-panel">
			<div class="category_list">
				<div class="category_item"><img src="test.jpg" width="100" height="100" /></div>
			</div>
		</div>
		<div id="container"></div>
		<div class="object-menu-warp">
			<div class="object-menu">
				<div id="objDelete" class="menu-item delete">
					<!-- <svg class="icon icon-delete"><use xlink:href="#delete"></use></svg> -->
					删除
				</div>
			</div>
		</div>
		<div id="scene-panel">
			<input id="exportScene" type="button" name="导出场景" value="导出场景"><br/><br/>
			<input id="importScene" type="button" name="导入场景" value="导入场景"><br/><br/>
			<input id="importObject" type="button" name="导入场景" value="导入对象"><br/><br/>
		</div>

		

		<div id="panel">
			<div class="input-wrap">
				长：<input id="obj_x" type="text" name="x"/> mm<br/>
				宽：<input id="obj_y" type="text" name="y"/> mm<br/>
				高：<input id="obj_z" type="text" name="z"/> mm<br/><br/>

				<input id="applyBtn" type="button" name="应用" value="应用"><br/><br/>
				<input id="exportObject" type="button" name="导出对象" value="导出对象"><br/><br/>

				
			</div>
		</div>

		<script src="jquery/jquery-3.3.1.min.js"></script>
		<script src="js/three.js"></script>

		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/controls/NiceControls.js"></script>
		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJLoader.js"></script>
		<script src="js/loaders/DDSLoader.js"></script>
		<script src="js/exporters/OBJExporter.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/objects/Reflector.js"></script>

		<script>
			var scene, camera, controls, stats;
			var renderer, mixer;
			var clock = new THREE.Clock();
			var url = 'scene.json';
			var SCENE_WIDTH;
			var SCENE_HEIGHT;
			var container = document.getElementById( 'container' );
			var transformControls;
			var orbitControls;
			var worker;

			var box = new THREE.Box3();

			var _draggingObject = null;
			var _dragging = false;


			$(function() {
				// stats = new Stats();
				// container.appendChild( stats.dom );
				SCENE_WIDTH = container.clientWidth;
				SCENE_HEIGHT = window.innerHeight;

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( SCENE_WIDTH, SCENE_HEIGHT );
				container.appendChild( renderer.domElement );

				raycaster = new THREE.Raycaster();//光线投射器
				mouse = new THREE.Vector2();//二维向量 
				container.addEventListener('mousemove', function(){
				    event.preventDefault();
				    mouse.x = ((event.clientX - $(container).offset().left) / SCENE_WIDTH) * 2 - 1;
				    mouse.y = -((event.clientY - $(container).offset().top) / SCENE_HEIGHT) * 2 + 1;

				    if(_draggingObject) {
				    	var object = _draggingObject;
				    	scene.add(object);
				    	_dragging = false;
				    	_draggingObject = null;

				    	box.setFromObject(object);
						object.rotation.x = Math.PI / 2;
						object.up.set(0, 0, 1);
						object.traverse(function ( child ) {
							child.userData.selectUUID = object.uuid;
							if(child.type == "Mesh") {
								child.geometry.translate(-(box.min.x + box.max.x)/2, -box.min.y, -(box.min.z + box.max.z)/2);
							}
						});

						transformControls.setAddObject(object);
				    }
				}, false);


				// Load a scene with objects, lights and camera from a JSON file
				new THREE.ObjectLoader().load( url, function ( loadedScene ) {
					scene = loadedScene;
					scene.background = new THREE.Color( 0xffffff );
					// If the loaded file contains a perspective camera, use it with adjusted aspect ratio...
					scene.traverse( function ( sceneChild ) {

					} );

					if ( camera === undefined ) {
						camera = new THREE.PerspectiveCamera( 60, SCENE_WIDTH / SCENE_HEIGHT, 100, 1000000 );
						camera.position.set( 0, -8500, 4000 );
						camera.up.set(0, 0, 1);
					}
					camera.lookAt(new THREE.Vector3(0,0,0));

					loadOBJ("models/washingmachine/", "washingmachine", "washingmachine", {x: 1000, y: 300});
					// loadOBJ("models/lamp/", "lamp", "lamp", {x: -1000, y: 300});
					// loadOBJ("models/chair/", "chair", "chair", {x: 0, y: -1000});
					// loadOBJ("models/table/", "table", "table", {x: 100, y: 0});
					// loadOBJ("models/sofa/", "sofa1", "sofa1", {x: 200, y: 300});
					// loadOBJ("models/sofa/", "sofa2", "sofa2", {x: 800, y: -600});

					loadOBJ("models/", "table_sofa", "table_sofa");
					loadOBJ("models/cabinet/", "cabinet", "cabinet", {x: 0, y:2200});
					loadOBJ("models/television/", "television", "television", {x: 800, y:2200, z:1000});
					
					

					loadOBJ("models/airconditioner/", "airconditioner", "airconditioner", {x: 1000, y: -200});
					loadOBJ("models/airconditioner/", "airconditioner2", "airconditioner2", {x: 2000, y: -800});
					
					
					addMirror(scene);


					orbitControls = new THREE.OrbitControls( camera, container);
					orbitControls.enableDamping = true;
					orbitControls.dampingFactor = 0.8;
					orbitControls.screenSpacePanning = false;
					orbitControls.minDistance = 1000;
					orbitControls.maxDistance = 50000;
					// orbitControls.maxPolarAngle = Math.PI / 2;


					orbitControls.addEventListener('change', function (event) {
						updateWall();
						requestAnimationFrame( render );
				    });

				    orbitControls.addEventListener('start', function (event) {
						$('.object-menu-warp').hide();
				    });

					orbitControls.addEventListener('end', function (event) {
						updateObjectInfo();
				    });

					render();
					updateWall();
					initTransformControls(camera, renderer, scene);
				} );

				function updateWall() {
					var frontWall = scene.getObjectByName("front-wall");
					box.setFromObject(frontWall);
					if(box.min.y >= camera.position.y) {
						frontWall.visible = false;
					} else {
						frontWall.visible = true;
					}

					var backWall = scene.getObjectByName("back-wall");
					box.setFromObject(backWall);
					if(box.max.y <= camera.position.y) {
						backWall.visible = false;
					} else {
						backWall.visible = true;
					}

					var leftWall = scene.getObjectByName("left-wall");
					box.setFromObject(leftWall);
					if(box.min.x >= camera.position.x) {
						leftWall.visible = false;
					} else {
						leftWall.visible = true;
					}

					var rightWall = scene.getObjectByName("right-wall");
					box.setFromObject(rightWall);
					if(box.max.x <= camera.position.x) {
						rightWall.visible = false;
					} else {
						rightWall.visible = true;
					}
				}

				function addMirror(scene){
					var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
					geometry.computeBoundingBox();
					geometry.translate(0, 500, 0);

					var verticalMirror = new THREE.Reflector( geometry, {
						clipBias: 0.003,
						textureWidth: SCENE_WIDTH * window.devicePixelRatio,
						textureHeight: SCENE_HEIGHT * window.devicePixelRatio,
						color: 0x889999,
						recursion: 1
					} );
					verticalMirror.userData.selectUUID = verticalMirror.uuid;
					verticalMirror.position.y = 2500;
					verticalMirror.position.z = 1200;
					verticalMirror.rotation.x = Math.PI / 2;

					scene.add( verticalMirror );
				}

				function loadOBJ(resourcePath, mtlName, objName, position, complete) {
					var onProgress = function ( xhr ) {
						if ( xhr.lengthComputable ) {
							var percentComplete = xhr.loaded / xhr.total * 100;
							console.log( Math.round( percentComplete, 2 ) + '% downloaded' );
						}
					};
					var onError = function ( xhr ) { };
					THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
					new THREE.MTLLoader()
						.setPath( resourcePath )
						.load( mtlName + '.mtl', function ( materials ) {
							materials.preload();
							new THREE.OBJLoader()
								.setMaterials( materials )
								.setPath( resourcePath )
								.load( objName + '.obj', function ( object ) {

									box.setFromObject(object);
									if(complete != undefined) {
										complete(object)
									} else {
										scene.add( object );
										if(position !== undefined) {
											if(position.x != undefined) {
												object.position.x = position.x;
											}

											if(position.y != undefined) {
												object.position.y = position.y;
											}

											if(position.z != undefined) {
												object.position.z = position.z;
											}
										}

										object.rotation.x = Math.PI / 2;
										object.up.set(0, 0, 1);
										object.traverse(function ( child ) {
											child.userData.selectUUID = object.uuid;
											if(child.type == "Mesh") {
												child.geometry.translate(-(box.min.x + box.max.x)/2, -box.min.y, -(box.min.z + box.max.z)/2);
											}
										});

										
										requestAnimationFrame(render);
									}
									

								}, onProgress, onError );
						} );
				}

				function render() {
					// if(stats){
					// 	stats.begin();
					// }
					renderer.render( scene, camera);
					// if(stats){
					// 	stats.end();
					// }
				}

				var selectObject;//定义上次投射到的对象
				function renderRaycasterObj(raycaster,scene,camera,mouse) {
				    raycaster.setFromCamera(mouse, camera);

				    var intersects = raycaster.intersectObjects(scene.children, true);
				    if (intersects.length > 0) {
				    	var currentProjectiveObjT;
				    	if(intersects[0].object.userData.selectUUID !== undefined) {
				    		currentProjectiveObjT = scene.getObjectByProperty( "uuid", intersects[0].object.userData.selectUUID )
				    	}
				    	
				        if (selectObject != currentProjectiveObjT) {
				            if((currentProjectiveObjT instanceof THREE.AxisHelper) || (currentProjectiveObjT instanceof THREE.GridHelper)){
				                //穿过的是坐标轴线和网格线
				                selectObject = null;
				                return;
				            }
				            selectObject = currentProjectiveObjT;
				        }
				    } else {
				        selectObject = null;
				    }
				    setSelectObject(selectObject);
				}

				function setSelectObject(obj) {
					selectObject = obj;
					if(selectObject) {
						transformControls.attach(selectObject);
				    	$('#obj_x').val((transformControls.objectSize.x).toFixed(0));
				    	$('#obj_y').val((transformControls.objectSize.y).toFixed(0));
				    	$('#obj_z').val((transformControls.objectSize.z).toFixed(0));
				    } else {
				    	transformControls.detach();
				    }

				    updateObjectInfo();
				    requestAnimationFrame( render );
				}

				$('.category_item').on('touchstart', onPointerDown);
				$('.category_item').on('mousedown', onPointerDown);
				function onPointerDown( event ) {
					event.preventDefault(); 

					if ( _dragging === true || ( event.button !== undefined && event.button !== 0 ) ) return;

					_dragging = true;

					if(transformControls.addObject != undefined) {
						scene.remove(transformControls.addObject);
						transformControls.addObject = undefined;
						requestAnimationFrame( render );
						_dragging = false;
						return;
					}

					loadOBJ("models/washingmachine/", "washingmachine", "washingmachine", {x: 1000, y: 300}, function(object) {
						_draggingObject = object;
						// scene.add( _draggingObject );
					});

				}

				$('category_item img').on('dragstart', function(event) { 
					event.preventDefault(); 

				});

				$('#applyBtn').click(function () {
					if(selectObject) {
						selectObject.scale.x = $('#obj_x').val()/transformControls.objectSize.x * selectObject.scale.x;
						selectObject.scale.y = $('#obj_z').val()/transformControls.objectSize.z * selectObject.scale.y;
						selectObject.scale.z = $('#obj_y').val()/transformControls.objectSize.y * selectObject.scale.z;
						requestAnimationFrame( render );
					}
				});

				$('#exportScene').click(function () {
					var output = scene.toJSON();

					try {
						output = JSON.stringify( output, parseNumber, '\t' );
						output = output.replace( /[\n\t]+([\d\.e\-\[\]]+)/g, '$1' );
					} catch ( e ) {
						output = JSON.stringify( output );
					}

					saveString( output, 'scene.json' );
				});

				$('#exportObject').click(function () {
					if ( selectObject === null ) {
						alert( '为选中导出对象' );
						return;
					}

					var output = selectObject.toJSON();

					try {
						output = JSON.stringify( output, parseNumber, '\t' );
						output = output.replace( /[\n\t]+([\d\.e\-\[\]]+)/g, '$1' );
					} catch ( e ) {
						output = JSON.stringify( output );
					}

					saveString( output, 'model.json' );
				});

				$('#objDelete').click(function () {
					if ( selectObject === null ) {
						return;
					}

					selectObject.parent.remove(selectObject);
					setSelectObject(null);
				});

				function saveString( text, filename ) {

					save( new Blob( [ text ], { type: 'text/plain' } ), filename );

				}

				var link = document.createElement( 'a' );
				link.style.display = 'none';
				document.body.appendChild( link ); // Firefox workaround, see #6594

				function save( blob, filename ) {

					link.href = URL.createObjectURL( blob );
					link.download = filename || 'data.json';
					link.click();
					// URL.revokeObjectURL( url ); breaks Firefox...
				}

				function toScreenPosition(object, camera) {
				    var vector = new THREE.Vector3();
				    var pos = new THREE.Vector3();
					var canvas = renderer.domElement;

					var box = new THREE.Box3();
					box.setFromObject(object);

					pos.copy(box.max);
				    projScreenMat = new THREE.Matrix4();
				    projScreenMat.multiply( camera.projectionMatrix, camera.matrixWorldInverse );
				    projScreenMat.multiplyVector3( pos );

				    return { x: ( pos.x + 1 ) * $(canvas).width() / 2 + $(canvas).offset().left,
				         y: ( - pos.y + 1) * $(canvas).height() / 2 + $(canvas).offset().top };
				};

				function updateObjectInfo() {
					if(selectObject) {
						var point = toScreenPosition(selectObject, camera);
				    	$('.object-menu-warp').css("transform", "translate(" + point.x + "px, " + point.y + "px) translate(0px, -100%)");
						$('.object-menu-warp').show();
						$('#panel').show();
					} else {
						$('.object-menu-warp').hide();
						$('#panel').hide();
					}
				}

				function initTransformControls (camera, renderer, scene){
					transformControls = new THREE.NiceControls(camera, renderer.domElement, scene);
					transformControls.setMoveRange(-4100, 3900, -1450, 2500, 0, 2800);

					transformControls.addEventListener('dragStart', function (event) {
						if(orbitControls != undefined) {
							orbitControls.enabled = false;
						}
				    });

					transformControls.addEventListener('dragEnd', function (event) {
				        if(orbitControls != undefined) {
							orbitControls.enabled = true;
						}
						updateObjectInfo();
				    });

				    // 拖拽结束
				    transformControls.addEventListener('mouseDown', function (event) {
				        if(orbitControls != undefined) {
							orbitControls.enabled = true;
						}
						$('.object-menu-warp').hide();
				    });

				    transformControls.addEventListener('change', function (event) {
						requestAnimationFrame( render );
				    });
					scene.add(transformControls);
				}

				renderer.domElement.addEventListener( 'click', function(){
	                renderRaycasterObj(raycaster,scene,camera,mouse);
	            }, false );

	            document.onselectstart = function() {
				  return false;
				}; 
			});
			
		</script>

	</body>
</html>